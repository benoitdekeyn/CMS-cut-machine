import solver from 'javascript-lp-solver'; // ou l'√©quivalent dans votre projet

/**
 * Adapte un pattern pour √©viter la surproduction en n'incluant que les pi√®ces n√©cessaires
 * @param {Object} pattern - Le pattern original √† adapter
 * @param {Map} remainingDemand - Demande restante pour chaque longueur de pi√®ce
 * @param {Number} iteration - Num√©ro de l'it√©ration actuelle
 * @returns {Object} Pattern modifi√© √©vitant la surproduction
 */
function adaptPatternToPreventOverproduction(pattern, remainingDemand, iteration) {
    // Analyser les pi√®ces du pattern original
    const pieceCounts = {};
    for (const pieceLength of pattern.pieces) {
        pieceCounts[pieceLength] = (pieceCounts[pieceLength] || 0) + 1;
    }
    
    // Cr√©er un pattern modifi√© pour √©viter la surproduction
    const modifiedPattern = {
        ...pattern,
        pieces: [],
        waste: pattern.waste,
        isModifiedPattern: true
    };
    let overproductionDetected = false;
    
    // Parcourir chaque type de pi√®ce dans le pattern et n'inclure que ce qui est n√©cessaire
    const usedPiecesLog = [];
    for (const [pieceLength, count] of Object.entries(pieceCounts)) {
        const lengthInt = parseInt(pieceLength, 10);
        const currentDemand = remainingDemand.get(lengthInt) || 0;
        
        // D√©terminer combien de pi√®ces de cette longueur peuvent √™tre utilis√©es
        const usableCount = Math.min(count, currentDemand);
        
        // Ajouter uniquement les pi√®ces n√©cessaires au pattern modifi√©
        for (let i = 0; i < usableCount; i++) {
            modifiedPattern.pieces.push(lengthInt);
        }
        
        // D√©duire de la demande restante
        if (usableCount > 0) {
            remainingDemand.set(lengthInt, currentDemand - usableCount);
            usedPiecesLog.push(`${usableCount}x${lengthInt}`);
        }
        
        // Signaler une surproduction potentielle
        if (count > currentDemand) {
            overproductionDetected = true;
            
            // Enregistrer les pi√®ces qui ont √©t√© supprim√©es pour √©viter la surproduction
            if (modifiedPattern.originInfo && modifiedPattern.originInfo.removedPieces) {
                for (let i = 0; i < count - usableCount; i++) {
                    modifiedPattern.originInfo.removedPieces.push(lengthInt);
                }
            }
            
            // Augmenter la chute pour les pi√®ces non utilis√©es
            modifiedPattern.waste += (count - usableCount) * lengthInt;
        }
    }
    
    // Si le pattern modifi√© ne contient pas assez de pi√®ces, il peut ne pas √™tre √©conomique de l'utiliser
    const originalUsage = pattern.pieces.reduce((sum, len) => sum + len, 0);
    const modifiedUsage = modifiedPattern.pieces.reduce((sum, len) => sum + len, 0);
    const usageRatio = modifiedUsage / (originalUsage || 1);
    
    // Transf√©rer l'identifiant du pattern original vers le pattern modifi√©
    modifiedPattern.originalPatternIndex = pattern.originalPatternIndex || pattern.id || -1;
    
    // Ajout des m√©tadonn√©es du pattern original pour le suivi
    modifiedPattern.originInfo = {
        originalPieces: [...pattern.pieces],
        removedPieces: overproductionDetected ? [] : null
    };
    
    // Rejeter le pattern si l'utilisation est trop faible (moins de 50%)
    if (usageRatio < 0.5 && modifiedPattern.pieces.length > 0) {
        modifiedPattern.hasUsablePieces = false;
        return modifiedPattern;
    }
    
    // Marquer si le pattern a √©t√© modifi√©
    modifiedPattern.isModified = overproductionDetected;
    modifiedPattern.hasUsablePieces = usedPiecesLog.length > 0;
    
    return modifiedPattern;
}

/**
 * R√©sout le probl√®me de d√©coupe de barres en utilisant la programmation lin√©aire en nombres entiers
 * avec le solveur jsLPSolver et des techniques avanc√©es de recherche op√©rationnelle.
 * 
 * @param {Object} motherBars - Dictionnaire des barres m√®res disponibles par mod√®le
 * @param {Object} pieces - Dictionnaire des pi√®ces √† d√©couper par mod√®le
 * @param {Function} progressCallback - Fonction de callback pour indiquer la progression
 * @returns {Object} R√©sultats de l'optimisation
 */
export function solveWithILP(motherBars, pieces, progressCallback = () => {}) {
    // V√©rifier que le solveur est charg√©
    if (typeof solver === 'undefined') {
        throw new Error("Le solveur jsLPSolver n'est pas d√©fini. Assurez-vous qu'il est correctement import√©.");
    }
    
    // Structure de r√©sultat finale
    const results = {};
    const globalStats = {
        totalBarsUsed: 0,
        totalWaste: 0,
        totalRemainingPieces: 0
    };

    console.log("D√©but de l'ex√©cution ILP optimis√©e");

    // Traiter chaque mod√®le s√©par√©ment
    for (const model in pieces) {
        if (pieces[model].length === 0 || !motherBars[model] || motherBars[model].length === 0) {
            continue;
        }

        progressCallback({ step: `Traitement du mod√®le ${model}`, percentage: 10 });

        // Initialiser les r√©sultats pour ce mod√®le
        const modelResult = {
            rawData: {
                usedBars: [],
                wasteLength: 0,
                totalMotherBarsUsed: 0,
                remainingPieces: [],
                motherBarLength: 0
            },
            layouts: []
        };

        try {
            console.log(`Optimisation du mod√®le ${model}`);
            
            // Pr√©parer les donn√©es
            const stockBars = prepareStockBarsData(motherBars[model]);
            const demandPieces = preparePiecesData(pieces[model]);
            
            // V√©rifier que les donn√©es sont valides
            if (demandPieces.length === 0) {
                console.log(`Mod√®le ${model} : aucune pi√®ce √† d√©couper`);
                continue;
            }
            
            if (stockBars.length === 0) {
                console.log(`Mod√®le ${model} : aucune barre m√®re disponible`);
                continue;
            }
            
            progressCallback({ step: `G√©n√©ration des patterns pour ${model}`, percentage: 30 });
            
            // G√©n√©rer des patterns de d√©coupe efficaces
            const initialPatterns = generatePatternsForBars(stockBars, demandPieces);
            console.log(`${initialPatterns.length} patterns g√©n√©r√©s pour le mod√®le ${model}`);
            
            // R√©soudre le probl√®me de d√©coupe avec la m√©thode la plus appropri√©e
            progressCallback({ step: `R√©solution ILP pour ${model}`, percentage: 70 });
            
            // R√©soudre avec la m√©thode principale (ILP) ou fallback si n√©cessaire
            const optimizationResult = solveWithCuttingStockILP(stockBars, demandPieces, initialPatterns);
            
            // Traiter les r√©sultats
            const processedResult = processOptimizationResult(optimizationResult, stockBars, demandPieces);
            
            // Mettre √† jour les statistiques globales
            globalStats.totalBarsUsed += processedResult.rawData.totalMotherBarsUsed;
            globalStats.totalWaste += processedResult.rawData.wasteLength;
            globalStats.totalRemainingPieces += processedResult.rawData.remainingPieces.length;
            
            // Assigner les r√©sultats pour ce mod√®le
            modelResult.rawData = processedResult.rawData;
            modelResult.layouts = processedResult.layouts;
            
            console.log(`Mod√®le ${model} trait√© : ${processedResult.rawData.totalMotherBarsUsed} barres utilis√©es`);
            
            // V√©rifier si des pi√®ces n'ont pas √©t√© d√©coup√©es
            if (processedResult.rawData.remainingPieces.length > 0) {
                console.warn(`‚ö†Ô∏è ${processedResult.rawData.remainingPieces.length} pi√®ces non d√©coup√©es pour le mod√®le ${model}`);
            }
            
        } catch (error) {
            console.error(`Erreur lors du traitement du mod√®le ${model}:`, error);
            
            // Essayer de r√©cup√©rer avec un algorithme glouton simple en cas d'erreur critique
            const stockBars = prepareStockBarsData(motherBars[model]);
            const demandPieces = preparePiecesData(pieces[model]);
            
            const fallbackResult = solveWithSimpleGreedy(stockBars, demandPieces);
            modelResult.rawData = fallbackResult.rawData;
            modelResult.layouts = fallbackResult.layouts;
            
            // Mettre √† jour les statistiques globales
            globalStats.totalBarsUsed += fallbackResult.rawData.totalMotherBarsUsed;
            globalStats.totalWaste += fallbackResult.rawData.wasteLength;
            globalStats.totalRemainingPieces += fallbackResult.rawData.remainingPieces.length;
            
            console.warn(`‚ö†Ô∏è Utilisation de l'algorithme de secours pour le mod√®le ${model}`);
        }
        
        // Calculer et afficher les statistiques pour ce mod√®le
        const stockBars = prepareStockBarsData(motherBars[model]);
        const demandPieces = preparePiecesData(pieces[model]);
        const modelStats = calculateModelStats(modelResult, stockBars, demandPieces);
        
        // Afficher uniquement les informations essentielles
        console.log(`üìä Mod√®le ${model}: ${modelResult.rawData.totalMotherBarsUsed} barres utilis√©es, taux d'utilisation: ${modelStats.utilizationRate}%`);
        
        // Ajouter les r√©sultats et statistiques pour ce mod√®le
        results[model] = {
            ...modelResult,
            stats: modelStats
        };
        
        progressCallback({ step: `Mod√®le ${model} termin√©`, percentage: 100 });
    }

    // Calculer les statistiques globales
    const globalStatistics = {
        totalDemandLength: 0,
        totalStockLength: 0,
        totalUsedLength: 0,
        totalWasteLength: 0,
        totalBarsLength: 0  // Ajouter cette ligne
    };
    
    for (const model in results) {
        if (results[model].stats) {
            globalStatistics.totalDemandLength += results[model].stats.totalDemandLength;
            globalStatistics.totalStockLength += results[model].stats.totalStockLength;
            globalStatistics.totalUsedLength += results[model].stats.totalUsedLength;
            globalStatistics.totalWasteLength += results[model].stats.totalWasteLength;
            
            // Ajouter le calcul de la longueur totale des barres
            if (results[model].rawData && results[model].rawData.usedBars) {
                globalStatistics.totalBarsLength += results[model].rawData.usedBars.reduce(
                    (sum, bar) => sum + bar.originalLength, 0
                );
            }
        }
    }
    
    // Calculer le taux d'utilisation global bas√© sur le ratio correct
    globalStatistics.utilizationRate = globalStatistics.totalBarsLength > 0 
        ? ((globalStatistics.totalUsedLength / globalStatistics.totalBarsLength) * 100).toFixed(3) 
        : 0;
    
    // Afficher uniquement une ligne de statistique importante globale
    console.log(`üìà GLOBAL: ${globalStats.totalBarsUsed} barres utilis√©es, taux d'utilisation: ${globalStatistics.utilizationRate}%`);

    return {
        modelResults: results,
        globalStats: {...globalStats, statistics: globalStatistics}
    };
}

/**
 * Pr√©pare les donn√©es des barres m√®res
 * @param {Array} motherBars - Liste des barres m√®res
 * @returns {Array} Donn√©es pr√©par√©es
 */
function prepareStockBarsData(motherBars) {
    const stockBars = [];
    
    for (const bar of motherBars) {
        stockBars.push({
            length: parseInt(bar.length, 10),
            quantity: parseInt(bar.quantity, 10)
        });
    }
    
    // Tri par ordre d√©croissant de longueur
    stockBars.sort((a, b) => b.length - a.length);
    return stockBars;
}

/**
 * Pr√©pare les donn√©es des pi√®ces √† d√©couper
 * @param {Array} pieces - Liste des pi√®ces
 * @returns {Array} Donn√©es pr√©par√©es
 */
function preparePiecesData(pieces) {
    const demandPieces = [];
    
    for (const piece of pieces) {
        demandPieces.push({
            length: parseInt(piece.length, 10),
            quantity: parseInt(piece.quantity, 10)
        });
    }
    
    // Tri par ordre d√©croissant de longueur
    demandPieces.sort((a, b) => b.length - a.length);
    return demandPieces;
}

/**
 * G√©n√®re des patterns de d√©coupe efficaces pour toutes les barres disponibles
 * @param {Array} stockBars - Barres m√®res disponibles
 * @param {Array} demandPieces - Pi√®ces √† d√©couper
 * @returns {Array} Patterns de d√©coupe
 */
function generatePatternsForBars(stockBars, demandPieces) {
    const allPatterns = [];
    
    // Limiter le nombre de patrons par barre pour √©viter une explosion combinatoire
    const maxPatternsPerBar = 3000;
    const totalMaxPatterns = 10000;
    
    // Pour chaque longueur de barre m√®re
    for (const stockBar of stockBars) {
        const stockLength = stockBar.length;
        const patternsForThisLength = generatePatternsForSingleBar(demandPieces, stockLength, maxPatternsPerBar);
        
        // Ajouter la longueur de la barre m√®re √† chaque pattern
        patternsForThisLength.forEach(pattern => {
            pattern.stockLength = stockLength;
            pattern.stockBarId = stockBar.id || null;
        });
        
        allPatterns.push(...patternsForThisLength);
        
        // Limiter le nombre total de patterns pour √©viter les probl√®mes de m√©moire
        if (allPatterns.length >= totalMaxPatterns) {
            console.warn(`‚ö†Ô∏è Nombre maximum de patterns atteint (${totalMaxPatterns}), certains patterns ignor√©s`);
            break;
        }
    }
    
    return allPatterns;
}

/**
 * G√©n√®re des patterns de d√©coupe efficaces pour une seule barre
 * Am√©lioration: utilise une approche plus efficace avec un cache de patterns
 * @param {Array} pieces - Pi√®ces √† d√©couper
 * @param {Number} stockLength - Longueur de la barre m√®re
 * @param {Number} maxPatterns - Nombre maximum de patterns √† g√©n√©rer
 * @returns {Array} Patterns de d√©coupe
 */
function generatePatternsForSingleBar(pieces, stockLength, maxPatterns = 3000) {
    // √âliminer les pi√®ces trop longues
    const validPieces = pieces.filter(piece => piece.length <= stockLength);
    
    // Si aucune pi√®ce valide, retourner un pattern vide
    if (validPieces.length === 0) {
        return [{
            pieces: [],
            waste: stockLength,
            composition: {}
        }];
    }
    
    // G√©n√©rer les patterns avec l'algorithme de programmation dynamique
    const patterns = generatePatternsDP(validPieces, stockLength, maxPatterns);
    
    // Trier les patterns par efficacit√© (moins de d√©chets et plus de pi√®ces)
    patterns.sort((a, b) => {
        // D'abord trier par d√©chets
        if (a.waste !== b.waste) {
            return a.waste - b.waste;
        }
        // Ensuite par nombre de pi√®ces (pr√©f√©rer plus de pi√®ces)
        return b.pieces.length - a.pieces.length;
    });
    
    return patterns.slice(0, maxPatterns);
}

/**
 * G√©n√®re des patterns de d√©coupe avec programmation dynamique
 * Cette approche est beaucoup plus efficace que la recherche en profondeur
 * @param {Array} pieces - Pi√®ces √† d√©couper
 * @param {Number} stockLength - Longueur de la barre m√®re
 * @param {Number} maxPatterns - Nombre maximum de patterns √† g√©n√©rer
 * @returns {Array} Patterns de d√©coupe
 */
function generatePatternsDP(pieces, stockLength, maxPatterns) {
    // D√©finir un cache pour les sous-probl√®mes
    const patternsCache = new Map();
    const patterns = [];
    const visited = new Set();
    
    // Fonction auxiliaire pour g√©n√©rer un pattern key
    function getPatternKey(composition) {
        return Object.entries(composition)
            .sort(([a], [b]) => parseInt(a) - parseInt(b))
            .map(([len, count]) => `${len}:${count}`)
            .join(',');
    }
    
    // Phase 1: G√©n√©rer tous les patterns possibles avec programmation dynamique
    function generateWithDP(remainingLength, pieceIndex, currentComposition = {}) {
        // Cl√© de cache pour ce sous-probl√®me
        const cacheKey = `${remainingLength}:${pieceIndex}`;
        
        // Si d√©j√† calcul√©, retourner le r√©sultat
        if (patternsCache.has(cacheKey)) {
            return patternsCache.get(cacheKey);
        }
        
        // Si nous avons atteint la fin des pi√®ces ou la longueur restante est trop petite
        if (pieceIndex >= pieces.length || remainingLength < pieces[pieces.length - 1].length) {
            const patternKey = getPatternKey(currentComposition);
            
            // √âviter les doublons
            if (!visited.has(patternKey) && patterns.length < maxPatterns) {
                // Convertir la composition en liste de pi√®ces
                const patternPieces = [];
                for (const [pieceLength, count] of Object.entries(currentComposition)) {
                    for (let i = 0; i < count; i++) {
                        patternPieces.push(parseInt(pieceLength, 10));
                    }
                }
                
                patterns.push({
                    pieces: patternPieces,
                    waste: remainingLength,
                    composition: {...currentComposition}
                });
                
                visited.add(patternKey);
            }
            
            return []; // Retourner un tableau vide pour la r√©cursion
        }
        
        // Donn√©es de la pi√®ce actuelle
        const piece = pieces[pieceIndex];
        const maxCount = Math.min(
            Math.floor(remainingLength / piece.length),
            piece.quantity
        );
        
        const subResults = [];
        
        // Essayer diff√©rentes quantit√©s de la pi√®ce actuelle
        for (let count = maxCount; count >= 0; count--) {
            const newComposition = {...currentComposition};
            if (count > 0) {
                newComposition[piece.length] = (newComposition[piece.length] || 0) + count;
            }
            
            const newRemainingLength = remainingLength - (count * piece.length);
            
            // R√©cursivement r√©soudre pour la pi√®ce suivante
            const nextResults = generateWithDP(
                newRemainingLength,
                pieceIndex + 1,
                newComposition
            );
            
            subResults.push(...nextResults);
            
            // Limiter le nombre de sous-r√©sultats pour √©viter une explosion combinatoire
            if (subResults.length > 100) break;
        }
        
        // Mettre en cache les r√©sultats pour ce sous-probl√®me
        patternsCache.set(cacheKey, subResults);
        
        return subResults;
    }
    
    // Lancer la g√©n√©ration de patterns
    generateWithDP(stockLength, 0);
    
    // Phase 2: Ajouter des patterns heuristiques qui pourraient √™tre manqu√©s
    addHeuristicPatterns(pieces, stockLength, patterns, maxPatterns);
    
    return patterns;
}

/**
 * Ajoute des patterns heuristiques bas√©s sur des r√®gles empiriques
 * @param {Array} pieces - Pi√®ces √† d√©couper
 * @param {Number} stockLength - Longueur de la barre m√®re
 * @param {Array} patterns - Tableau de patterns existants √† compl√©ter
 * @param {Number} maxPatterns - Nombre maximum de patterns
 */
function addHeuristicPatterns(pieces, stockLength, patterns, maxPatterns) {
    // Si on a d√©j√† atteint le maximum de patterns, ne rien faire
    if (patterns.length >= maxPatterns) return;
    
    // Heuristique 1: Essayer de combiner les pi√®ces les plus grandes d'abord
    const sortedPieces = [...pieces].sort((a, b) => b.length - a.length);
    let remainingLength = stockLength;
    const composition = {};
    const patternPieces = [];
    
    for (const piece of sortedPieces) {
        const maxFit = Math.min(
            Math.floor(remainingLength / piece.length),
            piece.quantity
        );
        
        if (maxFit > 0) {
            composition[piece.length] = maxFit;
            for (let i = 0; i < maxFit; i++) {
                patternPieces.push(piece.length);
            }
            remainingLength -= maxFit * piece.length;
        }
    }
    
    if (patternPieces.length > 0) {
        patterns.push({
            pieces: patternPieces,
            waste: remainingLength,
            composition
        });
    }
    
    // Heuristique 2: Essayer de combiner des pi√®ces de taille similaire
    // pour minimiser les petits d√©chets
    addHomogeneousPatterns(pieces, stockLength, patterns);
    
    // Heuristique 3: Patterns pour les pi√®ces les plus demand√©es
    addHighDemandPatterns(pieces, stockLength, patterns);
}

/**
 * Ajoute des patterns avec des pi√®ces de taille similaire
 */
function addHomogeneousPatterns(pieces, stockLength, patterns) {
    for (let i = 0; i < Math.min(pieces.length, 5); i++) {
        const piece = pieces[i];
        const maxFit = Math.min(
            Math.floor(stockLength / piece.length),
            piece.quantity
        );
        
        if (maxFit > 0) {
            const patternPieces = Array(maxFit).fill(piece.length);
            const waste = stockLength - (maxFit * piece.length);
            const composition = { [piece.length]: maxFit };
            
            patterns.push({
                pieces: patternPieces,
                waste,
                composition
            });
        }
    }
}

/**
 * Ajoute des patterns pour les pi√®ces les plus demand√©es
 */
function addHighDemandPatterns(pieces, stockLength, patterns) {
    const highDemandPieces = [...pieces]
        .sort((a, b) => b.quantity - a.quantity)
        .slice(0, 3);
    
    for (const piece of highDemandPieces) {
        const maxFit = Math.min(
            Math.floor(stockLength / piece.length),
            piece.quantity
        );
        
        if (maxFit > 0) {
            const patternPieces = Array(maxFit).fill(piece.length);
            const waste = stockLength - (maxFit * piece.length);
            const composition = { [piece.length]: maxFit };
            
            patterns.push({
                pieces: patternPieces,
                waste,
                composition
            });
        }
    }
}

/**
 * R√©sout le probl√®me de d√©coupe avec la programmation lin√©aire en nombres entiers
 * @param {Array} stockBars - Barres m√®res disponibles
 * @param {Array} demandPieces - Pi√®ces √† d√©couper
 * @param {Array} patterns - Patterns de d√©coupe
 * @returns {Object} R√©sultats de l'optimisation
 */
function solveWithCuttingStockILP(stockBars, demandPieces, patterns) {
    console.log(`Tentative de r√©solution ILP avec ${patterns.length} patterns`);
    
    // G√©n√©rer des patterns s√©curis√©s qui √©vitent la surproduction
    const { patterns: safePatterns, maxUsage } = generateSafePatterns(stockBars, demandPieces, patterns);
    
    if (safePatterns.length === 0) {
        console.warn("‚ö†Ô∏è Aucun pattern s√©curis√© n'a pu √™tre g√©n√©r√©, utilisation de l'algorithme de secours");
        return solveWithColumnGeneration(patterns, stockBars, demandPieces);
    }
    
    // R√©duire le nombre de patterns si n√©cessaire pour garantir la stabilit√©
    const maxPatternsToUse = Math.min(800, safePatterns.length);
    
    // S√©lectionner les patterns les plus efficaces
    const sortedPatterns = [...safePatterns]
        .sort((a, b) => a.waste - b.waste)
        .slice(0, maxPatternsToUse);
    
    console.log(`Utilisation des ${sortedPatterns.length} meilleurs patterns s√©curis√©s`);
    
    // Cr√©er un mod√®le ILP correctement structur√©
    const model = createILPModel(sortedPatterns, stockBars, demandPieces, maxUsage);
    
    // Essayer de r√©soudre avec le solveur ILP
    try {
        const options = {
            timeout: 10000,  // Augmenter le timeout √† 10 secondes
            strategy: 0,     // Strat√©gie de base pour la stabilit√©
            msg: true        // Activer les messages de debug
        };
        
        console.log("Lancement du solveur ILP...");
        const solution = solver.Solve(model, options);
        console.log("Solution ILP obtenue:", solution.feasible, "valeur:", solution.result);
        
        // V√©rifier si la solution est valide et utilisable
        if (solution.feasible && !isNaN(solution.result) && solution.result > 0) {
            // V√©rifier que des patterns ont √©t√© utilis√©s
            let patternsUsed = false;
            for (const key in solution) {
                if (key.startsWith('pattern_') && !isNaN(solution[key]) && solution[key] > 0) {
                    patternsUsed = true;
                    break;
                }
            }
            
            if (patternsUsed) {
                console.log("Solution ILP valide, utilisation de cette solution");
                return {
                    method: "ILP",
                    solution: solution,
                    patterns: sortedPatterns
                };
            } else {
                console.warn("‚ö†Ô∏è Solution ILP sans patterns utilis√©s, utilisation du fallback");
            }
        } else {
            console.warn("‚ö†Ô∏è Solution ILP non valide, utilisation du fallback");
        }
    } catch (error) {
        console.error("Erreur lors de la r√©solution ILP:", error);
    }
    
    console.log("Utilisation de l'algorithme de secours...");
    return solveWithColumnGeneration(sortedPatterns, stockBars, demandPieces);
}

/**
 * Cr√©e un mod√®le ILP correctement structur√© pour le solveur
 * @param {Array} patterns - Patterns de d√©coupe
 * @param {Array} stockBars - Barres m√®res disponibles
 * @param {Array} demandPieces - Pi√®ces √† d√©couper
 * @param {Map} patternMaxUsage - Limites d'utilisation pour chaque pattern
 * @returns {Object} Mod√®le ILP
 */
function createILPModel(patterns, stockBars, demandPieces, patternMaxUsage = null) {
    // Mod√®le pour minimiser le nombre de barres utilis√©es
    const model = {
        optimize: 'bars',
        opType: 'min',
        constraints: {},
        variables: {},
        ints: {}
    };
    
    // 1. CONTRAINTES DE DEMANDE: garantir que toutes les pi√®ces sont d√©coup√©es exactement selon la demande
    for (const piece of demandPieces) {
        model.constraints[`demand_${piece.length}`] = { equal: piece.quantity };
    }
    
    // 2. CONTRAINTES DE STOCK: garantir qu'on ne d√©passe pas le stock disponible
    // Cr√©ation d'une contrainte par longueur de barre stock
    const stockLengths = new Map();
    for (const bar of stockBars) {
        if (stockLengths.has(bar.length)) {
            stockLengths.set(bar.length, stockLengths.get(bar.length) + bar.quantity);
        } else {
            stockLengths.set(bar.length, bar.quantity);
        }
    }
    
    // Ajouter les contraintes de stock
    for (const [length, quantity] of stockLengths.entries()) {
        model.constraints[`stock_${length}`] = { max: quantity };
    }
    
    // 3. D√âFINIR LES VARIABLES (chaque variable = nombre de fois qu'un pattern est utilis√©)
    for (let i = 0; i < patterns.length; i++) {
        const pattern = patterns[i];
        const varName = `pattern_${i}`;
        
        // Chaque pattern contribue 1 √† l'objectif (une barre utilis√©e)
        model.variables[varName] = { bars: 1 };
        
        // Chaque variable doit √™tre un entier
        model.ints[varName] = 1;
        
        // Si une limite d'utilisation est sp√©cifi√©e pour ce pattern, l'ajouter comme contrainte
        if (patternMaxUsage && pattern.maxUsage) {
            model.constraints[`max_usage_${i}`] = { max: pattern.maxUsage };
            model.variables[varName][`max_usage_${i}`] = 1;
        }
        
        // Compter les occurrences de chaque type de pi√®ce dans ce pattern
        const pieceCounts = {};
        for (const pieceLength of pattern.pieces) {
            pieceCounts[pieceLength] = (pieceCounts[pieceLength] || 0) + 1;
        }
        
        // Ajouter la contribution aux contraintes de demande
        for (const [pieceLength, count] of Object.entries(pieceCounts)) {
            model.variables[varName][`demand_${pieceLength}`] = count;
        }
        
        // Ajouter la contribution aux contraintes de stock
        if (stockLengths.has(pattern.stockLength)) {
            model.variables[varName][`stock_${pattern.stockLength}`] = 1;
        }
    }
    
    console.log("Mod√®le ILP cr√©√©:");
    console.log("- Contraintes:", Object.keys(model.constraints).length);
    console.log("- Variables:", Object.keys(model.variables).length);
    
    return model;
}

/**
 * G√©n√®re des patterns sur mesure qui √©vitent strictement la surproduction
 * @param {Array} stockBars - Barres m√®res disponibles
 * @param {Array} demandPieces - Pi√®ces √† d√©couper
 * @returns {Array} Patterns adapt√©s sans surproduction
 */
function generateSafePatterns(stockBars, demandPieces) {
    console.log("G√©n√©ration de patterns sans risque de surproduction...");
    
    // Cr√©er une copie des patterns standards
    const basicPatterns = generatePatternsForBars(stockBars, demandPieces);
    
    // √âliminer tout pattern qui pourrait causer une surproduction
    const safePatterns = [];
    
    // Cr√©er un tableau pour suivre le nombre maximal de fois qu'un pattern peut √™tre utilis√©
    const patternMaxUsage = new Map();
    
    // Pour chaque pattern, calculer combien de fois il peut √™tre utilis√© sans surproduction
    for (const pattern of basicPatterns) {
        const pieceCounts = {};
        for (const pieceLength of pattern.pieces) {
            pieceCounts[pieceLength] = (pieceCounts[pieceLength] || 0) + 1;
        }
        
        // V√©rifier que ce pattern pourrait √™tre utilis√© au moins une fois
        let minUsageCount = Infinity;
        let hasPieces = false;
        
        for (const [pieceLength, count] of Object.entries(pieceCounts)) {
            hasPieces = true;
            const lengthInt = parseInt(pieceLength, 10);
            
            // Trouver la pi√®ce correspondante dans la demande
            const demandPiece = demandPieces.find(p => p.length === lengthInt);
            
            if (demandPiece) {
                // Calculer combien de fois ce pattern peut √™tre utilis√©
                const maxUsage = Math.floor(demandPiece.quantity / count);
                minUsageCount = Math.min(minUsageCount, maxUsage);
            } else {
                // Ce pattern utilise une pi√®ce qui n'est pas demand√©e
                minUsageCount = 0;
                break;
            }
        }
        
        // Si ce pattern peut √™tre utilis√©, l'ajouter √† la liste
        if (minUsageCount > 0 && hasPieces) {
            safePatterns.push(pattern);
            patternMaxUsage.set(pattern, minUsageCount);
        }
    }
    
    console.log(`${safePatterns.length} patterns s√ªrs g√©n√©r√©s (sur ${basicPatterns.length} patterns initiaux)`);
    
    return {
        patterns: safePatterns,
        maxUsage: patternMaxUsage
    };
}
function solveWithColumnGeneration(patterns, stockBars, demandPieces) {
    console.log("Ex√©cution de la g√©n√©ration de colonnes...");
    
    // Solution finale √† construire
    const solution = { feasible: true, result: 0 };
    const selectedPatterns = new Map();
    
    // Cr√©er une copie des demandes qu'on va satisfaire progressivement
    const remainingDemand = new Map();
    console.log("\nüìã R√âSUM√â DES PI√àCES √Ä D√âCOUPER:");
    console.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    for (const piece of demandPieces) {
        remainingDemand.set(piece.length, piece.quantity);
        console.log(`  ‚Ä¢ Pi√®ce de longueur ${piece.length}: ${piece.quantity} unit√©s demand√©es`);
    }
    console.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n");
    
    // Garder trace des barres disponibles
    const availableStock = new Map();
    for (const bar of stockBars) {
        if (availableStock.has(bar.length)) {
            availableStock.set(bar.length, availableStock.get(bar.length) + bar.quantity);
        } else {
            availableStock.set(bar.length, bar.quantity);
        }
    }
    
    // Garder trace du nombre maximum de fois que chaque pattern peut √™tre utilis√©
    const patternUsageLimits = new Map();
    const patternCurrentUsage = new Map();
    
    // Initialiser les limites d'utilisation des patterns en fonction des demandes
    for (let i = 0; i < patterns.length; i++) {
        const pattern = patterns[i];
        
        // Compter les pi√®ces par longueur dans ce pattern
        const pieceCounts = {};
        for (const pieceLength of pattern.pieces) {
            pieceCounts[pieceLength] = (pieceCounts[pieceLength] || 0) + 1;
        }
        
        // Calculer le nombre maximum de fois que ce pattern peut √™tre utilis√©
        let maxUsage = Infinity;
        for (const [pieceLength, count] of Object.entries(pieceCounts)) {
            const lengthInt = parseInt(pieceLength, 10);
            const demand = remainingDemand.get(lengthInt) || 0;
            if (count > 0) {
                maxUsage = Math.min(maxUsage, Math.floor(demand / count));
            }
        }
        
        // Stocker cette limite
        patternUsageLimits.set(i, maxUsage);
        patternCurrentUsage.set(i, 0);
    }
    
    // Algorithme de column generation simplifi√©
    let iteration = 0;
    const maxIterations = 100;
    
    console.log("\nüîÑ D√âMARRAGE DES IT√âRATIONS");
    console.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    
    // Tant qu'il reste des pi√®ces √† d√©couper et qu'on n'a pas atteint le max d'it√©rations
    while (Array.from(remainingDemand.values()).some(qty => qty > 0) && iteration < maxIterations) {
        iteration++;
        
        console.log(`\nüìå IT√âRATION ${iteration} :`);
        
        // √âtat actuel de la demande
        let demandStatusLog = [];
        for (const [length, qty] of remainingDemand.entries()) {
            if (qty > 0) {
                demandStatusLog.push(`${qty}x${length}`);
            }
        }
        
        if (demandStatusLog.length === 0) {
            console.log("‚úÖ Toutes les pi√®ces ont √©t√© satisfaites!");
            break;
        }
        
        console.log(`  ‚Ä¢ Demande restante: ${demandStatusLog.join(', ')}`);
        
        // 1. PHASE DE PRICING: Trouver le meilleur pattern pour la demande restante
        let bestPattern = null;
        let bestScore = -Infinity;
        let bestPatternIndex = -1;
        
        for (let i = 0; i < patterns.length; i++) {
            const pattern = patterns[i];
            
            // V√©rifier si ce pattern a atteint sa limite d'utilisation
            const currentUsage = patternCurrentUsage.get(i) || 0;
            const maxUsage = patternUsageLimits.get(i) || 0;
            
            if (currentUsage >= maxUsage) {
                // Pattern d√©j√† utilis√© au maximum, ignorer
                continue;
            }
            
            // Calculer la valeur de ce pattern pour la demande restante
            let score = 0;
            let useful = false;
            
            // Compter les pi√®ces de chaque type dans ce pattern
            const pieceCounts = {};
            for (const pieceLength of pattern.pieces) {
                pieceCounts[pieceLength] = (pieceCounts[pieceLength] || 0) + 1;
            }
            
            // √âvaluer ce pattern
            for (const [pieceLength, count] of Object.entries(pieceCounts)) {
                const lengthInt = parseInt(pieceLength, 10);
                const demandLeft = remainingDemand.get(lengthInt) || 0;
                if (demandLeft > 0) {
                    useful = true;
                    // R√©compense pour chaque pi√®ce satisfaite (proportionnelle √† sa taille)
                    // Ne compter que les pi√®ces qui sont r√©ellement n√©cessaires (pas plus que la demande)
                    const usableCount = Math.min(count, demandLeft);
                    score += usableCount * lengthInt;
                }
            }
            
            // Si le pattern contient des pi√®ces qui ne sont plus n√©cessaires,
            // il devrait √™tre fortement p√©nalis√© ou ignor√© compl√®tement
            let isPatternViable = true; // Commencer par supposer que le pattern est viable
            
            // P√©naliser le gaspillage et les pi√®ces superflues
            let overproduction = 0;
            let totalOverproduction = 0;
            let hasCriticalOverproduction = false;
            
            for (const [pieceLength, count] of Object.entries(pieceCounts)) {
                const lengthInt = parseInt(pieceLength, 10);
                const demandLeft = remainingDemand.get(lengthInt) || 0;
                
                if (count > demandLeft) {
                    // Comptabiliser la surproduction
                    const excessCount = count - demandLeft;
                    overproduction += 1; // P√©nalit√© par type de pi√®ce en surproduction
                    totalOverproduction += excessCount; // Nombre total de pi√®ces en surproduction
                    
                    // Si la demande est √† z√©ro mais qu'on produirait quand m√™me, p√©nalit√© encore plus forte
                    if (demandLeft === 0) {
                        hasCriticalOverproduction = true;
                        // Marquer ce pattern comme non viable s'il produirait des pi√®ces 
                        // dont on n'a plus besoin du tout
                        isPatternViable = false;
                    }
                }
            }
            
            // Ne consid√©rer les patterns non viables que s'ils sont vraiment n√©cessaires
            if (!isPatternViable) {
                // P√©naliser tr√®s fortement, sauf s'il n'y a pas d'autre choix
                score = -1000;
            } else {
                // P√©nalit√©s progressives pour dissuader la surproduction
                const wastePenalty = pattern.waste * 2;
                const overproductionPenalty = overproduction * 15;
                const totalOverproductionPenalty = totalOverproduction * 10;
                const criticalPenalty = hasCriticalOverproduction ? 200 : 0;
                
                score -= (wastePenalty + overproductionPenalty + totalOverproductionPenalty + criticalPenalty);
            }
            
            // Actualiser si c'est le meilleur pattern jusqu'√† pr√©sent
            if (useful && score > bestScore) {
                bestScore = score;
                bestPattern = pattern;
                bestPatternIndex = i;
            }
        }
        
        // Si aucun pattern utile n'a √©t√© trouv√©, g√©n√©rer un nouveau pattern sp√©cifique
        if (bestPattern === null) {
            // Essayer de g√©n√©rer un pattern sur mesure pour la demande restante
            bestPattern = generateCustomPattern(remainingDemand, stockBars);
            bestPatternIndex = patterns.length; // Un nouvel index virtuel
            
            if (bestPattern) {
                patterns.push(bestPattern);
                console.log(`Nouveau pattern g√©n√©r√© √† l'it√©ration ${iteration}`);
            } else {
                console.warn(`‚ö†Ô∏è Impossible de satisfaire toute la demande √† l'it√©ration ${iteration}`);
                break;
            }
        }
        
        // 2. PHASE DE MASTER PROBLEM: Appliquer ce pattern
        if (bestPattern) {
            // V√©rifier si nous avons suffisamment de barres m√®res de cette longueur
            const stockLength = bestPattern.stockLength;
            const availableCount = availableStock.get(stockLength) || 0;
            
            if (availableCount <= 0) {
                // Plus de barres m√®res de cette longueur disponibles, essayer un autre pattern
                console.log(`‚ö†Ô∏è Plus de barres m√®res de longueur ${stockLength} disponibles`);
                patterns.splice(bestPatternIndex, 1); // Retirer ce pattern de la liste
                continue;
            }
            
            // Adapter le pattern pour √©viter la surproduction
            const modifiedPattern = adaptPatternToPreventOverproduction(bestPattern, remainingDemand, iteration);
            
            // Ne pas utiliser le pattern s'il n'a plus de pi√®ces utiles apr√®s adaptation
            if (!modifiedPattern.hasUsablePieces) {
                console.log(`  ‚Ä¢ Pattern ignor√© car aucune pi√®ce n'est n√©cessaire apr√®s adaptation`);
                continue;
            }
            
            // D√©cr√©menter le stock disponible
            availableStock.set(stockLength, availableCount - 1);
            
            // Cr√©er un nouvel index pour ce pattern modifi√©
            const modifiedPatternIndex = `modified_${bestPatternIndex}_${iteration}`;
            
            // Incr√©menter le compteur de ce pattern modifi√©
            const varName = `pattern_${modifiedPatternIndex}`;
            solution[varName] = (solution[varName] || 0) + 1;
            
            // Mettre √† jour l'utilisation de ce pattern
            patternCurrentUsage.set(bestPatternIndex, (patternCurrentUsage.get(bestPatternIndex) || 0) + 1);
            
            // Utiliser le pattern modifi√© au lieu du pattern d'origine
            bestPattern = modifiedPattern;
            
            // Garder trace des patterns modifi√©s
            // Important: Stocker le modifiedPattern avec le nouvel index pour le retrouver lors du traitement final
            patterns[modifiedPatternIndex] = modifiedPattern;
            
            // Garder trace des patterns s√©lectionn√©s
            if (selectedPatterns.has(modifiedPatternIndex)) {
                selectedPatterns.set(modifiedPatternIndex, selectedPatterns.get(modifiedPatternIndex) + 1);
            } else {
                selectedPatterns.set(modifiedPatternIndex, 1);
            }
            
            // Incr√©menter le nombre total de barres utilis√©es
            solution.result++;
        }
    }
    
    // V√©rifier s'il reste des pi√®ces non satisfaites
    const remainingPieces = Array.from(remainingDemand.entries())
        .filter(([_, qty]) => qty > 0)
        .map(([len, qty]) => ({ length: len, quantity: qty }));
    
    if (remainingPieces.length > 0) {
        console.warn(`‚ö†Ô∏è ${remainingPieces.length} types de pi√®ces non satisfaites apr√®s column generation`);
        
        // Derni√®re chance: utiliser un algorithme glouton direct pour les pi√®ces restantes
        const additionalSolution = solveRemainingPiecesGreedy(remainingPieces, stockBars);
        
        // Fusionner les solutions
        for (const [key, value] of Object.entries(additionalSolution)) {
            if (key === 'result') {
                solution.result += value;
            } else if (key.startsWith('pattern_')) {
                solution[key] = (solution[key] || 0) + value;
            }
        }
    }
    
    console.log(`Column Generation termin√©e: ${solution.result} barres utilis√©es`);
    return {
        method: "ColumnGeneration",
        solution: solution,
        patterns: patterns
    };
}

/**
 * G√©n√®re un pattern sur mesure pour satisfaire une demande sp√©cifique
 * Utile quand les patterns existants ne sont pas adapt√©s
 * @param {Map} demandMap - Mapping des demandes restantes
 * @param {Array} stockBars - Barres m√®res disponibles
 * @returns {Object} Pattern g√©n√©r√©, ou null si impossible
 */
function generateCustomPattern(demandMap, stockBars) {
    // Trouver la barre m√®re la plus appropri√©e
    let bestBar = stockBars[0]; // Par d√©faut, prendre la premi√®re
    
    // D√©terminer les pi√®ces encore n√©cessaires, tri√©es par taille d√©croissante
    const remainingPieces = [];
    for (const [length, quantity] of demandMap.entries()) {
        if (quantity > 0) {
            remainingPieces.push({
                length: parseInt(length, 10),
                quantity: quantity
            });
        }
    }
    
    // Si aucune pi√®ce restante, retourner null
    if (remainingPieces.length === 0) return null;
    
    // Trier par ordre d√©croissant de longueur
    remainingPieces.sort((a, b) => b.length - a.length);
    
    // Essayer de g√©n√©rer un pattern pour chaque barre disponible
    let bestPattern = null;
    let bestScore = -Infinity;
    
    for (const bar of stockBars) {
        const stockLength = bar.length;
        
        // Algorithme du sac √† dos pour maximiser l'utilisation de la barre
        const pattern = knapsackForPattern(remainingPieces, stockLength);
        
        // √âvaluer ce pattern
        if (pattern && pattern.pieces.length > 0) {
            // Score = rapport entre la somme des longueurs et la longueur de la barre
            const utilizationRatio = (stockLength - pattern.waste) / stockLength;
            
            // Pr√©f√©rer les patterns qui utilisent bien la barre
            if (utilizationRatio > 0.5 && utilizationRatio > bestScore) {
                bestScore = utilizationRatio;
                bestPattern = pattern;
                bestPattern.stockLength = stockLength;
            }
        }
    }
    
    return bestPattern;
}

/**
 * R√©sout un probl√®me de sac √† dos pour g√©n√©rer un pattern optimis√©
 * @param {Array} pieces - Pi√®ces disponibles
 * @param {Number} capacity - Capacit√© (longueur de la barre)
 * @returns {Object} Pattern g√©n√©r√©
 */
function knapsackForPattern(pieces, capacity) {
    // Algorithme du sac √† dos modifi√© pour le probl√®me de cutting stock
    const n = pieces.length;
    const dp = Array(capacity + 1).fill(0);
    const selected = Array(capacity + 1).fill().map(() => []);
    
    // Phase 1: R√©soudre le probl√®me du sac √† dos
    for (let i = 0; i < n; i++) {
        const piece = pieces[i];
        
        for (let j = capacity; j >= piece.length; j--) {
            // Limiter le nombre de copies de chaque pi√®ce √† sa quantit√©
            for (let k = 1; k <= piece.quantity; k++) {
                if (j >= k * piece.length) {
                    const newValue = dp[j - k * piece.length] + k * piece.length;
                    
                    if (newValue > dp[j]) {
                        dp[j] = newValue;
                        selected[j] = [...selected[j - k * piece.length]];
                        
                        // Ajouter k copies de cette pi√®ce
                        for (let l = 0; l < k; l++) {
                            selected[j].push(piece.length);
                        }
                    }
                }
            }
        }
    }
    
    // Phase 2: Reconstruire la solution
    const patternPieces = selected[capacity];
    const waste = capacity - dp[capacity];
    
    // Compter les occurrences de chaque pi√®ce
    const composition = {};
    for (const pieceLength of patternPieces) {
        composition[pieceLength] = (composition[pieceLength] || 0) + 1;
    }
    
    return {
        pieces: patternPieces,
        waste: waste,
        composition: composition
    };
}

/**
 * R√©sout le probl√®me pour les pi√®ces restantes avec un algorithme glouton
 * @param {Array} remainingPieces - Pi√®ces restantes
 * @param {Array} stockBars - Barres m√®res disponibles
 * @returns {Object} Solution pour les pi√®ces restantes
 */
function solveRemainingPiecesGreedy(remainingPieces, stockBars) {
    console.log("R√©solution des pi√®ces restantes avec algorithme glouton");
    
    // Cr√©er une copie du stock disponible
    const availableBarsByLength = new Map();
    for (const bar of stockBars) {
        if (availableBarsByLength.has(bar.length)) {
            availableBarsByLength.set(bar.length, availableBarsByLength.get(bar.length) + bar.quantity);
        } else {
            availableBarsByLength.set(bar.length, bar.quantity);
        }
    }
    
    // V√©rifier si nous avons encore des barres disponibles
    const totalAvailableBars = Array.from(availableBarsByLength.values()).reduce((acc, val) => acc + val, 0);
    if (totalAvailableBars === 0) {
        console.warn("‚ö†Ô∏è Plus aucune barre m√®re disponible pour les pi√®ces restantes");
        return { feasible: false, result: 0 };
    }
    
    // Trier les barres m√®res par longueur d√©croissante
    const sortedBars = Array.from(availableBarsByLength.entries())
        .sort((a, b) => b[0] - a[0]);
    
    // Obtenir la barre m√®re la plus adapt√©e pour chaque pi√®ce
    const stockLength = sortedBars[0][0]; // Par d√©faut, prendre la plus grande
    
    // Pr√©parer toutes les pi√®ces restantes dans un tableau plat
    const allPieces = [];
    for (const piece of remainingPieces) {
        for (let i = 0; i < piece.quantity; i++) {
            allPieces.push(piece.length);
        }
    }
    
    // Trier les pi√®ces par ordre d√©croissant
    allPieces.sort((a, b) => b - a);
    
    // First-Fit Decreasing
    const bars = [];
    const solution = { feasible: true, result: 0 };
    
    for (const pieceLength of allPieces) {
        let placed = false;
        
        // Essayer de placer dans une barre existante
        for (let i = 0; i < bars.length; i++) {
            if (bars[i].remainingSpace >= pieceLength) {
                bars[i].pieces.push(pieceLength);
                bars[i].remainingSpace -= pieceLength;
                placed = true;
                break;
            }
        }
        
        // Si non plac√©e, cr√©er une nouvelle barre
        if (!placed) {
            // Trouver la barre la plus petite qui peut contenir cette pi√®ce
            let bestFitBarLength = null;
            
            for (const [barLength, quantity] of availableBarsByLength.entries()) {
                if (quantity > 0 && barLength >= pieceLength && 
                    (bestFitBarLength === null || barLength < bestFitBarLength)) {
                    bestFitBarLength = barLength;
                }
            }
            
            // V√©rifier si nous avons trouv√© une barre disponible
            if (bestFitBarLength === null) {
                console.warn(`‚ö†Ô∏è Plus de barres disponibles pour la pi√®ce de longueur ${pieceLength}`);
                continue; // Passer √† la pi√®ce suivante
            }
            
            // R√©duire la quantit√© disponible
            availableBarsByLength.set(bestFitBarLength, availableBarsByLength.get(bestFitBarLength) - 1);
            
            // Cr√©er une nouvelle barre
            bars.push({
                pieces: [pieceLength],
                remainingSpace: bestFitBarLength - pieceLength,
                stockLength: bestFitBarLength
            });
            solution.result++;
        }
    }
    
    // Convertir en format pattern_X
    for (let i = 0; i < bars.length; i++) {
        const patternKey = `pattern_extra_${i}`;
        solution[patternKey] = 1;
    }
    
    return solution;
}

/**
 * Algorithme glouton simple (fallback de secours)
 * @param {Array} stockBars - Barres m√®res disponibles
 * @param {Array} demandPieces - Pi√®ces √† d√©couper
 * @returns {Object} R√©sultats de l'algorithme glouton
 */
function solveWithSimpleGreedy(stockBars, demandPieces) {
    console.log("Utilisation de l'algorithme glouton simple");
    
    // Cr√©er une carte des barres disponibles par longueur
    const availableBarsByLength = new Map();
    for (const bar of stockBars) {
        if (availableBarsByLength.has(bar.length)) {
            availableBarsByLength.set(bar.length, availableBarsByLength.get(bar.length) + bar.quantity);
        } else {
            availableBarsByLength.set(bar.length, bar.quantity);
        }
    }
    
    // V√©rifier si nous avons des barres disponibles
    const totalAvailableBars = Array.from(availableBarsByLength.values()).reduce((acc, val) => acc + val, 0);
    if (totalAvailableBars === 0) {
        console.warn("‚ö†Ô∏è Aucune barre m√®re disponible");
        return {
            rawData: {
                usedBars: [],
                wasteLength: 0,
                totalMotherBarsUsed: 0,
                remainingPieces: demandPieces,
                motherBarLength: 0
            },
            layouts: []
        };
    }
    
    // Extraire les longueurs des barres m√®res disponibles
    const availableLengths = Array.from(availableBarsByLength.keys()).sort((a, b) => b - a);
    const motherBarLength = availableLengths[0]; // La plus grande
    
    // Cr√©er un tableau plat de toutes les pi√®ces
    const allPieces = [];
    for (const piece of demandPieces) {
        for (let i = 0; i < piece.quantity; i++) {
            allPieces.push(piece.length);
        }
    }
    
    // Trier les pi√®ces par ordre d√©croissant
    allPieces.sort((a, b) => b - a);
    
    // First-Fit Decreasing
    const usedBars = [];
    let currentBarIndex = -1;
    
    for (const pieceLength of allPieces) {
        let placed = false;
        
        // Essayer de placer dans une barre existante
        for (let i = 0; i <= currentBarIndex; i++) {
            if (usedBars[i].remainingSpace >= pieceLength) {
                usedBars[i].pieces.push(pieceLength);
                usedBars[i].cuts.push(pieceLength); // Mise √† jour pour compatibilit√©
                usedBars[i].remainingSpace -= pieceLength;
                usedBars[i].remainingLength -= pieceLength; // Mise √† jour pour compatibilit√©
                placed = true;
                break;
            }
        }
        
        // Si non plac√©e, cr√©er une nouvelle barre
        if (!placed) {
            // Trouver la barre la plus petite qui peut contenir cette pi√®ce
            let bestFitBarLength = null;
            
            for (const barLength of availableLengths) {
                if (availableBarsByLength.get(barLength) > 0 && barLength >= pieceLength &&
                   (bestFitBarLength === null || barLength < bestFitBarLength)) {
                    bestFitBarLength = barLength;
                }
            }
            
            // Si aucune barre disponible, consid√©rer cette pi√®ce comme non satisfaite
            if (bestFitBarLength === null) {
                console.warn(`‚ö†Ô∏è Plus de barres disponibles pour la pi√®ce de longueur ${pieceLength}`);
                continue; // Passer √† la pi√®ce suivante sans la placer
            }
            
            // R√©duire le stock de barres disponibles
            availableBarsByLength.set(bestFitBarLength, availableBarsByLength.get(bestFitBarLength) - 1);
            
            // Cr√©er la nouvelle barre
            currentBarIndex++;
            usedBars[currentBarIndex] = {
                id: currentBarIndex + 1,
                pieces: [pieceLength],
                remainingSpace: bestFitBarLength - pieceLength,
                originalLength: bestFitBarLength,
                // Ajout pour compatibilit√©
                cuts: [pieceLength],
                remainingLength: bestFitBarLength - pieceLength
            };
        }
    }
    
    // Calculer le total des d√©chets
    let wasteLength = 0;
    for (const bar of usedBars) {
        wasteLength += bar.remainingSpace;
    }
    
    // Regrouper les barres par layout identique
    const layoutPatterns = {};
    
    for (const bar of usedBars) {
        // Cr√©er une cl√© unique pour ce layout (arrangement de pi√®ces)
        const layoutKey = bar.pieces.slice().sort((a, b) => b - a).join(',');            if (!layoutPatterns[layoutKey]) {
                layoutPatterns[layoutKey] = {
                    count: 1,
                    pieces: bar.pieces.slice().sort((a, b) => b - a),
                    waste: bar.remainingSpace,
                    totalLength: bar.originalLength - bar.remainingSpace,
                    // Ajout des propri√©t√©s pour la compatibilit√©
                    cuts: bar.pieces.slice().sort((a, b) => b - a),
                    remainingLength: bar.remainingSpace,
                    originalLength: bar.originalLength
                };
            } else {
                layoutPatterns[layoutKey].count++;
        }
    }
    
    // Convertir en tableau et trier
    const layoutsArray = Object.values(layoutPatterns);
    layoutsArray.sort((a, b) => b.count - a.count);
    
    return {
        rawData: {
            usedBars,
            wasteLength,
            totalMotherBarsUsed: usedBars.length,
            remainingPieces: [], // Toutes les pi√®ces sont d√©coup√©es
            motherBarLength
        },
        layouts: layoutsArray
    };
}

/**
 * Traite les r√©sultats bruts de l'optimisation pour g√©n√©rer un r√©sultat structur√©
 * @param {Object} optimizationResult - R√©sultats bruts
 * @param {Array} stockBars - Barres m√®res disponibles
 * @param {Array} demandPieces - Pi√®ces √† d√©couper
 * @returns {Object} R√©sultats structur√©s
 */
function processOptimizationResult(optimizationResult, stockBars, demandPieces) {
    const { method, solution, patterns } = optimizationResult;
    
    // Si pas de patterns, retourner une solution vide
    if (!patterns || patterns.length === 0) {
        return {
            rawData: {
                usedBars: [],
                wasteLength: 0,
                totalMotherBarsUsed: 0,
                remainingPieces: demandPieces,
                motherBarLength: stockBars.length > 0 ? stockBars[0].length : 0
            },
            layouts: []
        };
    }
    
    console.log(`Traitement des r√©sultats (m√©thode: ${method})`);
    
    // Structures pour la solution
    const usedBars = [];
    const placedPieces = new Map();
    let wasteLength = 0;
    let barId = 1;
    
    // Initialiser le compteur de pi√®ces plac√©es
    for (const piece of demandPieces) {
        placedPieces.set(piece.length, 0);
    }
    
    // Traiter les patterns utilis√©s dans la solution
    for (const [varName, countValue] of Object.entries(solution)) {
        // N'utiliser que les variables de type pattern_X avec une valeur positive
        if (varName.startsWith('pattern_') && !isNaN(countValue) && countValue > 0) {
            let patternIndex;
            
            // Extraire l'index du pattern
            if (varName.startsWith('pattern_extra_')) {
                // Patterns ajout√©s par l'algorithme glouton
                continue; // On ne peut pas les tracer, ils seront g√©r√©s s√©par√©ment
            } else if (varName.startsWith('pattern_modified_')) {
                // Pattern modifi√© - extraire l'ID complet
                patternIndex = varName.replace('pattern_', '');
            } else {
                patternIndex = parseInt(varName.replace('pattern_', ''), 10);
            }
            
            // R√©cup√©rer le pattern
            const pattern = patterns[patternIndex];
            if (!pattern) {
                console.warn(`‚ö†Ô∏è Pattern ${patternIndex} non trouv√© dans la collection de patterns`);
                continue;
            }
            
            // Debug pour les patterns modifi√©s
            if (pattern.isModifiedPattern && pattern.originInfo) {
                console.log(`Application du pattern modifi√© ${patternIndex}:`);
                console.log(`  ‚Ä¢ Pi√®ces d'origine: ${pattern.originInfo.originalPieces.join(', ')}`);
                console.log(`  ‚Ä¢ Pi√®ces conserv√©es: ${pattern.pieces.join(', ')}`);
                if (pattern.originInfo.removedPieces && pattern.originInfo.removedPieces.length > 0) {
                    console.log(`  ‚Ä¢ Pi√®ces supprim√©es: ${pattern.originInfo.removedPieces.join(', ')}`);
                }
            }
            
            // Utiliser ce pattern le nombre de fois indiqu√©
            for (let i = 0; i < countValue; i++) {
                // Cr√©er une nouvelle barre utilis√©e
                const bar = {
                    id: barId++,
                    pieces: [...pattern.pieces],
                    waste: pattern.waste || 0,
                    originalLength: pattern.stockLength || stockBars[0].length,
                    // Ajouter des propri√©t√©s pour la compatibilit√© avec l'affichage
                    cuts: [...pattern.pieces],
                    remainingLength: pattern.waste || 0
                };
                
                usedBars.push(bar);
                wasteLength += pattern.waste || 0;
                
                // Mettre √† jour le compteur de pi√®ces plac√©es
                for (const pieceLength of pattern.pieces) {
                    placedPieces.set(pieceLength, (placedPieces.get(pieceLength) || 0) + 1);
                }
            }
        }
    }
    
    // Calculer les pi√®ces restantes
    const remainingPieces = [];
    for (const piece of demandPieces) {
        const placed = placedPieces.get(piece.length) || 0;
        const remaining = piece.quantity - placed;
        
        if (remaining > 0) {
            remainingPieces.push({
                length: piece.length,
                quantity: remaining
            });
        }
    }
    
    // S'il reste des pi√®ces et que nous sommes dans un cas avec algorithme glouton
    if (remainingPieces.length > 0 && (method === "ColumnGeneration" || solution.greedy)) {
        console.warn(`‚ö†Ô∏è Il reste ${remainingPieces.length} types de pi√®ces non d√©coup√©es`);
        
        // Essayer de d√©couper les pi√®ces restantes avec l'algorithme glouton
        const remainingResult = solveWithSimpleGreedy(stockBars, remainingPieces);
        
        // Fusionner les r√©sultats
        usedBars.push(...remainingResult.rawData.usedBars);
        wasteLength += remainingResult.rawData.wasteLength;
        
        // Les pi√®ces restantes sont maintenant toutes d√©coup√©es
        remainingPieces.length = 0;
    }
    
    // Regrouper les barres par layout identique
    const layoutPatterns = {};
    
    for (const bar of usedBars) {
        // Cr√©er une cl√© unique pour ce layout
        const layoutKey = bar.pieces.slice().sort((a, b) => b - a).join(',');
        
        if (!layoutPatterns[layoutKey]) {
            // Cr√©er une structure compatible avec les autres algorithmes
            layoutPatterns[layoutKey] = {
                count: 1,
                pieces: bar.pieces.slice().sort((a, b) => b - a),
                waste: bar.waste || bar.remainingLength || 0,
                totalLength: bar.originalLength - (bar.waste || bar.remainingLength || 0),
                // Pour compatibilit√© avec la fonction d'affichage
                cuts: bar.pieces.slice().sort((a, b) => b - a),
                remainingLength: bar.waste || bar.remainingLength || 0,
                originalLength: bar.originalLength
            };
        } else {
            layoutPatterns[layoutKey].count++;
        }
    }
    
    // Convertir en tableau et trier
    const layoutsArray = Object.values(layoutPatterns);
    layoutsArray.sort((a, b) => b.count - a.count);
    
    return {
        rawData: {
            usedBars,
            wasteLength,
            totalMotherBarsUsed: usedBars.length,
            remainingPieces,
            motherBarLength: stockBars.length > 0 ? stockBars[0].length : 0
        },
        layouts: layoutsArray
    };
}

/**
 * Calcule les statistiques cl√©s pour un mod√®le
 * @param {Object} modelResult - R√©sultats pour un mod√®le sp√©cifique
 * @param {Array} stockBars - Barres m√®res disponibles
 * @param {Array} demandPieces - Pi√®ces √† d√©couper
 * @returns {Object} Statistiques calcul√©es
 */
function calculateModelStats(modelResult, stockBars, demandPieces) {
    // Initialiser les compteurs
    let totalDemandLength = 0;
    let totalStockLength = 0;
    let totalUsedLength = 0;
    let totalWasteLength = 0;
    
    // Initialiser les variables de statut de production
    let hasOverproduction = false;
    let hasUnderproduction = false;
    let overproductionDetails = [];
    let underproductionDetails = [];
    let totalOverproduced = 0;
    let totalUnderproduced = 0;

    // 1. Calculer la somme des longueurs de toutes les pi√®ces √† d√©couper
    const demandByPieceLength = new Map();
    for (const piece of demandPieces) {
        totalDemandLength += piece.length * piece.quantity;
        demandByPieceLength.set(piece.length, piece.quantity);
    }

    // 2. Calculer la somme des longueurs de toutes les barres m√®res disponibles
    for (const bar of stockBars) {
        totalStockLength += bar.length * bar.quantity;
    }

    // 3. Calculer la somme des longueurs utilis√©es et des chutes dans les layouts
    if (modelResult.layouts && modelResult.layouts.length > 0) {
        // Garder trace des pi√®ces d√©coup√©es par longueur
        const cutPiecesByLength = new Map();
        
        // R√©initialiser totalWasteLength pour un calcul pr√©cis
        totalWasteLength = 0;
        
        for (const layout of modelResult.layouts) {
            // Nombre de barres de ce layout
            const count = layout.count || 1;
            
            // Pour chaque barre de ce layout
            const pieces = layout.cuts || layout.pieces || [];
            
            // Compter les pi√®ces par longueur
            for (const pieceLength of pieces) {
                const currentCount = cutPiecesByLength.get(pieceLength) || 0;
                cutPiecesByLength.set(pieceLength, currentCount + count);
            }
            
            const pieceSum = pieces.reduce((sum, piece) => sum + piece, 0);
            const wasteLength = layout.remainingLength || layout.waste || 0;
            
            // Multiplier par le nombre de fois que ce layout est utilis√©
            totalUsedLength += pieceSum * count;
            totalWasteLength += wasteLength * count;
        }
        
        // Calculer la longueur totale des barres utilis√©es
        let totalBarsLength = 0;
        if (modelResult.rawData && modelResult.rawData.usedBars) {
            totalBarsLength = modelResult.rawData.usedBars.reduce((sum, bar) => sum + bar.originalLength, 0);
        }
        
        // Le taux d'utilisation correct est:
        const correctUtilizationRate = totalBarsLength > 0 ? ((totalUsedLength / totalBarsLength) * 100).toFixed(3) : 0;
        
        // V√©rifier s'il y a une surproduction
        for (const [pieceLength, cutCount] of cutPiecesByLength.entries()) {
            const demandCount = demandByPieceLength.get(pieceLength) || 0;
            const diff = cutCount - demandCount;
            
            if (diff > 0) {
                hasOverproduction = true;
                totalOverproduced += diff;
                overproductionDetails.push(`${diff} pi√®ces de longueur ${pieceLength}`);
            } else if (diff < 0) {
                hasUnderproduction = true;
                totalUnderproduced += Math.abs(diff);
                underproductionDetails.push(`${Math.abs(diff)} pi√®ces de longueur ${pieceLength}`);
            }
        }
        
        // Afficher des avertissements clairs pour les probl√®mes d√©tect√©s
        if (hasOverproduction) {
            console.warn(`‚ö†Ô∏è SURPRODUCTION: ${totalOverproduced} pi√®ces au total`);
        }
        
        if (hasUnderproduction) {
            console.warn(`‚ö†Ô∏è PRODUCTION INCOMPL√àTE: ${totalUnderproduced} pi√®ces manquantes`);
        }
    }

    return {
        totalDemandLength,
        totalStockLength,
        totalUsedLength,
        totalWasteLength,
        // Correction du calcul du taux d'utilisation
        utilizationRate: totalUsedLength > 0 && modelResult.rawData && modelResult.rawData.usedBars && modelResult.rawData.usedBars.length > 0 
            ? ((totalUsedLength / modelResult.rawData.usedBars.reduce((sum, bar) => sum + bar.originalLength, 0)) * 100).toFixed(3) 
            : 0,
        overproductionDetails: hasOverproduction ? overproductionDetails.join(', ') : null,
        underproductionDetails: hasUnderproduction ? underproductionDetails.join(', ') : null,
        hasOverproduction,
        hasUnderproduction,
        totalOverproduced,
        totalUnderproduced
    };
}
