/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/javascript-lp-solver/src/External/lpsolve/Reformat.js":
/*!****************************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/External/lpsolve/Reformat.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("/*global describe*/\r\n/*global require*/\r\n/*global module*/\r\n/*global it*/\r\n/*global console*/\r\n/*global process*/\r\n/*jshint -W083 */\r\n\r\n /*************************************************************\r\n * Method: to_JSON\r\n * Scope: Public:\r\n * Agruments: input: Whatever the user gives us\r\n * Purpose: Convert an unfriendly formatted LP\r\n *          into something that our library can\r\n *          work with\r\n **************************************************************/\r\nfunction to_JSON(input){\r\n    var rxo = {\r\n        /* jshint ignore:start */\r\n        \"is_blank\": /^\\W{0,}$/,\r\n        \"is_objective\": /(max|min)(imize){0,}\\:/i,\r\n        \"is_int\": /^(?!\\/\\*)\\W{0,}int/i,\r\n        \"is_bin\": /^(?!\\/\\*)\\W{0,}bin/i,\r\n        \"is_constraint\": /(\\>|\\<){0,}\\=/i,\r\n        \"is_unrestricted\": /^\\S{0,}unrestricted/i,\r\n        \"parse_lhs\":  /(\\-|\\+){0,1}\\s{0,1}\\d{0,}\\.{0,}\\d{0,}\\s{0,}[A-Za-z]\\S{0,}/gi,\r\n        \"parse_rhs\": /(\\-|\\+){0,1}\\d{1,}\\.{0,}\\d{0,}\\W{0,}\\;{0,1}$/i,\r\n        \"parse_dir\": /(\\>|\\<){0,}\\=/gi,\r\n        \"parse_int\": /[^\\s|^\\,]+/gi,\r\n        \"parse_bin\": /[^\\s|^\\,]+/gi,\r\n        \"get_num\": /(\\-|\\+){0,1}(\\W|^)\\d+\\.{0,1}\\d{0,}/g,\r\n        \"get_word\": /[A-Za-z].*/\r\n        /* jshint ignore:end */\r\n    },\r\n    model = {\r\n        \"opType\": \"\",\r\n        \"optimize\": \"_obj\",\r\n        \"constraints\": {},\r\n        \"variables\": {}\r\n    },\r\n    constraints = {\r\n        \">=\": \"min\",\r\n        \"<=\": \"max\",\r\n        \"=\": \"equal\"\r\n    },\r\n    tmp = \"\", tst = 0, ary = null, hldr = \"\", hldr2 = \"\",\r\n    constraint = \"\", rhs = 0;\r\n\r\n    // Handle input if its coming\r\n    // to us as a hard string\r\n    // instead of as an array of\r\n    // strings\r\n    if(typeof input === \"string\"){\r\n        input = input.split(\"\\n\");\r\n    }\r\n\r\n    // Start iterating over the rows\r\n    // to see what all we have\r\n    for(var i = 0; i < input.length; i++){\r\n\r\n        constraint = \"__\" + i;\r\n\r\n        // Get the string we're working with\r\n        tmp = input[i];\r\n\r\n        // Set the test = 0\r\n        tst = 0;\r\n\r\n        // Reset the array\r\n        ary = null;\r\n\r\n        // Test to see if we're the objective\r\n        if(rxo.is_objective.test(tmp)){\r\n            // Set up in model the opType\r\n            model.opType = tmp.match(/(max|min)/gi)[0];\r\n\r\n            // Pull apart lhs\r\n            ary = tmp.match(rxo.parse_lhs).map(function(d){\r\n                return d.replace(/\\s+/,\"\");\r\n            }).slice(1);\r\n\r\n\r\n\r\n            // *** STEP 1 *** ///\r\n            // Get the variables out\r\n            ary.forEach(function(d){\r\n\r\n                // Get the number if its there\r\n                hldr = d.match(rxo.get_num);\r\n\r\n                // If it isn't a number, it might\r\n                // be a standalone variable\r\n                if(hldr === null){\r\n                    if(d.substr(0,1) === \"-\"){\r\n                        hldr = -1;\r\n                    } else {\r\n                        hldr = 1;\r\n                    }\r\n                } else {\r\n                    hldr = hldr[0];\r\n                }\r\n\r\n                hldr = parseFloat(hldr);\r\n\r\n                // Get the variable type\r\n                hldr2 = d.match(rxo.get_word)[0].replace(/\\;$/,\"\");\r\n\r\n                // Make sure the variable is in the model\r\n                model.variables[hldr2] = model.variables[hldr2] || {};\r\n                model.variables[hldr2]._obj = hldr;\r\n\r\n            });\r\n        ////////////////////////////////////\r\n        }else if(rxo.is_int.test(tmp)){\r\n            // Get the array of ints\r\n            ary = tmp.match(rxo.parse_int).slice(1);\r\n\r\n            // Since we have an int, our model should too\r\n            model.ints = model.ints || {};\r\n\r\n            ary.forEach(function(d){\r\n                d = d.replace(\";\",\"\");\r\n                model.ints[d] = 1;\r\n            });\r\n        ////////////////////////////////////\r\n        } else if(rxo.is_bin.test(tmp)){\r\n            // Get the array of bins\r\n            ary = tmp.match(rxo.parse_bin).slice(1);\r\n\r\n            // Since we have an binary, our model should too\r\n            model.binaries = model.binaries || {};\r\n\r\n            ary.forEach(function(d){\r\n                d = d.replace(\";\",\"\");\r\n                model.binaries[d] = 1;\r\n            });\r\n        ////////////////////////////////////\r\n        } else if(rxo.is_constraint.test(tmp)){\r\n            var separatorIndex = tmp.indexOf(\":\");\r\n            var constraintExpression = (separatorIndex === -1) ? tmp : tmp.slice(separatorIndex + 1);\r\n\r\n            // Pull apart lhs\r\n            ary = constraintExpression.match(rxo.parse_lhs).map(function(d){\r\n                return d.replace(/\\s+/,\"\");\r\n            });\r\n\r\n            // *** STEP 1 *** ///\r\n            // Get the variables out\r\n            ary.forEach(function(d){\r\n                // Get the number if its there\r\n                hldr = d.match(rxo.get_num);\r\n\r\n                if(hldr === null){\r\n                    if(d.substr(0,1) === \"-\"){\r\n                        hldr = -1;\r\n                    } else {\r\n                        hldr = 1;\r\n                    }\r\n                } else {\r\n                    hldr = hldr[0];\r\n                }\r\n\r\n                hldr = parseFloat(hldr);\r\n\r\n\r\n                // Get the variable name\r\n                hldr2 = d.match(rxo.get_word)[0];\r\n\r\n                // Make sure the variable is in the model\r\n                model.variables[hldr2] = model.variables[hldr2] || {};\r\n                model.variables[hldr2][constraint] = hldr;\r\n\r\n            });\r\n\r\n            // *** STEP 2 *** ///\r\n            // Get the RHS out\r\n            rhs = parseFloat(tmp.match(rxo.parse_rhs)[0]);\r\n\r\n            // *** STEP 3 *** ///\r\n            // Get the Constrainer out\r\n            tmp = constraints[tmp.match(rxo.parse_dir)[0]];\r\n            model.constraints[constraint] = model.constraints[constraint] || {};\r\n            model.constraints[constraint][tmp] = rhs;\r\n        ////////////////////////////////////\r\n        } else if(rxo.is_unrestricted.test(tmp)){\r\n            // Get the array of unrestricted\r\n            ary = tmp.match(rxo.parse_int).slice(1);\r\n\r\n            // Since we have an int, our model should too\r\n            model.unrestricted = model.unrestricted || {};\r\n\r\n            ary.forEach(function(d){\r\n                d = d.replace(\";\",\"\");\r\n                model.unrestricted[d] = 1;\r\n            });\r\n        }\r\n    }\r\n    return model;\r\n}\r\n\r\n\r\n /*************************************************************\r\n * Method: from_JSON\r\n * Scope: Public:\r\n * Agruments: model: The model we want solver to operate on\r\n * Purpose: Convert a friendly JSON model into a model for a\r\n *          real solving library...in this case\r\n *          lp_solver\r\n **************************************************************/\r\nfunction from_JSON(model){\r\n    // Make sure we at least have a model\r\n    if (!model) {\r\n        throw new Error(\"Solver requires a model to operate on\");\r\n    }\r\n\r\n    var output = \"\",\r\n        ary = [],\r\n        norm = 1,\r\n        lookup = {\r\n            \"max\": \"<=\",\r\n            \"min\": \">=\",\r\n            \"equal\": \"=\"\r\n        },\r\n        rxClean = new RegExp(\"[^A-Za-z0-9_\\[\\{\\}\\/\\.\\&\\#\\$\\%\\~\\'\\@\\^]\", \"gi\");\r\n\r\n    // Build the objective statement\r\n    \r\n    if(model.opType){\r\n        \r\n        output += model.opType + \":\";\r\n\r\n        // Iterate over the variables\r\n        for(var x in model.variables){\r\n            // Give each variable a self of 1 unless\r\n            // it exists already\r\n            model.variables[x][x] = model.variables[x][x] ? model.variables[x][x] : 1;\r\n\r\n            // Does our objective exist here?\r\n            if(model.variables[x][model.optimize]){\r\n                output += \" \" + model.variables[x][model.optimize] + \" \" + x.replace(rxClean,\"_\");\r\n            }\r\n        }\r\n    } else {\r\n        output += \"max:\";\r\n    }\r\n    \r\n\r\n\r\n    // Add some closure to our line thing\r\n    output += \";\\n\\n\";\r\n\r\n    // And now... to iterate over the constraints\r\n    for(var xx in model.constraints){\r\n        for(var y in model.constraints[xx]){\r\n            if(typeof lookup[y] !== \"undefined\"){\r\n                \r\n                for(var z in model.variables){\r\n\r\n                    // Does our Constraint exist here?\r\n                    if(typeof model.variables[z][xx] !== \"undefined\"){\r\n                        output += \" \" + model.variables[z][xx] + \" \" + z.replace(rxClean,\"_\");\r\n                    }\r\n                }\r\n                // Add the constraint type and value...\r\n\r\n                output += \" \" + lookup[y] + \" \" + model.constraints[xx][y];\r\n                output += \";\\n\";\r\n                \r\n            }\r\n        }\r\n    }\r\n\r\n    // Are there any ints?\r\n    if(model.ints){\r\n        output += \"\\n\\n\";\r\n        for(var xxx in model.ints){\r\n            output += \"int \" + xxx.replace(rxClean,\"_\") + \";\\n\";\r\n        }\r\n    }\r\n\r\n    // Are there any unrestricted?\r\n    if(model.unrestricted){\r\n        output += \"\\n\\n\";\r\n        for(var xxxx in model.unrestricted){\r\n            output += \"unrestricted \" + xxxx.replace(rxClean,\"_\") + \";\\n\";\r\n        }\r\n    }\r\n\r\n    // And kick the string back\r\n    return output;\r\n\r\n}\r\n\r\n\r\nmodule.exports = function (model) {\r\n    // If the user is giving us an array\r\n    // or a string, convert it to a JSON Model\r\n    // otherwise, spit it out as a string\r\n    if(model.length){\r\n        return to_JSON(model);\r\n    } else {\r\n        return from_JSON(model);\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/External/lpsolve/Reformat.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/External/lpsolve/main.js":
/*!************************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/External/lpsolve/main.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*global describe*/\r\n/*global require*/\r\n/*global it*/\r\n/*global console*/\r\n/*global process*/\r\n/*global exports*/\r\n/*global Promise*/\r\n\r\n\r\n// LP SOLVE CLI REFERENCE:\r\n// http://lpsolve.sourceforge.net/5.5/lp_solve.htm\r\n//\r\n//\r\n\r\n// var reformat = require(\"./Reformat.js\");\r\n\r\nexports.reformat = __webpack_require__(/*! ./Reformat.js */ \"./node_modules/javascript-lp-solver/src/External/lpsolve/Reformat.js\");\r\n\r\nfunction clean_data(data){\r\n\r\n    //\r\n    // Clean Up\r\n    // And Reformatting...\r\n    //\r\n    data = data.replace(\"\\\\r\\\\n\",\"\\r\\n\");\r\n\r\n\r\n    data = data.split(\"\\r\\n\");\r\n    data = data.filter(function(x){\r\n        \r\n        var rx;\r\n        \r\n        //\r\n        // Test 1\r\n        rx = new RegExp(\" 0$\",\"gi\");\r\n        if(rx.test(x) === true){\r\n            return false;\r\n        }\r\n\r\n        //\r\n        // Test 2\r\n        rx = new RegExp(\"\\\\d$\",\"gi\");\r\n        if(rx.test(x) === false){\r\n            return false;\r\n        }\r\n        \r\n\r\n        return true;\r\n    })\r\n    .map(function(x){\r\n        return x.split(/\\:{0,1} +(?=\\d)/);\r\n    })\r\n    .reduce(function(o,k,i){\r\n        o[k[0]] = k[1];\r\n        return o;\r\n    },{});\r\n    \r\n    return data;\r\n}\r\n\r\n\r\n\r\n\r\n\r\nexports.solve = function(model){\r\n    //\r\n    return new Promise(function(res, rej){\r\n        //\r\n        // Exit if we're in the browser...\r\n        //\r\n        if(typeof window !== \"undefined\"){\r\n            rej(\"Function Not Available in Browser\");\r\n        }\r\n        //\r\n        // Convert JSON model to lp_solve format\r\n        //\r\n        var data = __webpack_require__(/*! ./Reformat.js */ \"./node_modules/javascript-lp-solver/src/External/lpsolve/Reformat.js\")(model);\r\n        \r\n        \r\n        if(!model.external){\r\n            rej(\"Data for this function must be contained in the 'external' attribute. Not seeing anything there.\");\r\n        }\r\n        \r\n        // \r\n        // In the args, they *SHALL* have provided an executable\r\n        // path to the solver they're piping the data into\r\n        //\r\n        if(!model.external.binPath){\r\n            rej(\"No Executable | Binary path provided in arguments as 'binPath'\");\r\n        }\r\n        \r\n        //\r\n        // They also need to provide an arg_array\r\n        //\r\n        if(!model.external.args){\r\n            rej(\"No arguments array for cli | bash provided on 'args' attribute\");\r\n        }\r\n        \r\n        //\r\n        // They also need a tempName so we know where to store\r\n        // the temp file we're creating...\r\n        //\r\n        if(!model.external.tempName){\r\n            rej(\"No 'tempName' given. This is necessary to produce a staging file for the solver to operate on\");\r\n        }\r\n        \r\n        \r\n        \r\n        //\r\n        // To my knowledge, in Windows, you cannot directly pipe text into\r\n        // an exe...\r\n        //\r\n        // Thus, our process looks like this...\r\n        //\r\n        // 1.) Convert a model to something an external solver can use\r\n        // 2.) Save the results from step 1 as a temp-text file\r\n        // 3.) Pump the results into an exe | whatever-linux-uses\r\n        // 4.) \r\n        // \r\n        //\r\n        \r\n        var fs = __webpack_require__(/*! fs */ \"?2632\");\r\n        \r\n        fs.writeFile(model.external.tempName, data, function(fe, fd){\r\n            if(fe){\r\n                rej(fe);\r\n            } else {\r\n                //\r\n                // So it looks like we wrote to a file and closed it.\r\n                // Neat.\r\n                //\r\n                // Now we need to execute our CLI...\r\n                var exec = (__webpack_require__(/*! child_process */ \"?2c27\").execFile);\r\n                \r\n                //\r\n                // Put the temp file name in the args array...\r\n                //\r\n                model.external.args.push(model.external.tempName);\r\n                \r\n                exec(model.external.binPath, model.external.args, function(e,data){\r\n                    if(e){\r\n                        \r\n                        if(e.code === 1){\r\n                            res(clean_data(data));\r\n                        } else {\r\n                            \r\n                            var codes = {\r\n                                \"-2\": \"Out of Memory\",\r\n                                \"1\": \"SUBOPTIMAL\",\r\n                                \"2\": \"INFEASIBLE\",\r\n                                \"3\": \"UNBOUNDED\",\r\n                                \"4\": \"DEGENERATE\",\r\n                                \"5\": \"NUMFAILURE\",\r\n                                \"6\": \"USER-ABORT\",\r\n                                \"7\": \"TIMEOUT\",\r\n                                \"9\": \"PRESOLVED\",\r\n                                \"25\": \"ACCURACY ERROR\",\r\n                                \"255\": \"FILE-ERROR\"\r\n                            };\r\n                            \r\n                            var ret_obj = {\r\n                                \"code\": e.code,\r\n                                \"meaning\": codes[e.code],\r\n                                \"data\": data\r\n                            };\r\n                            \r\n                            rej(ret_obj);\r\n                        }\r\n\r\n                    } else {\r\n                        // And finally...return it.\r\n                        res(clean_data(data));\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n/*\r\nmodel.external = {\r\n    \"binPath\": \"C:/lpsolve/lp_solve.exe\",\r\n    \"tempName\": \"C:/temp/out.txt\",\r\n    \"args\": [\r\n        \"-S2\"\r\n    ]\r\n    \r\n}\r\n\r\n*/\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/External/lpsolve/main.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/External/main.js":
/*!****************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/External/main.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*global describe*/\r\n/*global require*/\r\n/*global it*/\r\n/*global console*/\r\n/*global process*/\r\n/*global exports*/\r\n/*global Promise*/\r\n/*global module*/\r\n\r\nmodule.exports = {\r\n    \"lpsolve\": __webpack_require__(/*! ./lpsolve/main.js */ \"./node_modules/javascript-lp-solver/src/External/lpsolve/main.js\")\r\n};\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/External/main.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/Model.js":
/*!********************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/Model.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*global describe*/\r\n/*global require*/\r\n/*global module*/\r\n/*global it*/\r\n/*global console*/\r\n/*global process*/\r\n\r\nvar Tableau = __webpack_require__(/*! ./Tableau/Tableau.js */ \"./node_modules/javascript-lp-solver/src/Tableau/Tableau.js\");\r\nvar branchAndCut = __webpack_require__(/*! ./Tableau/branchAndCut.js */ \"./node_modules/javascript-lp-solver/src/Tableau/branchAndCut.js\");\r\nvar expressions = __webpack_require__(/*! ./expressions.js */ \"./node_modules/javascript-lp-solver/src/expressions.js\");\r\nvar Constraint = expressions.Constraint;\r\nvar Equality = expressions.Equality;\r\nvar Variable = expressions.Variable;\r\nvar IntegerVariable = expressions.IntegerVariable;\r\nvar Term = expressions.Term;\r\n\r\n/*************************************************************\r\n * Class: Model\r\n * Description: Holds the model of a linear optimisation problem\r\n **************************************************************/\r\nfunction Model(precision, name) {\r\n    this.tableau = new Tableau(precision);\r\n\r\n    this.name = name;\r\n\r\n    this.variables = [];\r\n\r\n    this.integerVariables = [];\r\n\r\n    this.unrestrictedVariables = {};\r\n\r\n    this.constraints = [];\r\n\r\n    this.nConstraints = 0;\r\n\r\n    this.nVariables = 0;\r\n\r\n    this.isMinimization = true;\r\n\r\n    this.tableauInitialized = false;\r\n    \r\n    this.relaxationIndex = 1;\r\n\r\n    this.useMIRCuts = false;\r\n\r\n    this.checkForCycles = true;\r\n    \r\n    //\r\n    // Quick and dirty way to leave useful information\r\n    // for the end user without hitting the console\r\n    // or modifying the primary return object...\r\n    //\r\n    this.messages = [];\r\n}\r\nmodule.exports = Model;\r\n\r\nModel.prototype.minimize = function () {\r\n    this.isMinimization = true;\r\n    return this;\r\n};\r\n\r\nModel.prototype.maximize = function () {\r\n    this.isMinimization = false;\r\n    return this;\r\n};\r\n\r\n// Model.prototype.addConstraint = function (constraint) {\r\n//     // TODO: make sure that the constraint does not belong do another model\r\n//     // and make\r\n//     this.constraints.push(constraint);\r\n//     return this;\r\n// };\r\n\r\nModel.prototype._getNewElementIndex = function () {\r\n    if (this.availableIndexes.length > 0) {\r\n        return this.availableIndexes.pop();\r\n    }\r\n\r\n    var index = this.lastElementIndex;\r\n    this.lastElementIndex += 1;\r\n    return index;\r\n};\r\n\r\nModel.prototype._addConstraint = function (constraint) {\r\n    var slackVariable = constraint.slack;\r\n    this.tableau.variablesPerIndex[slackVariable.index] = slackVariable;\r\n    this.constraints.push(constraint);\r\n    this.nConstraints += 1;\r\n    if (this.tableauInitialized === true) {\r\n        this.tableau.addConstraint(constraint);\r\n    }\r\n};\r\n\r\nModel.prototype.smallerThan = function (rhs) {\r\n    var constraint = new Constraint(rhs, true, this.tableau.getNewElementIndex(), this);\r\n    this._addConstraint(constraint);\r\n    return constraint;\r\n};\r\n\r\nModel.prototype.greaterThan = function (rhs) {\r\n    var constraint = new Constraint(rhs, false, this.tableau.getNewElementIndex(), this);\r\n    this._addConstraint(constraint);\r\n    return constraint;\r\n};\r\n\r\nModel.prototype.equal = function (rhs) {\r\n    var constraintUpper = new Constraint(rhs, true, this.tableau.getNewElementIndex(), this);\r\n    this._addConstraint(constraintUpper);\r\n\r\n    var constraintLower = new Constraint(rhs, false, this.tableau.getNewElementIndex(), this);\r\n    this._addConstraint(constraintLower);\r\n\r\n    return new Equality(constraintUpper, constraintLower);\r\n};\r\n\r\nModel.prototype.addVariable = function (cost, id, isInteger, isUnrestricted, priority) {\r\n    if (typeof priority === \"string\") {\r\n        switch (priority) {\r\n        case \"required\":\r\n            priority = 0;\r\n            break;\r\n        case \"strong\":\r\n            priority = 1;\r\n            break;\r\n        case \"medium\":\r\n            priority = 2;\r\n            break;\r\n        case \"weak\":\r\n            priority = 3;\r\n            break;\r\n        default:\r\n            priority = 0;\r\n            break;\r\n        }\r\n    }\r\n\r\n    var varIndex = this.tableau.getNewElementIndex();\r\n    if (id === null || id === undefined) {\r\n        id = \"v\" + varIndex;\r\n    }\r\n\r\n    if (cost === null || cost === undefined) {\r\n        cost = 0;\r\n    }\r\n\r\n    if (priority === null || priority === undefined) {\r\n        priority = 0;\r\n    }\r\n\r\n    var variable;\r\n    if (isInteger) {\r\n        variable = new IntegerVariable(id, cost, varIndex, priority);\r\n        this.integerVariables.push(variable);\r\n    } else {\r\n        variable = new Variable(id, cost, varIndex, priority);\r\n    }\r\n\r\n    this.variables.push(variable);\r\n    this.tableau.variablesPerIndex[varIndex] = variable;\r\n\r\n    if (isUnrestricted) {\r\n        this.unrestrictedVariables[varIndex] = true;\r\n    }\r\n\r\n    this.nVariables += 1;\r\n\r\n    if (this.tableauInitialized === true) {\r\n        this.tableau.addVariable(variable);\r\n    }\r\n\r\n    return variable;\r\n};\r\n\r\nModel.prototype._removeConstraint = function (constraint) {\r\n    var idx = this.constraints.indexOf(constraint);\r\n    if (idx === -1) {\r\n        console.warn(\"[Model.removeConstraint] Constraint not present in model\");\r\n        return;\r\n    }\r\n\r\n    this.constraints.splice(idx, 1);\r\n    this.nConstraints -= 1;\r\n\r\n    if (this.tableauInitialized === true) {\r\n        this.tableau.removeConstraint(constraint);\r\n    }\r\n\r\n    if (constraint.relaxation) {\r\n        this.removeVariable(constraint.relaxation);\r\n    }\r\n};\r\n\r\n//-------------------------------------------------------------------\r\n// For dynamic model modification\r\n//-------------------------------------------------------------------\r\nModel.prototype.removeConstraint = function (constraint) {\r\n    if (constraint.isEquality) {\r\n        this._removeConstraint(constraint.upperBound);\r\n        this._removeConstraint(constraint.lowerBound);\r\n    } else {\r\n        this._removeConstraint(constraint);\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\nModel.prototype.removeVariable = function (variable) {\r\n    var idx = this.variables.indexOf(variable);\r\n    if (idx === -1) {\r\n        console.warn(\"[Model.removeVariable] Variable not present in model\");\r\n        return;\r\n    }\r\n    this.variables.splice(idx, 1);\r\n\r\n    if (this.tableauInitialized === true) {\r\n        this.tableau.removeVariable(variable);\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\nModel.prototype.updateRightHandSide = function (constraint, difference) {\r\n    if (this.tableauInitialized === true) {\r\n        this.tableau.updateRightHandSide(constraint, difference);\r\n    }\r\n    return this;\r\n};\r\n\r\nModel.prototype.updateConstraintCoefficient = function (constraint, variable, difference) {\r\n    if (this.tableauInitialized === true) {\r\n        this.tableau.updateConstraintCoefficient(constraint, variable, difference);\r\n    }\r\n    return this;\r\n};\r\n\r\n\r\nModel.prototype.setCost = function (cost, variable) {\r\n    var difference = cost - variable.cost;\r\n    if (this.isMinimization === false) {\r\n        difference = -difference;\r\n    }\r\n\r\n    variable.cost = cost;\r\n    this.tableau.updateCost(variable, difference);\r\n    return this;\r\n};\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nModel.prototype.loadJson = function (jsonModel) {\r\n    this.isMinimization = (jsonModel.opType !== \"max\");\r\n\r\n    var variables = jsonModel.variables;\r\n    var constraints = jsonModel.constraints;\r\n\r\n    var constraintsMin = {};\r\n    var constraintsMax = {};\r\n\r\n    // Instantiating constraints\r\n    var constraintIds = Object.keys(constraints);\r\n    var nConstraintIds = constraintIds.length;\r\n\r\n    for (var c = 0; c < nConstraintIds; c += 1) {\r\n        var constraintId = constraintIds[c];\r\n        var constraint = constraints[constraintId];\r\n        var equal = constraint.equal;\r\n\r\n        var weight = constraint.weight;\r\n        var priority = constraint.priority;\r\n        var relaxed = weight !== undefined || priority !== undefined;\r\n\r\n        var lowerBound, upperBound;\r\n        if (equal === undefined) {\r\n            var min = constraint.min;\r\n            if (min !== undefined) {\r\n                lowerBound = this.greaterThan(min);\r\n                constraintsMin[constraintId] = lowerBound;\r\n                if (relaxed) { lowerBound.relax(weight, priority); }\r\n            }\r\n\r\n            var max = constraint.max;\r\n            if (max !== undefined) {\r\n                upperBound = this.smallerThan(max);\r\n                constraintsMax[constraintId] = upperBound;\r\n                if (relaxed) { upperBound.relax(weight, priority); }\r\n            }\r\n        } else {\r\n            lowerBound = this.greaterThan(equal);\r\n            constraintsMin[constraintId] = lowerBound;\r\n\r\n            upperBound = this.smallerThan(equal);\r\n            constraintsMax[constraintId] = upperBound;\r\n\r\n            var equality = new Equality(lowerBound, upperBound);\r\n            if (relaxed) { equality.relax(weight, priority); }\r\n        }\r\n    }\r\n\r\n    var variableIds = Object.keys(variables);\r\n    var nVariables = variableIds.length;\r\n    \r\n    \r\n    \r\n//\r\n//\r\n// *** OPTIONS ***\r\n//\r\n//\r\n\r\n    this.tolerance = jsonModel.tolerance || 0;\r\n    \r\n    if(jsonModel.timeout){\r\n        this.timeout = jsonModel.timeout;\r\n    }\r\n    \r\n    //\r\n    //\r\n    // The model is getting too sloppy with options added to it...\r\n    // mebe it needs an \"options\" option...?\r\n    //\r\n    // YES! IT DOES!\r\n    // DO IT!\r\n    // NOW!\r\n    // HERE!!!\r\n    //\r\n    if(jsonModel.options){\r\n        \r\n        //\r\n        // TIMEOUT\r\n        //\r\n        if(jsonModel.options.timeout){\r\n            this.timeout = jsonModel.options.timeout;\r\n        }\r\n        \r\n        //\r\n        // TOLERANCE\r\n        //\r\n        if(this.tolerance === 0){\r\n            this.tolerance = jsonModel.options.tolerance || 0;\r\n        }\r\n        \r\n        //\r\n        // MIR CUTS - (NOT WORKING)\r\n        //\r\n        if(jsonModel.options.useMIRCuts){\r\n            this.useMIRCuts = jsonModel.options.useMIRCuts;\r\n        }\r\n        \r\n        //\r\n        // CYCLE CHECK...tricky because it defaults to false\r\n        //\r\n        //\r\n        // This should maybe be on by default...\r\n        //\r\n        if(typeof jsonModel.options.exitOnCycles === \"undefined\"){\r\n            this.checkForCycles = true;\r\n        } else {\r\n            this.checkForCycles = jsonModel.options.exitOnCycles;\r\n        }\r\n\r\n        \r\n    }\r\n    \r\n    \r\n//\r\n//\r\n// /// OPTIONS \\\\\\\r\n//\r\n//\r\n    \r\n    var integerVarIds = jsonModel.ints || {};\r\n    var binaryVarIds = jsonModel.binaries || {};\r\n    var unrestrictedVarIds = jsonModel.unrestricted || {};\r\n\r\n    // Instantiating variables and constraint terms\r\n    var objectiveName = jsonModel.optimize;\r\n    for (var v = 0; v < nVariables; v += 1) {\r\n        // Creation of the variables\r\n        var variableId = variableIds[v];\r\n        var variableConstraints = variables[variableId];\r\n        var cost = variableConstraints[objectiveName] || 0;\r\n        var isBinary = !!binaryVarIds[variableId];\r\n        var isInteger = !!integerVarIds[variableId] || isBinary;\r\n        var isUnrestricted = !!unrestrictedVarIds[variableId];\r\n        var variable = this.addVariable(cost, variableId, isInteger, isUnrestricted);\r\n\r\n        if (isBinary) {\r\n            // Creating an upperbound constraint for this variable\r\n            this.smallerThan(1).addTerm(1, variable);\r\n        }\r\n\r\n        var constraintNames = Object.keys(variableConstraints);\r\n        for (c = 0; c < constraintNames.length; c += 1) {\r\n            var constraintName = constraintNames[c];\r\n            if (constraintName === objectiveName) {\r\n                continue;\r\n            }\r\n\r\n            var coefficient = variableConstraints[constraintName];\r\n\r\n            var constraintMin = constraintsMin[constraintName];\r\n            if (constraintMin !== undefined) {\r\n                constraintMin.addTerm(coefficient, variable);\r\n            }\r\n\r\n            var constraintMax = constraintsMax[constraintName];\r\n            if (constraintMax !== undefined) {\r\n                constraintMax.addTerm(coefficient, variable);\r\n            }\r\n        }\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nModel.prototype.getNumberOfIntegerVariables = function () {\r\n    return this.integerVariables.length;\r\n};\r\n\r\nModel.prototype.solve = function () {\r\n    // Setting tableau if not done\r\n    if (this.tableauInitialized === false) {\r\n        this.tableau.setModel(this);\r\n        this.tableauInitialized = true;\r\n    }\r\n\r\n    return this.tableau.solve();\r\n};\r\n\r\nModel.prototype.isFeasible = function () {\r\n    return this.tableau.feasible;\r\n};\r\n\r\nModel.prototype.save = function () {\r\n    return this.tableau.save();\r\n};\r\n\r\nModel.prototype.restore = function () {\r\n    return this.tableau.restore();\r\n};\r\n\r\nModel.prototype.activateMIRCuts = function (useMIRCuts) {\r\n    this.useMIRCuts = useMIRCuts;\r\n};\r\n\r\nModel.prototype.debug = function (debugCheckForCycles) {\r\n    this.checkForCycles = debugCheckForCycles;\r\n};\r\n\r\nModel.prototype.log = function (message) {\r\n    return this.tableau.log(message);\r\n};\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/Model.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/Polyopt.js":
/*!**********************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/Polyopt.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("/*global describe*/\r\n/*global require*/\r\n/*global module*/\r\n/*global it*/\r\n/*global console*/\r\n/*global process*/\r\n\r\n    /***************************************************************\r\n     * Method: polyopt\r\n     * Scope: private\r\n     * Agruments:\r\n     *        model: The model we want solver to operate on.\r\n                     Because we're in here, we're assuming that\r\n                     we're solving a multi-objective optimization\r\n                     problem. Poly-Optimization. polyopt.\r\n\r\n                     This model has to be formed a little differently\r\n                     because it has multiple objective functions.\r\n                     Normally, a model has 2 attributes: opType (string,\r\n                     \"max\" or \"min\"), and optimize (string, whatever\r\n                     attribute we're optimizing.\r\n\r\n                     Now, there is no opType attribute on the model,\r\n                     and optimize is an object of attributes to be\r\n                     optimized, and how they're to be optimized.\r\n                     For example:\r\n\r\n                     ...\r\n                     \"optimize\": {\r\n                        \"pancakes\": \"max\",\r\n                        \"cost\": \"minimize\"\r\n                     }\r\n                     ...\r\n\r\n\r\n     **************************************************************/\r\n\r\nmodule.exports = function(solver, model){\r\n\r\n    // I have no idea if this is actually works, or what,\r\n    // but here is my algorithm to solve linear programs\r\n    // with multiple objective functions\r\n\r\n    // 1. Optimize for each constraint\r\n    // 2. The results for each solution is a vector\r\n    //    representing a vertex on the polytope we're creating\r\n    // 3. The results for all solutions describes the shape\r\n    //    of the polytope (would be nice to have the equation\r\n    //    representing this)\r\n    // 4. Find the mid-point between all vertices by doing the\r\n    //    following (a_1 + a_2 ... a_n) / n;\r\n    var objectives = model.optimize,\r\n        new_constraints = JSON.parse(JSON.stringify(model.optimize)),\r\n        keys = Object.keys(model.optimize),\r\n        tmp,\r\n        counter = 0,\r\n        vectors = {},\r\n        vector_key = \"\",\r\n        obj = {},\r\n        pareto = [],\r\n        i,j,x,y,z;\r\n\r\n    // Delete the optimize object from the model\r\n    delete model.optimize;\r\n\r\n    // Iterate and Clear\r\n    for(i = 0; i < keys.length; i++){\r\n        // Clean up the new_constraints\r\n        new_constraints[keys[i]] = 0;\r\n    }\r\n\r\n    // Solve and add\r\n    for(i = 0; i < keys.length; i++){\r\n\r\n        // Prep the model\r\n        model.optimize = keys[i];\r\n        model.opType = objectives[keys[i]];\r\n\r\n        // solve the model\r\n        tmp = solver.Solve(model, undefined, undefined, true);\r\n\r\n        // Only the variables make it into the solution;\r\n        // not the attributes.\r\n        //\r\n        // Because of this, we have to add the attributes\r\n        // back onto the solution so we can do math with\r\n        // them later...\r\n\r\n        // Loop over the keys\r\n        for(y in keys){\r\n            // We're only worried about attributes, not variables\r\n            if(!model.variables[keys[y]]){\r\n                // Create space for the attribute in the tmp object\r\n                tmp[keys[y]] = tmp[keys[y]] ? tmp[keys[y]] : 0;\r\n                // Go over each of the variables\r\n                for(x in model.variables){\r\n                    // Does the variable exist in tmp *and* does attribute exist in this model?\r\n                    if(model.variables[x][keys[y]] && tmp[x]){\r\n                        // Add it to tmp\r\n                        tmp[keys[y]] += tmp[x] * model.variables[x][keys[y]];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // clear our key\r\n        vector_key = \"base\";\r\n        // this makes sure that if we get\r\n        // the same vector more than once,\r\n        // we only count it once when finding\r\n        // the midpoint\r\n        for(j = 0; j < keys.length; j++){\r\n            if(tmp[keys[j]]){\r\n                vector_key += \"-\" + ((tmp[keys[j]] * 1000) | 0) / 1000;\r\n            } else {\r\n                vector_key += \"-0\";\r\n            }\r\n        }\r\n\r\n        // Check here to ensure it doesn't exist\r\n        if(!vectors[vector_key]){\r\n            // Add the vector-key in\r\n            vectors[vector_key] = 1;\r\n            counter++;\r\n            \r\n            // Iterate over the keys\r\n            // and update our new constraints\r\n            for(j = 0; j < keys.length; j++){\r\n                if(tmp[keys[j]]){\r\n                    new_constraints[keys[j]] += tmp[keys[j]];\r\n                }\r\n            }\r\n            \r\n            // Push the solution into the paretos\r\n            // array after cleaning it of some\r\n            // excess data markers\r\n            \r\n            delete tmp.feasible;\r\n            delete tmp.result;            \r\n            pareto.push(tmp);\r\n        }\r\n    }\r\n\r\n    // Trying to find the mid-point\r\n    // divide each constraint by the\r\n    // number of constraints\r\n    // *midpoint formula*\r\n    // (x1 + x2 + x3) / 3\r\n    for(i = 0; i < keys.length; i++){\r\n        model.constraints[keys[i]] = {\"equal\": new_constraints[keys[i]] / counter};\r\n    }\r\n\r\n    // Give the model a fake thing to optimize on\r\n    model.optimize = \"cheater-\" + Math.random();\r\n    model.opType = \"max\";\r\n\r\n    // And add the fake attribute to the variables\r\n    // in the model\r\n    for(i in model.variables){\r\n        model.variables[i].cheater = 1;\r\n    }\r\n    \r\n    // Build out the object with all attributes\r\n    for(i in pareto){\r\n        for(x in pareto[i]){\r\n            obj[x] = obj[x] || {min: 1e99, max: -1e99};\r\n        }\r\n    }\r\n    \r\n    // Give each pareto a full attribute list\r\n    // while getting the max and min values\r\n    // for each attribute\r\n    for(i in obj){\r\n        for(x in pareto){\r\n            if(pareto[x][i]){\r\n                if(pareto[x][i] > obj[i].max){\r\n                    obj[i].max = pareto[x][i];\r\n                } \r\n                if(pareto[x][i] < obj[i].min){\r\n                    obj[i].min = pareto[x][i];\r\n                }\r\n            } else {\r\n                pareto[x][i] = 0;\r\n                obj[i].min = 0;\r\n            }\r\n        }\r\n    }\r\n    // Solve the model for the midpoints\r\n    tmp =  solver.Solve(model, undefined, undefined, true);\r\n    \r\n    return {\r\n        midpoint: tmp,\r\n        vertices: pareto,\r\n        ranges: obj\r\n    };    \r\n\r\n};\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/Polyopt.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/Tableau/MilpSolution.js":
/*!***********************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/Tableau/MilpSolution.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*global module*/\r\n/*global require*/\r\nvar Solution = __webpack_require__(/*! ./Solution.js */ \"./node_modules/javascript-lp-solver/src/Tableau/Solution.js\");\r\n\r\nfunction MilpSolution(tableau, evaluation, feasible, bounded, branchAndCutIterations) {\r\n    Solution.call(this, tableau, evaluation, feasible, bounded);\r\n    this.iter = branchAndCutIterations;\r\n}\r\nmodule.exports = MilpSolution;\r\nMilpSolution.prototype = Object.create(Solution.prototype);\r\nMilpSolution.constructor = MilpSolution;\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/Tableau/MilpSolution.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/Tableau/Solution.js":
/*!*******************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/Tableau/Solution.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("/*global module*/\r\n\r\nfunction Solution(tableau, evaluation, feasible, bounded) {\r\n    this.feasible = feasible;\r\n    this.evaluation = evaluation;\r\n    this.bounded = bounded;\r\n    this._tableau = tableau;\r\n}\r\nmodule.exports = Solution;\r\n\r\nSolution.prototype.generateSolutionSet = function () {\r\n    var solutionSet = {};\r\n\r\n    var tableau = this._tableau;\r\n    var varIndexByRow = tableau.varIndexByRow;\r\n    var variablesPerIndex = tableau.variablesPerIndex;\r\n    var matrix = tableau.matrix;\r\n    var rhsColumn = tableau.rhsColumn;\r\n    var lastRow = tableau.height - 1;\r\n    var roundingCoeff = Math.round(1 / tableau.precision);\r\n\r\n    for (var r = 1; r <= lastRow; r += 1) {\r\n        var varIndex = varIndexByRow[r];\r\n        var variable = variablesPerIndex[varIndex];\r\n        if (variable === undefined || variable.isSlack === true) {\r\n            continue;\r\n        }\r\n\r\n        var varValue = matrix[r][rhsColumn];\r\n        solutionSet[variable.id] =\r\n            Math.round((Number.EPSILON + varValue) * roundingCoeff) / roundingCoeff;\r\n    }\r\n\r\n    return solutionSet;\r\n};\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/Tableau/Solution.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/Tableau/Tableau.js":
/*!******************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/Tableau/Tableau.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*global describe*/\r\n/*global require*/\r\n/*global module*/\r\n/*global it*/\r\n/*global console*/\r\n/*global process*/\r\nvar Solution = __webpack_require__(/*! ./Solution.js */ \"./node_modules/javascript-lp-solver/src/Tableau/Solution.js\");\r\nvar MilpSolution = __webpack_require__(/*! ./MilpSolution.js */ \"./node_modules/javascript-lp-solver/src/Tableau/MilpSolution.js\");\r\n\r\n/*************************************************************\r\n * Class: Tableau\r\n * Description: Simplex tableau, holding a the tableau matrix\r\n *              and all the information necessary to perform\r\n *              the simplex algorithm\r\n * Agruments:\r\n *        precision: If we're solving a MILP, how tight\r\n *                   do we want to define an integer, given\r\n *                   that 20.000000000000001 is not an integer.\r\n *                   (defaults to 1e-8)\r\n **************************************************************/\r\nfunction Tableau(precision) {\r\n    this.model = null;\r\n\r\n    this.matrix = null;\r\n    this.width = 0;\r\n    this.height = 0;\r\n\r\n    this.costRowIndex = 0;\r\n    this.rhsColumn = 0;\r\n\r\n    this.variablesPerIndex = [];\r\n    this.unrestrictedVars = null;\r\n\r\n    // Solution attributes\r\n    this.feasible = true; // until proven guilty\r\n    this.evaluation = 0;\r\n    this.simplexIters = 0;\r\n\r\n    this.varIndexByRow = null;\r\n    this.varIndexByCol = null;\r\n\r\n    this.rowByVarIndex = null;\r\n    this.colByVarIndex = null;\r\n\r\n    this.precision = precision || 1e-8;\r\n\r\n    this.optionalObjectives = [];\r\n    this.objectivesByPriority = {};\r\n\r\n    this.savedState = null;\r\n\r\n    this.availableIndexes = [];\r\n    this.lastElementIndex = 0;\r\n\r\n    this.variables = null;\r\n    this.nVars = 0;\r\n\r\n    this.bounded = true;\r\n    this.unboundedVarIndex = null;\r\n\r\n    this.branchAndCutIterations = 0;\r\n}\r\nmodule.exports = Tableau;\r\n\r\nTableau.prototype.solve = function () {\r\n    if (this.model.getNumberOfIntegerVariables() > 0) {\r\n        this.branchAndCut();\r\n    } else {\r\n        this.simplex();\r\n    }\r\n    this.updateVariableValues();\r\n    return this.getSolution();\r\n};\r\n\r\nfunction OptionalObjective(priority, nColumns) {\r\n    this.priority = priority;\r\n    this.reducedCosts = new Array(nColumns);\r\n    for (var c = 0; c < nColumns; c += 1) {\r\n        this.reducedCosts[c] = 0;\r\n    }\r\n}\r\n\r\nOptionalObjective.prototype.copy = function () {\r\n    var copy = new OptionalObjective(this.priority, this.reducedCosts.length);\r\n    copy.reducedCosts = this.reducedCosts.slice();\r\n    return copy;\r\n};\r\n\r\nTableau.prototype.setOptionalObjective = function (priority, column, cost) {\r\n    var objectiveForPriority = this.objectivesByPriority[priority];\r\n    if (objectiveForPriority === undefined) {\r\n        var nColumns = Math.max(this.width, column + 1);\r\n        objectiveForPriority = new OptionalObjective(priority, nColumns);\r\n        this.objectivesByPriority[priority] = objectiveForPriority;\r\n        this.optionalObjectives.push(objectiveForPriority);\r\n        this.optionalObjectives.sort(function (a, b) {\r\n            return a.priority - b.priority;\r\n        });\r\n    }\r\n\r\n    objectiveForPriority.reducedCosts[column] = cost;\r\n};\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nTableau.prototype.initialize = function (width, height, variables, unrestrictedVars) {\r\n    this.variables = variables;\r\n    this.unrestrictedVars = unrestrictedVars;\r\n\r\n    this.width = width;\r\n    this.height = height;\r\n\r\n\r\n// console.time(\"tableau_build\");\r\n    // BUILD AN EMPTY ARRAY OF THAT WIDTH\r\n    var tmpRow = new Array(width);\r\n    for (var i = 0; i < width; i++) {\r\n        tmpRow[i] = 0;\r\n    }\r\n\r\n    // BUILD AN EMPTY TABLEAU\r\n    this.matrix = new Array(height);\r\n    for (var j = 0; j < height; j++) {\r\n        this.matrix[j] = tmpRow.slice();\r\n    }\r\n\r\n//\r\n// TODO: Benchmark This\r\n//this.matrix = new Array(height).fill(0).map(() => new Array(width).fill(0));\r\n\r\n// console.timeEnd(\"tableau_build\");\r\n// console.log(\"height\",height);\r\n// console.log(\"width\",width);\r\n// console.log(\"------\");\r\n// console.log(\"\");\r\n\r\n\r\n    this.varIndexByRow = new Array(this.height);\r\n    this.varIndexByCol = new Array(this.width);\r\n\r\n    this.varIndexByRow[0] = -1;\r\n    this.varIndexByCol[0] = -1;\r\n\r\n    this.nVars = width + height - 2;\r\n    this.rowByVarIndex = new Array(this.nVars);\r\n    this.colByVarIndex = new Array(this.nVars);\r\n\r\n    this.lastElementIndex = this.nVars;\r\n};\r\n\r\nTableau.prototype._resetMatrix = function () {\r\n    var variables = this.model.variables;\r\n    var constraints = this.model.constraints;\r\n\r\n    var nVars = variables.length;\r\n    var nConstraints = constraints.length;\r\n\r\n    var v, varIndex;\r\n    var costRow = this.matrix[0];\r\n    var coeff = (this.model.isMinimization === true) ? -1 : 1;\r\n    for (v = 0; v < nVars; v += 1) {\r\n        var variable = variables[v];\r\n        var priority = variable.priority;\r\n        var cost = coeff * variable.cost;\r\n        if (priority === 0) {\r\n            costRow[v + 1] = cost;\r\n        } else {\r\n            this.setOptionalObjective(priority, v + 1, cost);\r\n        }\r\n\r\n        varIndex = variables[v].index;\r\n        this.rowByVarIndex[varIndex] = -1;\r\n        this.colByVarIndex[varIndex] = v + 1;\r\n        this.varIndexByCol[v + 1] = varIndex;\r\n    }\r\n\r\n    var rowIndex = 1;\r\n    for (var c = 0; c < nConstraints; c += 1) {\r\n        var constraint = constraints[c];\r\n\r\n        var constraintIndex = constraint.index;\r\n        this.rowByVarIndex[constraintIndex] = rowIndex;\r\n        this.colByVarIndex[constraintIndex] = -1;\r\n        this.varIndexByRow[rowIndex] = constraintIndex;\r\n\r\n        var t, term, column;\r\n        var terms = constraint.terms;\r\n        var nTerms = terms.length;\r\n        var row = this.matrix[rowIndex++];\r\n        if (constraint.isUpperBound) {\r\n            for (t = 0; t < nTerms; t += 1) {\r\n                term = terms[t];\r\n                column = this.colByVarIndex[term.variable.index];\r\n                row[column] = term.coefficient;\r\n            }\r\n\r\n            row[0] = constraint.rhs;\r\n        } else {\r\n            for (t = 0; t < nTerms; t += 1) {\r\n                term = terms[t];\r\n                column = this.colByVarIndex[term.variable.index];\r\n                row[column] = -term.coefficient;\r\n            }\r\n\r\n            row[0] = -constraint.rhs;\r\n        }\r\n    }\r\n};\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nTableau.prototype.setModel = function (model) {\r\n    this.model = model;\r\n\r\n    var width = model.nVariables + 1;\r\n    var height = model.nConstraints + 1;\r\n\r\n\r\n    this.initialize(width, height, model.variables, model.unrestrictedVariables);\r\n    this._resetMatrix();\r\n    return this;\r\n};\r\n\r\nTableau.prototype.getNewElementIndex = function () {\r\n    if (this.availableIndexes.length > 0) {\r\n        return this.availableIndexes.pop();\r\n    }\r\n\r\n    var index = this.lastElementIndex;\r\n    this.lastElementIndex += 1;\r\n    return index;\r\n};\r\n\r\nTableau.prototype.density = function () {\r\n    var density = 0;\r\n\r\n    var matrix = this.matrix;\r\n    for (var r = 0; r < this.height; r++) {\r\n        var row = matrix[r];\r\n        for (var c = 0; c < this.width; c++) {\r\n            if (row[c] !== 0) {\r\n                density += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    return density / (this.height * this.width);\r\n};\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nTableau.prototype.setEvaluation = function () {\r\n    // Rounding objective value\r\n    var roundingCoeff = Math.round(1 / this.precision);\r\n    var evaluation = this.matrix[this.costRowIndex][this.rhsColumn];\r\n    var roundedEvaluation =\r\n        Math.round((Number.EPSILON + evaluation) * roundingCoeff) / roundingCoeff;\r\n\r\n    this.evaluation = roundedEvaluation;\r\n    if (this.simplexIters === 0) {\r\n        this.bestPossibleEval = roundedEvaluation;\r\n    }\r\n};\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nTableau.prototype.getSolution = function () {\r\n    var evaluation = (this.model.isMinimization === true) ?\r\n        this.evaluation : -this.evaluation;\r\n\r\n    if (this.model.getNumberOfIntegerVariables() > 0) {\r\n        return new MilpSolution(this, evaluation, this.feasible, this.bounded, this.branchAndCutIterations);\r\n    } else {\r\n        return new Solution(this, evaluation, this.feasible, this.bounded);\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/Tableau/Tableau.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/Tableau/backup.js":
/*!*****************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/Tableau/backup.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/*global require*/\r\nvar Tableau = __webpack_require__(/*! ./Tableau.js */ \"./node_modules/javascript-lp-solver/src/Tableau/Tableau.js\");\r\n\r\nTableau.prototype.copy = function () {\r\n    var copy = new Tableau(this.precision);\r\n\r\n    copy.width = this.width;\r\n    copy.height = this.height;\r\n\r\n    copy.nVars = this.nVars;\r\n    copy.model = this.model;\r\n\r\n    // Making a shallow copy of integer variable indexes\r\n    // and variable ids\r\n    copy.variables = this.variables;\r\n    copy.variablesPerIndex = this.variablesPerIndex;\r\n    copy.unrestrictedVars = this.unrestrictedVars;\r\n    copy.lastElementIndex = this.lastElementIndex;\r\n\r\n    // All the other arrays are deep copied\r\n    copy.varIndexByRow = this.varIndexByRow.slice();\r\n    copy.varIndexByCol = this.varIndexByCol.slice();\r\n\r\n    copy.rowByVarIndex = this.rowByVarIndex.slice();\r\n    copy.colByVarIndex = this.colByVarIndex.slice();\r\n\r\n    copy.availableIndexes = this.availableIndexes.slice();\r\n\r\n    var optionalObjectivesCopy = [];\r\n    for(var o = 0; o < this.optionalObjectives.length; o++){\r\n        optionalObjectivesCopy[o] = this.optionalObjectives[o].copy();\r\n    }\r\n    copy.optionalObjectives = optionalObjectivesCopy;\r\n\r\n\r\n    var matrix = this.matrix;\r\n    var matrixCopy = new Array(this.height);\r\n    for (var r = 0; r < this.height; r++) {\r\n        matrixCopy[r] = matrix[r].slice();\r\n    }\r\n\r\n    copy.matrix = matrixCopy;\r\n\r\n    return copy;\r\n};\r\n\r\nTableau.prototype.save = function () {\r\n    this.savedState = this.copy();\r\n};\r\n\r\nTableau.prototype.restore = function () {\r\n    if (this.savedState === null) {\r\n        return;\r\n    }\r\n\r\n    var save = this.savedState;\r\n    var savedMatrix = save.matrix;\r\n    this.nVars = save.nVars;\r\n    this.model = save.model;\r\n\r\n    // Shallow restore\r\n    this.variables = save.variables;\r\n    this.variablesPerIndex = save.variablesPerIndex;\r\n    this.unrestrictedVars = save.unrestrictedVars;\r\n    this.lastElementIndex = save.lastElementIndex;\r\n\r\n    this.width = save.width;\r\n    this.height = save.height;\r\n\r\n    // Restoring matrix\r\n    var r, c;\r\n    for (r = 0; r < this.height; r += 1) {\r\n        var savedRow = savedMatrix[r];\r\n        var row = this.matrix[r];\r\n        for (c = 0; c < this.width; c += 1) {\r\n            row[c] = savedRow[c];\r\n        }\r\n    }\r\n\r\n    // Restoring all the other structures\r\n    var savedBasicIndexes = save.varIndexByRow;\r\n    for (c = 0; c < this.height; c += 1) {\r\n        this.varIndexByRow[c] = savedBasicIndexes[c];\r\n    }\r\n\r\n    while (this.varIndexByRow.length > this.height) {\r\n        this.varIndexByRow.pop();\r\n    }\r\n\r\n    var savedNonBasicIndexes = save.varIndexByCol;\r\n    for (r = 0; r < this.width; r += 1) {\r\n        this.varIndexByCol[r] = savedNonBasicIndexes[r];\r\n    }\r\n\r\n    while (this.varIndexByCol.length > this.width) {\r\n        this.varIndexByCol.pop();\r\n    }\r\n\r\n    var savedRows = save.rowByVarIndex;\r\n    var savedCols = save.colByVarIndex;\r\n    for (var v = 0; v < this.nVars; v += 1) {\r\n        this.rowByVarIndex[v] = savedRows[v];\r\n        this.colByVarIndex[v] = savedCols[v];\r\n    }\r\n\r\n\r\n    if (save.optionalObjectives.length > 0 && this.optionalObjectives.length > 0) {\r\n        this.optionalObjectives = [];\r\n        this.optionalObjectivePerPriority = {};\r\n        for(var o = 0; o < save.optionalObjectives.length; o++){\r\n            var optionalObjectiveCopy = save.optionalObjectives[o].copy();\r\n            this.optionalObjectives[o] = optionalObjectiveCopy;\r\n            this.optionalObjectivePerPriority[optionalObjectiveCopy.priority] = optionalObjectiveCopy;\r\n        }\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/Tableau/backup.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/Tableau/branchAndCut.js":
/*!***********************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/Tableau/branchAndCut.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/*global describe*/\r\n/*global require*/\r\n/*global module*/\r\n/*global it*/\r\n/*global console*/\r\n/*global process*/\r\nvar Tableau = __webpack_require__(/*! ./Tableau.js */ \"./node_modules/javascript-lp-solver/src/Tableau/Tableau.js\");\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nfunction Cut(type, varIndex, value) {\r\n    this.type = type;\r\n    this.varIndex = varIndex;\r\n    this.value = value;\r\n}\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nfunction Branch(relaxedEvaluation, cuts) {\r\n    this.relaxedEvaluation = relaxedEvaluation;\r\n    this.cuts = cuts;\r\n}\r\n\r\n//-------------------------------------------------------------------\r\n// Branch sorting strategies\r\n//-------------------------------------------------------------------\r\nfunction sortByEvaluation(a, b) {\r\n    return b.relaxedEvaluation - a.relaxedEvaluation;\r\n}\r\n\r\n\r\n//-------------------------------------------------------------------\r\n// Applying cuts on a tableau and resolving\r\n//-------------------------------------------------------------------\r\nTableau.prototype.applyCuts = function (branchingCuts){\r\n    // Restoring initial solution\r\n    this.restore();\r\n\r\n    this.addCutConstraints(branchingCuts);\r\n    this.simplex();\r\n    // Adding MIR cuts\r\n    if (this.model.useMIRCuts){\r\n        var fractionalVolumeImproved = true;\r\n        while(fractionalVolumeImproved){\r\n            var fractionalVolumeBefore = this.computeFractionalVolume(true);\r\n            this.applyMIRCuts();\r\n            this.simplex();\r\n\r\n            var fractionalVolumeAfter = this.computeFractionalVolume(true);\r\n\r\n            // If the new fractional volume is bigger than 90% of the previous one\r\n            // we assume there is no improvement from the MIR cuts\r\n            if(fractionalVolumeAfter >= 0.9 * fractionalVolumeBefore){\r\n                fractionalVolumeImproved = false;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n//-------------------------------------------------------------------\r\n// Function: MILP\r\n// Detail: Main function, my attempt at a mixed integer linear programming\r\n//         solver\r\n//-------------------------------------------------------------------\r\nTableau.prototype.branchAndCut = function () {\r\n    var branches = [];\r\n    var iterations = 0;\r\n    var tolerance = this.model.tolerance;\r\n    var toleranceFlag = true;\r\n    var terminalTime = 1e99;\r\n    \r\n    //\r\n    // Set Start Time on model...\r\n    // Let's build out a way to *gracefully* quit\r\n    // after {{time}} milliseconds\r\n    //\r\n    \r\n    // 1.) Check to see if there's a timeout on the model\r\n    //\r\n    if(this.model.timeout){\r\n        // 2.) Hooray! There is!\r\n        //     Calculate the final date\r\n        //\r\n        terminalTime = Date.now() + this.model.timeout;\r\n    }\r\n\r\n    // This is the default result\r\n    // If nothing is both *integral* and *feasible*\r\n    var bestEvaluation = Infinity;\r\n    var bestBranch = null;\r\n    var bestOptionalObjectivesEvaluations = [];\r\n    for (var oInit = 0; oInit < this.optionalObjectives.length; oInit += 1){\r\n        bestOptionalObjectivesEvaluations.push(Infinity);\r\n    }\r\n\r\n    // And here...we...go!\r\n\r\n    // 1.) Load a model into the queue\r\n    var branch = new Branch(-Infinity, []);\r\n    var acceptableThreshold;\r\n    \r\n    branches.push(branch);\r\n    // If all branches have been exhausted terminate the loop\r\n    while (branches.length > 0 && toleranceFlag === true && Date.now() < terminalTime) {\r\n        \r\n        if(this.model.isMinimization){\r\n            acceptableThreshold = this.bestPossibleEval * (1 + tolerance);\r\n        } else {\r\n            acceptableThreshold = this.bestPossibleEval * (1 - tolerance);\r\n        }\r\n        \r\n        // Abort while loop if termination tolerance is both specified and condition is met\r\n        if (tolerance > 0) {\r\n            if (bestEvaluation < acceptableThreshold) {\r\n                toleranceFlag = false;\r\n            }\r\n        }\r\n        \r\n        // Get a model from the queue\r\n        branch = branches.pop();\r\n        if (branch.relaxedEvaluation > bestEvaluation) {\r\n            continue;\r\n        }\r\n\r\n        // Solving from initial relaxed solution\r\n        // with additional cut constraints\r\n\r\n        // Adding cut constraints\r\n        var cuts = branch.cuts;\r\n        this.applyCuts(cuts);\r\n\r\n        iterations++;\r\n        if (this.feasible === false) {\r\n            continue;\r\n        }\r\n\r\n        var evaluation = this.evaluation;\r\n        if (evaluation > bestEvaluation) {\r\n            // This branch does not contain the optimal solution\r\n            continue;\r\n        }\r\n\r\n        // To deal with the optional objectives\r\n        if (evaluation === bestEvaluation){\r\n            var isCurrentEvaluationWorse = true;\r\n            for (var o = 0; o < this.optionalObjectives.length; o += 1){\r\n                if (this.optionalObjectives[o].reducedCosts[0] > bestOptionalObjectivesEvaluations[o]){\r\n                    break;\r\n                } else if (this.optionalObjectives[o].reducedCosts[0] < bestOptionalObjectivesEvaluations[o]) {\r\n                    isCurrentEvaluationWorse = false;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (isCurrentEvaluationWorse){\r\n                continue;\r\n            }\r\n        }\r\n\r\n        // Is the model both integral and feasible?\r\n        if (this.isIntegral() === true) {\r\n            \r\n            //\r\n            // Store the fact that we are integral\r\n            //\r\n            this.__isIntegral = true;\r\n            \r\n            \r\n            if (iterations === 1) {\r\n                this.branchAndCutIterations = iterations;\r\n                return;\r\n            }\r\n            // Store the solution as the bestSolution\r\n            bestBranch = branch;\r\n            bestEvaluation = evaluation;\r\n            for (var oCopy = 0; oCopy < this.optionalObjectives.length; oCopy += 1){\r\n                bestOptionalObjectivesEvaluations[oCopy] = this.optionalObjectives[oCopy].reducedCosts[0];\r\n            }\r\n        } else {\r\n            if (iterations === 1) {\r\n                // Saving the first iteration\r\n                // TODO: implement a better strategy for saving the tableau?\r\n                this.save();\r\n            }\r\n\r\n            // If the solution is\r\n            //  a. Feasible\r\n            //  b. Better than the current solution\r\n            //  c. but *NOT* integral\r\n\r\n            // So the solution isn't integral? How do we solve this.\r\n            // We create 2 new models, that are mirror images of the prior\r\n            // model, with 1 exception.\r\n\r\n            // Say we're trying to solve some stupid problem requiring you get\r\n            // animals for your daughter's kindergarten petting zoo party\r\n            // and you have to choose how many ducks, goats, and lambs to get.\r\n\r\n            // Say that the optimal solution to this problem if we didn't have\r\n            // to make it integral was {duck: 8, lambs: 3.5}\r\n            //\r\n            // To keep from traumatizing your daughter and the other children\r\n            // you're going to want to have whole animals\r\n\r\n            // What we would do is find the most fractional variable (lambs)\r\n            // and create new models from the old models, but with a new constraint\r\n            // on apples. The constraints on the low model would look like:\r\n            // constraints: {...\r\n            //   lamb: {max: 3}\r\n            //   ...\r\n            // }\r\n            //\r\n            // while the constraints on the high model would look like:\r\n            //\r\n            // constraints: {...\r\n            //   lamb: {min: 4}\r\n            //   ...\r\n            // }\r\n            // If neither of these models is feasible because of this constraint,\r\n            // the model is not integral at this point, and fails.\r\n\r\n            // Find out where we want to split the solution\r\n            var variable = this.getMostFractionalVar();\r\n\r\n            var varIndex = variable.index;\r\n\r\n            var cutsHigh = [];\r\n            var cutsLow = [];\r\n\r\n            var nCuts = cuts.length;\r\n            for (var c = 0; c < nCuts; c += 1) {\r\n                var cut = cuts[c];\r\n                if (cut.varIndex === varIndex) {\r\n                    if (cut.type === \"min\") {\r\n                        cutsLow.push(cut);\r\n                    } else {\r\n                        cutsHigh.push(cut);\r\n                    }\r\n                } else {\r\n                    cutsHigh.push(cut);\r\n                    cutsLow.push(cut);\r\n                }\r\n            }\r\n\r\n            var min = Math.ceil(variable.value);\r\n            var max = Math.floor(variable.value);\r\n\r\n            var cutHigh = new Cut(\"min\", varIndex, min);\r\n            cutsHigh.push(cutHigh);\r\n\r\n            var cutLow = new Cut(\"max\", varIndex, max);\r\n            cutsLow.push(cutLow);\r\n\r\n            branches.push(new Branch(evaluation, cutsHigh));\r\n            branches.push(new Branch(evaluation, cutsLow));\r\n\r\n            // Sorting branches\r\n            // Branches with the most promising lower bounds\r\n            // will be picked first\r\n            branches.sort(sortByEvaluation);\r\n        }\r\n    }\r\n\r\n    // Adding cut constraints for the optimal solution\r\n    if (bestBranch !== null) {\r\n        // The model is feasible\r\n        this.applyCuts(bestBranch.cuts);\r\n    }\r\n    this.branchAndCutIterations = iterations;\r\n};\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/Tableau/branchAndCut.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/Tableau/branchingStrategies.js":
/*!******************************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/Tableau/branchingStrategies.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/*global require*/\r\nvar Tableau = __webpack_require__(/*! ./Tableau.js */ \"./node_modules/javascript-lp-solver/src/Tableau/Tableau.js\");\r\n\r\nfunction VariableData(index, value) {\r\n    this.index = index;\r\n    this.value = value;\r\n}\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nTableau.prototype.getMostFractionalVar = function () {\r\n    var biggestFraction = 0;\r\n    var selectedVarIndex = null;\r\n    var selectedVarValue = null;\r\n    var mid = 0.5;\r\n\r\n    var integerVariables = this.model.integerVariables;\r\n    var nIntegerVars = integerVariables.length;\r\n    for (var v = 0; v < nIntegerVars; v++) {\r\n        var varIndex = integerVariables[v].index;\r\n        var varRow = this.rowByVarIndex[varIndex];\r\n        if (varRow === -1) {\r\n            continue;\r\n        }\r\n\r\n        var varValue = this.matrix[varRow][this.rhsColumn];\r\n        var fraction = Math.abs(varValue - Math.round(varValue));\r\n        if (biggestFraction < fraction) {\r\n            biggestFraction = fraction;\r\n            selectedVarIndex = varIndex;\r\n            selectedVarValue = varValue;\r\n        }\r\n    }\r\n\r\n    return new VariableData(selectedVarIndex, selectedVarValue);\r\n};\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nTableau.prototype.getFractionalVarWithLowestCost = function () {\r\n    var highestCost = Infinity;\r\n    var selectedVarIndex = null;\r\n    var selectedVarValue = null;\r\n\r\n    var integerVariables = this.model.integerVariables;\r\n    var nIntegerVars = integerVariables.length;\r\n    for (var v = 0; v < nIntegerVars; v++) {\r\n        var variable = integerVariables[v];\r\n        var varIndex = variable.index;\r\n        var varRow = this.rowByVarIndex[varIndex];\r\n        if (varRow === -1) {\r\n            // Variable value is non basic\r\n            // its value is 0\r\n            continue;\r\n        }\r\n\r\n        var varValue = this.matrix[varRow][this.rhsColumn];\r\n        if (Math.abs(varValue - Math.round(varValue)) > this.precision) {\r\n            var cost = variable.cost;\r\n            if (highestCost > cost) {\r\n                highestCost = cost;\r\n                selectedVarIndex = varIndex;\r\n                selectedVarValue = varValue;\r\n            }\r\n        }\r\n    }\r\n\r\n    return new VariableData(selectedVarIndex, selectedVarValue);\r\n};\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/Tableau/branchingStrategies.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/Tableau/cuttingStrategies.js":
/*!****************************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/Tableau/cuttingStrategies.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/*global require*/\r\nvar Tableau = __webpack_require__(/*! ./Tableau.js */ \"./node_modules/javascript-lp-solver/src/Tableau/Tableau.js\");\r\nvar SlackVariable = (__webpack_require__(/*! ../expressions.js */ \"./node_modules/javascript-lp-solver/src/expressions.js\").SlackVariable);\r\n\r\nTableau.prototype.addCutConstraints = function (cutConstraints) {\r\n    var nCutConstraints = cutConstraints.length;\r\n\r\n    var height = this.height;\r\n    var heightWithCuts = height + nCutConstraints;\r\n\r\n    // Adding rows to hold cut constraints\r\n    for (var h = height; h < heightWithCuts; h += 1) {\r\n        if (this.matrix[h] === undefined) {\r\n            this.matrix[h] = this.matrix[h - 1].slice();\r\n        }\r\n    }\r\n\r\n    // Adding cut constraints\r\n    this.height = heightWithCuts;\r\n    this.nVars = this.width + this.height - 2;\r\n\r\n    var c;\r\n    var lastColumn = this.width - 1;\r\n    for (var i = 0; i < nCutConstraints; i += 1) {\r\n        var cut = cutConstraints[i];\r\n\r\n        // Constraint row index\r\n        var r = height + i;\r\n\r\n        var sign = (cut.type === \"min\") ? -1 : 1;\r\n\r\n        // Variable on which the cut is applied\r\n        var varIndex = cut.varIndex;\r\n        var varRowIndex = this.rowByVarIndex[varIndex];\r\n        var constraintRow = this.matrix[r];\r\n        if (varRowIndex === -1) {\r\n            // Variable is non basic\r\n            constraintRow[this.rhsColumn] = sign * cut.value;\r\n            for (c = 1; c <= lastColumn; c += 1) {\r\n                constraintRow[c] = 0;\r\n            }\r\n            constraintRow[this.colByVarIndex[varIndex]] = sign;\r\n        } else {\r\n            // Variable is basic\r\n            var varRow = this.matrix[varRowIndex];\r\n            var varValue = varRow[this.rhsColumn];\r\n            constraintRow[this.rhsColumn] = sign * (cut.value - varValue);\r\n            for (c = 1; c <= lastColumn; c += 1) {\r\n                constraintRow[c] = -sign * varRow[c];\r\n            }\r\n        }\r\n\r\n        // Creating slack variable\r\n        var slackVarIndex = this.getNewElementIndex();\r\n        this.varIndexByRow[r] = slackVarIndex;\r\n        this.rowByVarIndex[slackVarIndex] = r;\r\n        this.colByVarIndex[slackVarIndex] = -1;\r\n        this.variablesPerIndex[slackVarIndex] = new SlackVariable(\"s\"+slackVarIndex, slackVarIndex);\r\n        this.nVars += 1;\r\n    }\r\n};\r\n\r\nTableau.prototype._addLowerBoundMIRCut = function(rowIndex) {\r\n\r\n\tif(rowIndex === this.costRowIndex) {\r\n\t\t//console.log(\"! IN MIR CUTS : The index of the row corresponds to the cost row. !\");\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar model = this.model;\r\n\tvar matrix = this.matrix;\r\n\r\n\tvar intVar = this.variablesPerIndex[this.varIndexByRow[rowIndex]];\r\n\tif (!intVar.isInteger) {\r\n\t\treturn false;\r\n    }\r\n\r\n\tvar d = matrix[rowIndex][this.rhsColumn];\r\n\tvar frac_d = d - Math.floor(d);\r\n\r\n\tif (frac_d < this.precision || 1 - this.precision < frac_d) {\r\n\t\treturn false;\r\n    }\r\n\r\n\t//Adding a row\r\n\tvar r = this.height;\r\n\tmatrix[r] = matrix[r - 1].slice();\r\n\tthis.height += 1;\r\n\r\n\t// Creating slack variable\r\n\tthis.nVars += 1;\r\n\tvar slackVarIndex = this.getNewElementIndex();\r\n\tthis.varIndexByRow[r] = slackVarIndex;\r\n\tthis.rowByVarIndex[slackVarIndex] = r;\r\n\tthis.colByVarIndex[slackVarIndex] = -1;\r\n\tthis.variablesPerIndex[slackVarIndex] = new SlackVariable(\"s\"+slackVarIndex, slackVarIndex);\r\n\r\n\tmatrix[r][this.rhsColumn] = Math.floor(d);\r\n\r\n\tfor (var colIndex = 1; colIndex < this.varIndexByCol.length; colIndex += 1) {\r\n\t\tvar variable = this.variablesPerIndex[this.varIndexByCol[colIndex]];\r\n\r\n\t\tif (!variable.isInteger) {\r\n\t\t\tmatrix[r][colIndex] = Math.min(0, matrix[rowIndex][colIndex] / (1 - frac_d));\r\n\t\t} else {\r\n\t\t\tvar coef = matrix[rowIndex][colIndex];\r\n\t\t\tvar termCoeff = Math.floor(coef)+Math.max(0, coef - Math.floor(coef) - frac_d) / (1 - frac_d);\r\n\t\t\tmatrix[r][colIndex] = termCoeff;\r\n\t\t}\r\n\t}\r\n\r\n\tfor(var c = 0; c < this.width; c += 1) {\r\n\t\tmatrix[r][c] -= matrix[rowIndex][c];\r\n\t}\r\n\r\n\treturn true;\r\n};\r\n\r\nTableau.prototype._addUpperBoundMIRCut = function(rowIndex) {\r\n\r\n\tif (rowIndex === this.costRowIndex) {\r\n\t\t//console.log(\"! IN MIR CUTS : The index of the row corresponds to the cost row. !\");\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar model = this.model;\r\n\tvar matrix = this.matrix;\r\n\r\n\tvar intVar = this.variablesPerIndex[this.varIndexByRow[rowIndex]];\r\n\tif (!intVar.isInteger) {\r\n\t\treturn false;\r\n    }\r\n\r\n\tvar b = matrix[rowIndex][this.rhsColumn];\r\n\tvar f = b - Math.floor(b);\r\n\r\n\tif (f < this.precision || 1 - this.precision < f) {\r\n\t\treturn false;\r\n    }\r\n\r\n\t//Adding a row\r\n\tvar r = this.height;\r\n\tmatrix[r] = matrix[r - 1].slice();\r\n\tthis.height += 1;\r\n\r\n\t// Creating slack variable\r\n    \r\n\tthis.nVars += 1;\r\n\tvar slackVarIndex = this.getNewElementIndex();\r\n\tthis.varIndexByRow[r] = slackVarIndex;\r\n\tthis.rowByVarIndex[slackVarIndex] = r;\r\n\tthis.colByVarIndex[slackVarIndex] = -1;\r\n\tthis.variablesPerIndex[slackVarIndex] = new SlackVariable(\"s\"+slackVarIndex, slackVarIndex);\r\n\r\n\tmatrix[r][this.rhsColumn] = -f;\r\n\r\n\r\n\tfor(var colIndex = 1; colIndex < this.varIndexByCol.length; colIndex += 1) {\r\n\t\tvar variable = this.variablesPerIndex[this.varIndexByCol[colIndex]];\r\n\r\n\t\tvar aj = matrix[rowIndex][colIndex];\r\n\t\tvar fj = aj - Math.floor(aj);\r\n\r\n\t\tif(variable.isInteger) {\r\n\t\t\tif(fj <= f) {\r\n\t\t\t\tmatrix[r][colIndex] = -fj;\r\n            } else {\r\n\t\t\t\tmatrix[r][colIndex] = -(1 - fj) * f / fj;\r\n            }\r\n\t\t} else {\r\n\t\t\tif (aj >= 0) {\r\n\t\t\t\tmatrix[r][colIndex] = -aj;\r\n            } else {\r\n\t\t\t\tmatrix[r][colIndex] = aj * f / (1 - f);\r\n            }\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n};\r\n\r\n\r\n//\r\n// THIS MAKES SOME MILP PROBLEMS PROVIDE INCORRECT\r\n// ANSWERS...\r\n//\r\n// QUICK FIX: MAKE THE FUNCTION EMPTY...\r\n//\r\nTableau.prototype.applyMIRCuts = function () {\r\n    \r\n    // var nRows = this.height;\r\n    // for (var cst = 0; cst < nRows; cst += 1) {\r\n    //    this._addUpperBoundMIRCut(cst);\r\n    // }\r\n\r\n\r\n    // // nRows = tableau.height;\r\n    // for (cst = 0; cst < nRows; cst += 1) {\r\n    //    this._addLowerBoundMIRCut(cst);\r\n    // }\r\n    \r\n};\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/Tableau/cuttingStrategies.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/Tableau/dynamicModification.js":
/*!******************************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/Tableau/dynamicModification.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/*global require*/\r\n/*global console*/\r\nvar Tableau = __webpack_require__(/*! ./Tableau.js */ \"./node_modules/javascript-lp-solver/src/Tableau/Tableau.js\");\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nTableau.prototype._putInBase = function (varIndex) {\r\n    // Is varIndex in the base?\r\n    var r = this.rowByVarIndex[varIndex];\r\n    if (r === -1) {\r\n        // Outside the base\r\n        // pivoting to take it out\r\n        var c = this.colByVarIndex[varIndex];\r\n\r\n        // Selecting pivot row\r\n        // (Any row with coefficient different from 0)\r\n        for (var r1 = 1; r1 < this.height; r1 += 1) {\r\n            var coefficient = this.matrix[r1][c];\r\n            if (coefficient < -this.precision || this.precision < coefficient) {\r\n                r = r1;\r\n                break;\r\n            }\r\n        }\r\n\r\n        this.pivot(r, c);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\nTableau.prototype._takeOutOfBase = function (varIndex) {\r\n    // Is varIndex in the base?\r\n    var c = this.colByVarIndex[varIndex];\r\n    if (c === -1) {\r\n        // Inside the base\r\n        // pivoting to take it out\r\n        var r = this.rowByVarIndex[varIndex];\r\n\r\n        // Selecting pivot column\r\n        // (Any column with coefficient different from 0)\r\n        var pivotRow = this.matrix[r];\r\n        for (var c1 = 1; c1 < this.height; c1 += 1) {\r\n            var coefficient = pivotRow[c1];\r\n            if (coefficient < -this.precision || this.precision < coefficient) {\r\n                c = c1;\r\n                break;\r\n            }\r\n        }\r\n\r\n        this.pivot(r, c);\r\n    }\r\n\r\n    return c;\r\n};\r\n\r\nTableau.prototype.updateVariableValues = function () {\r\n    var nVars = this.variables.length;\r\n    var roundingCoeff = Math.round(1 / this.precision);\r\n    for (var v = 0; v < nVars; v += 1) {\r\n        var variable = this.variables[v];\r\n        var varIndex = variable.index;\r\n\r\n        var r = this.rowByVarIndex[varIndex];\r\n        if (r === -1) {\r\n            // Variable is non basic\r\n            variable.value = 0;\r\n        } else {\r\n            // Variable is basic\r\n            var varValue = this.matrix[r][this.rhsColumn];\r\n            variable.value = Math.round((varValue + Number.EPSILON) * roundingCoeff) / roundingCoeff;\r\n        }\r\n    }\r\n};\r\n\r\nTableau.prototype.updateRightHandSide = function (constraint, difference) {\r\n    // Updates RHS of given constraint\r\n    var lastRow = this.height - 1;\r\n    var constraintRow = this.rowByVarIndex[constraint.index];\r\n    if (constraintRow === -1) {\r\n        // Slack is not in base\r\n        var slackColumn = this.colByVarIndex[constraint.index];\r\n\r\n        // Upading all the RHS values\r\n        for (var r = 0; r <= lastRow; r += 1) {\r\n            var row = this.matrix[r];\r\n            row[this.rhsColumn] -= difference * row[slackColumn];\r\n        }\r\n\r\n        var nOptionalObjectives = this.optionalObjectives.length;\r\n        if (nOptionalObjectives > 0) {\r\n            for (var o = 0; o < nOptionalObjectives; o += 1) {\r\n                var reducedCosts = this.optionalObjectives[o].reducedCosts;\r\n                reducedCosts[this.rhsColumn] -= difference * reducedCosts[slackColumn];\r\n            }\r\n        }\r\n    } else {\r\n        // Slack variable of constraint is in base\r\n        // Updating RHS with the difference between the old and the new one\r\n        this.matrix[constraintRow][this.rhsColumn] -= difference;\r\n    }\r\n};\r\n\r\nTableau.prototype.updateConstraintCoefficient = function (constraint, variable, difference) {\r\n    // Updates variable coefficient within a constraint\r\n    if (constraint.index === variable.index) {\r\n        throw new Error(\"[Tableau.updateConstraintCoefficient] constraint index should not be equal to variable index !\");\r\n    }\r\n\r\n    var r = this._putInBase(constraint.index);\r\n\r\n    var colVar = this.colByVarIndex[variable.index];\r\n    if (colVar === -1) {\r\n        var rowVar = this.rowByVarIndex[variable.index];\r\n        for (var c = 0; c < this.width; c += 1){\r\n            this.matrix[r][c] += difference * this.matrix[rowVar][c];\r\n        }\r\n    } else {\r\n        this.matrix[r][colVar] -= difference;\r\n    }\r\n};\r\n\r\nTableau.prototype.updateCost = function (variable, difference) {\r\n    // Updates variable coefficient within the objective function\r\n    var varIndex = variable.index;\r\n    var lastColumn = this.width - 1;\r\n    var varColumn = this.colByVarIndex[varIndex];\r\n    if (varColumn === -1) {\r\n        // Variable is in base\r\n        var variableRow = this.matrix[this.rowByVarIndex[varIndex]];\r\n\r\n        var c;\r\n        if (variable.priority === 0) {\r\n            var costRow = this.matrix[0];\r\n\r\n            // Upading all the reduced costs\r\n            for (c = 0; c <= lastColumn; c += 1) {\r\n                costRow[c] += difference * variableRow[c];\r\n            }\r\n        } else {\r\n            var reducedCosts = this.objectivesByPriority[variable.priority].reducedCosts;\r\n            for (c = 0; c <= lastColumn; c += 1) {\r\n                reducedCosts[c] += difference * variableRow[c];\r\n            }\r\n        }\r\n    } else {\r\n        // Variable is not in the base\r\n        // Updating coefficient with difference\r\n        this.matrix[0][varColumn] -= difference;\r\n    }\r\n};\r\n\r\nTableau.prototype.addConstraint = function (constraint) {\r\n    // Adds a constraint to the tableau\r\n    var sign = constraint.isUpperBound ? 1 : -1;\r\n    var lastRow = this.height;\r\n\r\n    var constraintRow = this.matrix[lastRow];\r\n    if (constraintRow === undefined) {\r\n        constraintRow = this.matrix[0].slice();\r\n        this.matrix[lastRow] = constraintRow;\r\n    }\r\n\r\n    // Setting all row cells to 0\r\n    var lastColumn = this.width - 1;\r\n    for (var c = 0; c <= lastColumn; c += 1) {\r\n        constraintRow[c] = 0;\r\n    }\r\n\r\n    // Initializing RHS\r\n    constraintRow[this.rhsColumn] = sign * constraint.rhs;\r\n\r\n    var terms = constraint.terms;\r\n    var nTerms = terms.length;\r\n    for (var t = 0; t < nTerms; t += 1) {\r\n        var term = terms[t];\r\n        var coefficient = term.coefficient;\r\n        var varIndex = term.variable.index;\r\n\r\n        var varRowIndex = this.rowByVarIndex[varIndex];\r\n        if (varRowIndex === -1) {\r\n            // Variable is non basic\r\n            constraintRow[this.colByVarIndex[varIndex]] += sign * coefficient;\r\n        } else {\r\n            // Variable is basic\r\n            var varRow = this.matrix[varRowIndex];\r\n            var varValue = varRow[this.rhsColumn];\r\n            for (c = 0; c <= lastColumn; c += 1) {\r\n                constraintRow[c] -= sign * coefficient * varRow[c];\r\n            }\r\n        }\r\n    }\r\n    // Creating slack variable\r\n    var slackIndex = constraint.index;\r\n    this.varIndexByRow[lastRow] = slackIndex;\r\n    this.rowByVarIndex[slackIndex] = lastRow;\r\n    this.colByVarIndex[slackIndex] = -1;\r\n\r\n    this.height += 1;\r\n};\r\n\r\nTableau.prototype.removeConstraint = function (constraint) {\r\n    var slackIndex = constraint.index;\r\n    var lastRow = this.height - 1;\r\n\r\n    // Putting the constraint's slack in the base\r\n    var r = this._putInBase(slackIndex);\r\n\r\n    // Removing constraint\r\n    // by putting the corresponding row at the bottom of the matrix\r\n    // and virtually reducing the height of the matrix by 1\r\n    var tmpRow = this.matrix[lastRow];\r\n    this.matrix[lastRow] = this.matrix[r];\r\n    this.matrix[r] = tmpRow;\r\n\r\n    // Removing associated slack variable from basic variables\r\n    this.varIndexByRow[r] = this.varIndexByRow[lastRow];\r\n    this.varIndexByRow[lastRow] = -1;\r\n    this.rowByVarIndex[slackIndex] = -1;\r\n\r\n    // Putting associated slack variable index in index manager\r\n    this.availableIndexes[this.availableIndexes.length] = slackIndex;\r\n\r\n    constraint.slack.index = -1;\r\n\r\n    this.height -= 1;\r\n};\r\n\r\nTableau.prototype.addVariable = function (variable) {\r\n    // Adds a variable to the tableau\r\n    // var sign = constraint.isUpperBound ? 1 : -1;\r\n\r\n    var lastRow = this.height - 1;\r\n    var lastColumn = this.width;\r\n    var cost = this.model.isMinimization === true ? -variable.cost : variable.cost;\r\n    var priority = variable.priority;\r\n\r\n    // Setting reduced costs\r\n    var nOptionalObjectives = this.optionalObjectives.length;\r\n    if (nOptionalObjectives > 0) {\r\n        for (var o = 0; o < nOptionalObjectives; o += 1) {\r\n            this.optionalObjectives[o].reducedCosts[lastColumn] = 0;\r\n        }\r\n    }\r\n\r\n    if (priority === 0) {\r\n        this.matrix[0][lastColumn] = cost;\r\n    } else {\r\n        this.setOptionalObjective(priority, lastColumn, cost);\r\n        this.matrix[0][lastColumn] = 0;\r\n    }\r\n\r\n    // Setting all other column cells to 0\r\n    for (var r = 1; r <= lastRow; r += 1) {\r\n        this.matrix[r][lastColumn] = 0;\r\n    }\r\n\r\n    // Adding variable to trackers\r\n    var varIndex = variable.index;\r\n    this.varIndexByCol[lastColumn] = varIndex;\r\n\r\n    this.rowByVarIndex[varIndex] = -1;\r\n    this.colByVarIndex[varIndex] = lastColumn;\r\n\r\n    this.width += 1;\r\n};\r\n\r\n\r\nTableau.prototype.removeVariable = function (variable) {\r\n    var varIndex = variable.index;\r\n\r\n    // Putting the variable out of the base\r\n    var c = this._takeOutOfBase(varIndex);\r\n    var lastColumn = this.width - 1;\r\n    if (c !== lastColumn) {\r\n        var lastRow = this.height - 1;\r\n        for (var r = 0; r <= lastRow; r += 1) {\r\n            var row = this.matrix[r];\r\n            row[c] = row[lastColumn];\r\n        }\r\n\r\n        var nOptionalObjectives = this.optionalObjectives.length;\r\n        if (nOptionalObjectives > 0) {\r\n            for (var o = 0; o < nOptionalObjectives; o += 1) {\r\n                var reducedCosts = this.optionalObjectives[o].reducedCosts;\r\n                reducedCosts[c] = reducedCosts[lastColumn];\r\n            }\r\n        }\r\n\r\n        var switchVarIndex = this.varIndexByCol[lastColumn];\r\n        this.varIndexByCol[c] = switchVarIndex;\r\n        this.colByVarIndex[switchVarIndex] = c;\r\n    }\r\n\r\n    // Removing variable from non basic variables\r\n    this.varIndexByCol[lastColumn] = -1;\r\n    this.colByVarIndex[varIndex] = -1;\r\n\r\n    // Adding index into index manager\r\n    this.availableIndexes[this.availableIndexes.length] = varIndex;\r\n\r\n    variable.index = -1;\r\n\r\n    this.width -= 1;\r\n};\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/Tableau/dynamicModification.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/Tableau/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/Tableau/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*global require*/\r\n/*global module*/\r\n__webpack_require__(/*! ./simplex.js */ \"./node_modules/javascript-lp-solver/src/Tableau/simplex.js\");\r\n__webpack_require__(/*! ./cuttingStrategies.js */ \"./node_modules/javascript-lp-solver/src/Tableau/cuttingStrategies.js\");\r\n__webpack_require__(/*! ./dynamicModification.js */ \"./node_modules/javascript-lp-solver/src/Tableau/dynamicModification.js\");\r\n__webpack_require__(/*! ./log.js */ \"./node_modules/javascript-lp-solver/src/Tableau/log.js\");\r\n__webpack_require__(/*! ./backup.js */ \"./node_modules/javascript-lp-solver/src/Tableau/backup.js\");\r\n__webpack_require__(/*! ./branchingStrategies.js */ \"./node_modules/javascript-lp-solver/src/Tableau/branchingStrategies.js\");\r\n__webpack_require__(/*! ./integerProperties.js */ \"./node_modules/javascript-lp-solver/src/Tableau/integerProperties.js\");\r\n\r\nmodule.exports = __webpack_require__(/*! ./Tableau.js */ \"./node_modules/javascript-lp-solver/src/Tableau/Tableau.js\");\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/Tableau/index.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/Tableau/integerProperties.js":
/*!****************************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/Tableau/integerProperties.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/*global require*/\r\nvar Tableau = __webpack_require__(/*! ./Tableau.js */ \"./node_modules/javascript-lp-solver/src/Tableau/Tableau.js\");\r\n\r\nTableau.prototype.countIntegerValues = function(){\r\n    var count = 0;\r\n    for (var r = 1; r < this.height; r += 1) {\r\n        if (this.variablesPerIndex[this.varIndexByRow[r]].isInteger) {\r\n            var decimalPart = this.matrix[r][this.rhsColumn];\r\n            decimalPart = decimalPart - Math.floor(decimalPart);\r\n            if (decimalPart < this.precision && -decimalPart < this.precision) {\r\n                count += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    return count;\r\n};\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nTableau.prototype.isIntegral = function () {\r\n    var integerVariables = this.model.integerVariables;\r\n    var nIntegerVars = integerVariables.length;\r\n    for (var v = 0; v < nIntegerVars; v++) {\r\n        var varRow = this.rowByVarIndex[integerVariables[v].index];\r\n        if (varRow === -1) {\r\n            continue;\r\n        }\r\n\r\n        var varValue = this.matrix[varRow][this.rhsColumn];\r\n        if (Math.abs(varValue - Math.round(varValue)) > this.precision) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\n// Multiply all the fractional parts of variables supposed to be integer\r\nTableau.prototype.computeFractionalVolume = function(ignoreIntegerValues) {\r\n    var volume = -1;\r\n    // var integerVariables = this.model.integerVariables;\r\n    // var nIntegerVars = integerVariables.length;\r\n    // for (var v = 0; v < nIntegerVars; v++) {\r\n    //     var r = this.rowByVarIndex[integerVariables[v].index];\r\n    //     if (r === -1) {\r\n    //         continue;\r\n    //     }\r\n    //     var rhs = this.matrix[r][this.rhsColumn];\r\n    //     rhs = Math.abs(rhs);\r\n    //     var decimalPart = Math.min(rhs - Math.floor(rhs), Math.floor(rhs + 1));\r\n    //     if (decimalPart < this.precision) {\r\n    //         if (!ignoreIntegerValues) {\r\n    //             return 0;\r\n    //         }\r\n    //     } else {\r\n    //         if (volume === -1) {\r\n    //             volume = rhs;\r\n    //         } else {\r\n    //             volume *= rhs;\r\n    //         }\r\n    //     }\r\n    // }\r\n\r\n    for (var r = 1; r < this.height; r += 1) {\r\n        if (this.variablesPerIndex[this.varIndexByRow[r]].isInteger) {\r\n            var rhs = this.matrix[r][this.rhsColumn];\r\n            rhs = Math.abs(rhs);\r\n            var decimalPart = Math.min(rhs - Math.floor(rhs), Math.floor(rhs + 1));\r\n            if (decimalPart < this.precision) {\r\n                if (!ignoreIntegerValues) {\r\n                    return 0;\r\n                }\r\n            } else {\r\n                if (volume === -1) {\r\n                    volume = rhs;\r\n                } else {\r\n                    volume *= rhs;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (volume === -1){\r\n        return 0;\r\n    }\r\n    return volume;\r\n};\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/Tableau/integerProperties.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/Tableau/log.js":
/*!**************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/Tableau/log.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/*global require*/\r\n/*global console*/\r\nvar Tableau = __webpack_require__(/*! ./Tableau.js */ \"./node_modules/javascript-lp-solver/src/Tableau/Tableau.js\");\r\n\r\n//-------------------------------------------------------------------\r\n// Description: Display a tableau matrix\r\n//              and additional tableau information\r\n//\r\n//-------------------------------------------------------------------\r\nTableau.prototype.log = function (message, force) {\r\n    if (false) // removed by dead control flow\n{}\r\n\r\n    console.log(\"****\", message, \"****\");\r\n    console.log(\"Nb Variables\", this.width - 1);\r\n    console.log(\"Nb Constraints\", this.height - 1);\r\n    // console.log(\"Variable Ids\", this.variablesPerIndex);\r\n    console.log(\"Basic Indexes\", this.varIndexByRow);\r\n    console.log(\"Non Basic Indexes\", this.varIndexByCol);\r\n    console.log(\"Rows\", this.rowByVarIndex);\r\n    console.log(\"Cols\", this.colByVarIndex);\r\n\r\n    var digitPrecision = 5;\r\n\r\n    // Variable declaration\r\n    var varNameRowString = \"\",\r\n        spacePerColumn = [\" \"],\r\n        j,\r\n        c,\r\n        s,\r\n        r,\r\n        variable,\r\n        varIndex,\r\n        varName,\r\n        varNameLength,\r\n        nSpaces,\r\n        valueSpace,\r\n        nameSpace;\r\n\r\n    var row,\r\n        rowString;\r\n\r\n    for (c = 1; c < this.width; c += 1) {\r\n        varIndex = this.varIndexByCol[c];\r\n        variable = this.variablesPerIndex[varIndex];\r\n        if (variable === undefined) {\r\n            varName = \"c\" + varIndex;\r\n        } else {\r\n            varName = variable.id;\r\n        }\r\n\r\n        varNameLength = varName.length;\r\n        nSpaces = Math.abs(varNameLength - 5);\r\n        valueSpace = \" \";\r\n        nameSpace = \"\\t\";\r\n\r\n        ///////////\r\n        /*valueSpace = \" \";\r\n        nameSpace = \" \";\r\n\r\n        for (s = 0; s < nSpaces; s += 1) {\r\n            if (varNameLength > 5) {\r\n                valueSpace += \" \";\r\n            } else {\r\n                nameSpace += \" \";\r\n            }\r\n        }*/\r\n\r\n        ///////////\r\n        if (varNameLength > 5) {\r\n            valueSpace += \" \";\r\n        } else {\r\n            nameSpace += \"\\t\";\r\n        }\r\n\r\n        spacePerColumn[c] = valueSpace;\r\n\r\n        varNameRowString += nameSpace + varName;\r\n    }\r\n    console.log(varNameRowString);\r\n\r\n    var signSpace;\r\n\r\n    // Displaying reduced costs\r\n    var firstRow = this.matrix[this.costRowIndex];\r\n    var firstRowString = \"\\t\";\r\n\r\n    ///////////\r\n    /*for (j = 1; j < this.width; j += 1) {\r\n        signSpace = firstRow[j] < 0 ? \"\" : \" \";\r\n        firstRowString += signSpace;\r\n        firstRowString += spacePerColumn[j];\r\n        firstRowString += firstRow[j].toFixed(2);\r\n    }\r\n    signSpace = firstRow[0] < 0 ? \"\" : \" \";\r\n    firstRowString += signSpace + spacePerColumn[0] +\r\n        firstRow[0].toFixed(2);\r\n    console.log(firstRowString + \" Z\");*/\r\n\r\n    ///////////\r\n    for (j = 1; j < this.width; j += 1) {\r\n        signSpace = \"\\t\";\r\n        firstRowString += signSpace;\r\n        firstRowString += spacePerColumn[j];\r\n        firstRowString += firstRow[j].toFixed(digitPrecision);\r\n    }\r\n    signSpace = \"\\t\";\r\n    firstRowString += signSpace + spacePerColumn[0] +\r\n        firstRow[0].toFixed(digitPrecision);\r\n    console.log(firstRowString + \"\\tZ\");\r\n\r\n\r\n    // Then the basic variable rowByVarIndex\r\n    for (r = 1; r < this.height; r += 1) {\r\n        row = this.matrix[r];\r\n        rowString = \"\\t\";\r\n\r\n        ///////////\r\n        /*for (c = 1; c < this.width; c += 1) {\r\n            signSpace = row[c] < 0 ? \"\" : \" \";\r\n            rowString += signSpace + spacePerColumn[c] + row[c].toFixed(2);\r\n        }\r\n        signSpace = row[0] < 0 ? \"\" : \" \";\r\n        rowString += signSpace + spacePerColumn[0] + row[0].toFixed(2);*/\r\n\r\n        ///////////\r\n        for (c = 1; c < this.width; c += 1) {\r\n            signSpace = \"\\t\";\r\n            rowString += signSpace + spacePerColumn[c] + row[c].toFixed(digitPrecision);\r\n        }\r\n        signSpace = \"\\t\";\r\n        rowString += signSpace + spacePerColumn[0] + row[0].toFixed(digitPrecision);\r\n\r\n\r\n        varIndex = this.varIndexByRow[r];\r\n        variable = this.variablesPerIndex[varIndex];\r\n        if (variable === undefined) {\r\n            varName = \"c\" + varIndex;\r\n        } else {\r\n            varName = variable.id;\r\n        }\r\n        console.log(rowString + \"\\t\" + varName);\r\n    }\r\n    console.log(\"\");\r\n\r\n    // Then reduced costs for optional objectives\r\n    var nOptionalObjectives = this.optionalObjectives.length;\r\n    if (nOptionalObjectives > 0) {\r\n        console.log(\"    Optional objectives:\");\r\n        for (var o = 0; o < nOptionalObjectives; o += 1) {\r\n            var reducedCosts = this.optionalObjectives[o].reducedCosts;\r\n            var reducedCostsString = \"\";\r\n            for (j = 1; j < this.width; j += 1) {\r\n                signSpace = reducedCosts[j] < 0 ? \"\" : \" \";\r\n                reducedCostsString += signSpace;\r\n                reducedCostsString += spacePerColumn[j];\r\n                reducedCostsString += reducedCosts[j].toFixed(digitPrecision);\r\n            }\r\n            signSpace = reducedCosts[0] < 0 ? \"\" : \" \";\r\n            reducedCostsString += signSpace + spacePerColumn[0] +\r\n                reducedCosts[0].toFixed(digitPrecision);\r\n            console.log(reducedCostsString + \" z\" + o);\r\n        }\r\n    }\r\n    console.log(\"Feasible?\", this.feasible);\r\n    console.log(\"evaluation\", this.evaluation);\r\n\r\n    return this;\r\n};\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/Tableau/log.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/Tableau/simplex.js":
/*!******************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/Tableau/simplex.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/*global describe*/\r\n/*global require*/\r\n/*global module*/\r\n/*global it*/\r\n/*global console*/\r\n/*global process*/\r\n\r\nvar Tableau = __webpack_require__(/*! ./Tableau.js */ \"./node_modules/javascript-lp-solver/src/Tableau/Tableau.js\");\r\n\r\n//-------------------------------------------------------------------\r\n// Function: solve\r\n// Detail: Main function, linear programming solver\r\n//-------------------------------------------------------------------\r\nTableau.prototype.simplex = function () {\r\n    // Bounded until proven otherwise\r\n    this.bounded = true;\r\n\r\n    // Execute Phase 1 to obtain a Basic Feasible Solution (BFS)\r\n    this.phase1();\r\n\r\n    // Execute Phase 2\r\n    if (this.feasible === true) {\r\n        // Running simplex on Initial Basic Feasible Solution (BFS)\r\n        // N.B current solution is feasible\r\n        this.phase2();\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n//-------------------------------------------------------------------\r\n// Description: Convert a non standard form tableau\r\n//              to a standard form tableau by eliminating\r\n//              all negative values in the Right Hand Side (RHS)\r\n//              This results in a Basic Feasible Solution (BFS)\r\n//\r\n//-------------------------------------------------------------------\r\nTableau.prototype.phase1 = function () {\r\n    var debugCheckForCycles = this.model.checkForCycles;\r\n    var varIndexesCycle = [];\r\n\r\n    var matrix = this.matrix;\r\n    var rhsColumn = this.rhsColumn;\r\n    var lastColumn = this.width - 1;\r\n    var lastRow = this.height - 1;\r\n\r\n    var unrestricted;\r\n    var iterations = 0;\r\n\r\n    while (true) {\r\n        // ******************************************\r\n        // ** PHASE 1 - STEP  1 : FIND PIVOT ROW **\r\n        //\r\n        // Selecting leaving variable (feasibility condition):\r\n        // Basic variable with most negative value\r\n        //\r\n        // ******************************************\r\n        var leavingRowIndex = 0;\r\n        var rhsValue = -this.precision;\r\n        for (var r = 1; r <= lastRow; r++) {\r\n            unrestricted = this.unrestrictedVars[this.varIndexByRow[r]] === true;\r\n            \r\n            //\r\n            // *Don't think this does anything...\r\n            //\r\n            //if (unrestricted) {\r\n            //    continue;\r\n            //}\r\n\r\n            var value = matrix[r][rhsColumn];\r\n            if (value < rhsValue) {\r\n                rhsValue = value;\r\n                leavingRowIndex = r;\r\n            }\r\n        }\r\n\r\n        // If nothing is strictly smaller than 0; we're done with phase 1.\r\n        if (leavingRowIndex === 0) {\r\n            // Feasible, champagne!\r\n            this.feasible = true;\r\n            return iterations;\r\n        }\r\n\r\n\r\n        // ******************************************\r\n        // ** PHASE 1 - STEP  2 : FIND PIVOT COLUMN **\r\n        //\r\n        //\r\n        // ******************************************\r\n        // Selecting entering variable\r\n        var enteringColumn = 0;\r\n        var maxQuotient = -Infinity;\r\n        var costRow = matrix[0];\r\n        var leavingRow = matrix[leavingRowIndex];\r\n        for (var c = 1; c <= lastColumn; c++) {\r\n            var coefficient = leavingRow[c];\r\n            //\r\n            // *Don't think this does anything...\r\n            //\r\n            //if (-this.precision < coefficient && coefficient < this.precision) {\r\n            //    continue;\r\n            //}\r\n            //\r\n\r\n            unrestricted = this.unrestrictedVars[this.varIndexByCol[c]] === true;\r\n            if (unrestricted || coefficient < -this.precision) {\r\n                var quotient = -costRow[c] / coefficient;\r\n                if (maxQuotient < quotient) {\r\n                    maxQuotient = quotient;\r\n                    enteringColumn = c;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (enteringColumn === 0) {\r\n            // Not feasible\r\n            this.feasible = false;\r\n            return iterations;\r\n        }\r\n\r\n        if(debugCheckForCycles){\r\n            varIndexesCycle.push([this.varIndexByRow[leavingRowIndex], this.varIndexByCol[enteringColumn]]);\r\n\r\n            var cycleData = this.checkForCycles(varIndexesCycle);\r\n            if(cycleData.length > 0){\r\n\r\n                this.model.messages.push(\"Cycle in phase 1\");\r\n                this.model.messages.push(\"Start :\"+ cycleData[0]);\r\n                this.model.messages.push(\"Length :\"+ cycleData[1]);\r\n\r\n                this.feasible = false;\r\n                return iterations;\r\n                \r\n            }\r\n        }\r\n\r\n        this.pivot(leavingRowIndex, enteringColumn);\r\n        iterations += 1;\r\n    }\r\n};\r\n\r\n//-------------------------------------------------------------------\r\n// Description: Apply simplex to obtain optimal solution\r\n//              used as phase2 of the simplex\r\n//\r\n//-------------------------------------------------------------------\r\nTableau.prototype.phase2 = function () {\r\n    var debugCheckForCycles = this.model.checkForCycles;\r\n    var varIndexesCycle = [];\r\n\r\n    var matrix = this.matrix;\r\n    var rhsColumn = this.rhsColumn;\r\n    var lastColumn = this.width - 1;\r\n    var lastRow = this.height - 1;\r\n\r\n    var precision = this.precision;\r\n    var nOptionalObjectives = this.optionalObjectives.length;\r\n    var optionalCostsColumns = null;\r\n\r\n    var iterations = 0;\r\n    var reducedCost, unrestricted;\r\n\r\n    while (true) {\r\n        var costRow = matrix[this.costRowIndex];\r\n\r\n        // Selecting entering variable (optimality condition)\r\n        if (nOptionalObjectives > 0) {\r\n            optionalCostsColumns = [];\r\n        }\r\n\r\n        var enteringColumn = 0;\r\n        var enteringValue = precision;\r\n        var isReducedCostNegative = false;\r\n        for (var c = 1; c <= lastColumn; c++) {\r\n            reducedCost = costRow[c];\r\n            unrestricted = this.unrestrictedVars[this.varIndexByCol[c]] === true;\r\n\r\n            if (nOptionalObjectives > 0 && -precision < reducedCost && reducedCost < precision) {\r\n                optionalCostsColumns.push(c);\r\n                continue;\r\n            }\r\n\r\n            if (unrestricted && reducedCost < 0) {\r\n                if (-reducedCost > enteringValue) {\r\n                    enteringValue = -reducedCost;\r\n                    enteringColumn = c;\r\n                    isReducedCostNegative = true;\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if (reducedCost > enteringValue) {\r\n                enteringValue = reducedCost;\r\n                enteringColumn = c;\r\n                isReducedCostNegative = false;\r\n            }\r\n        }\r\n\r\n        if (nOptionalObjectives > 0) {\r\n            // There exist optional improvable objectives\r\n            var o = 0;\r\n            while (enteringColumn === 0 && optionalCostsColumns.length > 0 && o < nOptionalObjectives) {\r\n                var optionalCostsColumns2 = [];\r\n                var reducedCosts = this.optionalObjectives[o].reducedCosts;\r\n\r\n                enteringValue = precision;\r\n\r\n                for (var i = 0; i < optionalCostsColumns.length; i++) {\r\n                    c = optionalCostsColumns[i];\r\n\r\n                    reducedCost = reducedCosts[c];\r\n                    unrestricted = this.unrestrictedVars[this.varIndexByCol[c]] === true;\r\n\r\n                    if (-precision < reducedCost && reducedCost < precision) {\r\n                        optionalCostsColumns2.push(c);\r\n                        continue;\r\n                    }\r\n\r\n                    if (unrestricted && reducedCost < 0) {\r\n                        if (-reducedCost > enteringValue) {\r\n                            enteringValue = -reducedCost;\r\n                            enteringColumn = c;\r\n                            isReducedCostNegative = true;\r\n                        }\r\n                        continue;\r\n                    }\r\n\r\n                    if (reducedCost > enteringValue) {\r\n                        enteringValue = reducedCost;\r\n                        enteringColumn = c;\r\n                        isReducedCostNegative = false;\r\n                    }\r\n                }\r\n                optionalCostsColumns = optionalCostsColumns2;\r\n                o += 1;\r\n            }\r\n        }\r\n\r\n\r\n        // If no entering column could be found we're done with phase 2.\r\n        if (enteringColumn === 0) {\r\n            this.setEvaluation();\r\n            this.simplexIters += 1;\r\n            return iterations;\r\n        }\r\n\r\n        // Selecting leaving variable\r\n        var leavingRow = 0;\r\n        var minQuotient = Infinity;\r\n\r\n        var varIndexByRow = this.varIndexByRow;\r\n\r\n        for (var r = 1; r <= lastRow; r++) {\r\n            var row = matrix[r];\r\n            var rhsValue = row[rhsColumn];\r\n            var colValue = row[enteringColumn];\r\n\r\n            if (-precision < colValue && colValue < precision) {\r\n                continue;\r\n            }\r\n\r\n            if (colValue > 0 && precision > rhsValue && rhsValue > -precision) {\r\n                minQuotient = 0;\r\n                leavingRow = r;\r\n                break;\r\n            }\r\n\r\n            var quotient = isReducedCostNegative ? -rhsValue / colValue : rhsValue / colValue;\r\n            if (quotient > precision && minQuotient > quotient) {\r\n                minQuotient = quotient;\r\n                leavingRow = r;\r\n            }\r\n        }\r\n\r\n        if (minQuotient === Infinity) {\r\n            // optimal value is -Infinity\r\n            this.evaluation = -Infinity;\r\n            this.bounded = false;\r\n            this.unboundedVarIndex = this.varIndexByCol[enteringColumn];\r\n            return iterations;\r\n        }\r\n\r\n        if(debugCheckForCycles){\r\n            varIndexesCycle.push([this.varIndexByRow[leavingRow], this.varIndexByCol[enteringColumn]]);\r\n\r\n            var cycleData = this.checkForCycles(varIndexesCycle);\r\n            if(cycleData.length > 0){\r\n\r\n                this.model.messages.push(\"Cycle in phase 2\");\r\n                this.model.messages.push(\"Start :\"+ cycleData[0]);\r\n                this.model.messages.push(\"Length :\"+ cycleData[1]);\r\n\r\n                this.feasible = false;\r\n                return iterations;\r\n            }\r\n        }\r\n\r\n        this.pivot(leavingRow, enteringColumn, true);\r\n        iterations += 1;\r\n    }\r\n};\r\n\r\n// Array holding the column indexes for which the value is not null\r\n// on the pivot row\r\n// Shared by all tableaux for smaller overhead and lower memory usage\r\nvar nonZeroColumns = [];\r\n\r\n\r\n//-------------------------------------------------------------------\r\n// Description: Execute pivot operations over a 2d array,\r\n//          on a given row, and column\r\n//\r\n//-------------------------------------------------------------------\r\nTableau.prototype.pivot = function (pivotRowIndex, pivotColumnIndex) {\r\n    var matrix = this.matrix;\r\n\r\n    var quotient = matrix[pivotRowIndex][pivotColumnIndex];\r\n\r\n    var lastRow = this.height - 1;\r\n    var lastColumn = this.width - 1;\r\n\r\n    var leavingBasicIndex = this.varIndexByRow[pivotRowIndex];\r\n    var enteringBasicIndex = this.varIndexByCol[pivotColumnIndex];\r\n\r\n    this.varIndexByRow[pivotRowIndex] = enteringBasicIndex;\r\n    this.varIndexByCol[pivotColumnIndex] = leavingBasicIndex;\r\n\r\n    this.rowByVarIndex[enteringBasicIndex] = pivotRowIndex;\r\n    this.rowByVarIndex[leavingBasicIndex] = -1;\r\n\r\n    this.colByVarIndex[enteringBasicIndex] = -1;\r\n    this.colByVarIndex[leavingBasicIndex] = pivotColumnIndex;\r\n\r\n    // Divide everything in the target row by the element @\r\n    // the target column\r\n    var pivotRow = matrix[pivotRowIndex];\r\n    var nNonZeroColumns = 0;\r\n    for (var c = 0; c <= lastColumn; c++) {\r\n        if (!(pivotRow[c] >= -1e-16 && pivotRow[c] <= 1e-16)) {\r\n            pivotRow[c] /= quotient;\r\n            nonZeroColumns[nNonZeroColumns] = c;\r\n            nNonZeroColumns += 1;\r\n        } else {\r\n            pivotRow[c] = 0;\r\n        }\r\n    }\r\n    pivotRow[pivotColumnIndex] = 1 / quotient;\r\n\r\n    // for every row EXCEPT the pivot row,\r\n    // set the value in the pivot column = 0 by\r\n    // multiplying the value of all elements in the objective\r\n    // row by ... yuck... just look below; better explanation later\r\n    var coefficient, i, v0;\r\n    var precision = this.precision;\r\n    \r\n    // //////////////////////////////////////\r\n    //\r\n    // This is step 2 of the pivot function.\r\n    // It is, by far, the most expensive piece of\r\n    // this whole process where the code can be optimized (faster code)\r\n    // without changing the whole algorithm (fewer cycles)\r\n    //\r\n    // 1.) For every row but the pivot row\r\n    // 2.) Update each column to \r\n    //    a.) itself\r\n    //        less\r\n    //    b.) active-row's pivot column\r\n    //        times\r\n    //    c.) whatever-the-hell this is: nonZeroColumns[i]\r\n    // \r\n    // //////////////////////////////////////\r\n    // console.time(\"step-2\");\r\n    for (var r = 0; r <= lastRow; r++) {\r\n        if (r !== pivotRowIndex) {\r\n            //if(1 === 1){\r\n            if(!(matrix[r][pivotColumnIndex] >= -1e-16 && matrix[r][pivotColumnIndex] <= 1e-16)){\r\n            //if((matrix[r][pivotColumnIndex] !== 0)){\r\n                // Set reference to the row we're working on\r\n                //\r\n                var row = matrix[r];\r\n\r\n                // Catch the coefficient that we're going to end up dividing everything by\r\n                coefficient = row[pivotColumnIndex];\r\n                \r\n                // No point Burning Cycles if\r\n                // Zero to the thing\r\n                if (!(coefficient >= -1e-16 && coefficient <= 1e-16)) {\r\n                    for (i = 0; i < nNonZeroColumns; i++) {\r\n                        c = nonZeroColumns[i];\r\n                        // No point in doing math if you're just adding\r\n                        // Zero to the thing\r\n                        v0 = pivotRow[c];\r\n                        if (!(v0 >= -1e-16 && v0 <= 1e-16)) {\r\n                            row[c] = row[c] - coefficient * v0;\r\n                        } else {\r\n                            if(v0 !== 0){\r\n                                pivotRow[c] = 0;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    row[pivotColumnIndex] = -coefficient / quotient;\r\n                } else {\r\n                    if(coefficient !== 0){\r\n                        row[pivotColumnIndex] = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // console.timeEnd(\"step-2\");\r\n\r\n    var nOptionalObjectives = this.optionalObjectives.length;\r\n    if (nOptionalObjectives > 0) {\r\n        for (var o = 0; o < nOptionalObjectives; o += 1) {\r\n            var reducedCosts = this.optionalObjectives[o].reducedCosts;\r\n            coefficient = reducedCosts[pivotColumnIndex];\r\n            if (coefficient !== 0) {\r\n                for (i = 0; i < nNonZeroColumns; i++) {\r\n                    c = nonZeroColumns[i];\r\n                    v0 = pivotRow[c];\r\n                    if (v0 !== 0) {\r\n                        reducedCosts[c] = reducedCosts[c] - coefficient * v0;\r\n                    }\r\n                }\r\n\r\n                reducedCosts[pivotColumnIndex] = -coefficient / quotient;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n\r\n\r\nTableau.prototype.checkForCycles = function (varIndexes) {\r\n    for (var e1 = 0; e1 < varIndexes.length - 1; e1++) {\r\n        for (var e2 = e1 + 1; e2 < varIndexes.length; e2++) {\r\n            var elt1 = varIndexes[e1];\r\n            var elt2 = varIndexes[e2];\r\n            if (elt1[0] === elt2[0] && elt1[1] === elt2[1]) {\r\n                if (e2 - e1 > varIndexes.length - e2) {\r\n                    break;\r\n                }\r\n                var cycleFound = true;\r\n                for (var i = 1; i < e2 - e1; i++) {\r\n                    var tmp1 = varIndexes[e1+i];\r\n                    var tmp2 = varIndexes[e2+i];\r\n                    if(tmp1[0] !== tmp2[0] || tmp1[1] !== tmp2[1]) {\r\n                        cycleFound = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (cycleFound) {\r\n                    return [e1, e2 - e1];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return [];\r\n};\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/Tableau/simplex.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/Validation.js":
/*!*************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/Validation.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*global describe*/\r\n/*global require*/\r\n/*global module*/\r\n/*global it*/\r\n/*global console*/\r\n/*global process*/\r\n/*global exports*/\r\n\r\n\r\n// All functions in this module that\r\n// get exported to main ***MUST***\r\n// return a functional LPSolve JSON style\r\n// model or throw an error\r\n\r\nexports.CleanObjectiveAttributes = function(model){\r\n  // Test to see if the objective attribute\r\n  // is also used by one of the constraints\r\n  //\r\n  // If so...create a new attribute on each\r\n  // variable\r\n    var fakeAttr,\r\n        x, z;\r\n  \r\n    if(typeof model.optimize === \"string\"){\r\n        if(model.constraints[model.optimize]){\r\n            // Create the new attribute\r\n            fakeAttr = Math.random();\r\n\r\n            // Go over each variable and check\r\n            for(x in model.variables){\r\n                // Is it there?\r\n                if(model.variables[x][model.optimize]){\r\n                    model.variables[x][fakeAttr] = model.variables[x][model.optimize];\r\n                }\r\n            }\r\n\r\n        // Now that we've cleaned up the variables\r\n        // we need to clean up the constraints\r\n            model.constraints[fakeAttr] = model.constraints[model.optimize];\r\n            delete model.constraints[model.optimize];\r\n            return model;\r\n        } else {    \r\n            return model;\r\n        }  \r\n    } else {\r\n        // We're assuming its an object?\r\n        for(z in model.optimize){\r\n            if(model.constraints[z]){\r\n            // Make sure that the constraint\r\n            // being optimized isn't constrained\r\n            // by an equity collar\r\n                if(model.constraints[z] === \"equal\"){\r\n                    // Its constrained by an equal sign;\r\n                    // delete that objective and move on\r\n                    delete model.optimize[z];\r\n                \r\n                } else {\r\n                    // Create the new attribute\r\n                    fakeAttr = Math.random();\r\n\r\n                    // Go over each variable and check\r\n                    for(x in model.variables){\r\n                        // Is it there?\r\n                        if(model.variables[x][z]){\r\n                            model.variables[x][fakeAttr] = model.variables[x][z];\r\n                        }\r\n                    }\r\n                // Now that we've cleaned up the variables\r\n                // we need to clean up the constraints\r\n                    model.constraints[fakeAttr] = model.constraints[z];\r\n                    delete model.constraints[z];            \r\n                }\r\n            }    \r\n        }\r\n        return model;\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/Validation.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/expressions.js":
/*!**************************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/expressions.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("/*global describe*/\r\n/*global require*/\r\n/*global module*/\r\n/*global it*/\r\n/*global console*/\r\n/*global process*/\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nfunction Variable(id, cost, index, priority) {\r\n    this.id = id;\r\n    this.cost = cost;\r\n    this.index = index;\r\n    this.value = 0;\r\n    this.priority = priority;\r\n}\r\n\r\nfunction IntegerVariable(id, cost, index, priority) {\r\n    Variable.call(this, id, cost, index, priority);\r\n}\r\nIntegerVariable.prototype.isInteger = true;\r\n\r\nfunction SlackVariable(id, index) {\r\n    Variable.call(this, id, 0, index, 0);\r\n}\r\nSlackVariable.prototype.isSlack = true;\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nfunction Term(variable, coefficient) {\r\n    this.variable = variable;\r\n    this.coefficient = coefficient;\r\n}\r\n\r\nfunction createRelaxationVariable(model, weight, priority) {\r\n    if (priority === 0 || priority === \"required\") {\r\n        return null;\r\n    }\r\n\r\n    weight = weight || 1;\r\n    priority = priority || 1;\r\n\r\n    if (model.isMinimization === false) {\r\n        weight = -weight;\r\n    }\r\n\r\n    return model.addVariable(weight, \"r\" + (model.relaxationIndex++), false, false, priority);\r\n}\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nfunction Constraint(rhs, isUpperBound, index, model) {\r\n    this.slack = new SlackVariable(\"s\" + index, index);\r\n    this.index = index;\r\n    this.model = model;\r\n    this.rhs = rhs;\r\n    this.isUpperBound = isUpperBound;\r\n\r\n    this.terms = [];\r\n    this.termsByVarIndex = {};\r\n\r\n    // Error variable in case the constraint is relaxed\r\n    this.relaxation = null;\r\n}\r\n\r\nConstraint.prototype.addTerm = function (coefficient, variable) {\r\n    var varIndex = variable.index;\r\n    var term = this.termsByVarIndex[varIndex];\r\n    if (term === undefined) {\r\n        // No term for given variable\r\n        term = new Term(variable, coefficient);\r\n        this.termsByVarIndex[varIndex] = term;\r\n        this.terms.push(term);\r\n        if (this.isUpperBound === true) {\r\n            coefficient = -coefficient;\r\n        }\r\n        this.model.updateConstraintCoefficient(this, variable, coefficient);\r\n    } else {\r\n        // Term for given variable already exists\r\n        // updating its coefficient\r\n        var newCoefficient = term.coefficient + coefficient;\r\n        this.setVariableCoefficient(newCoefficient, variable);\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\nConstraint.prototype.removeTerm = function (term) {\r\n    // TODO\r\n    return this;\r\n};\r\n\r\nConstraint.prototype.setRightHandSide = function (newRhs) {\r\n    if (newRhs !== this.rhs) {\r\n        var difference = newRhs - this.rhs;\r\n        if (this.isUpperBound === true) {\r\n            difference = -difference;\r\n        }\r\n\r\n        this.rhs = newRhs;\r\n        this.model.updateRightHandSide(this, difference);\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\nConstraint.prototype.setVariableCoefficient = function (newCoefficient, variable) {\r\n    var varIndex = variable.index;\r\n    if (varIndex === -1) {\r\n        console.warn(\"[Constraint.setVariableCoefficient] Trying to change coefficient of inexistant variable.\");\r\n        return;\r\n    }\r\n\r\n    var term = this.termsByVarIndex[varIndex];\r\n    if (term === undefined) {\r\n        // No term for given variable\r\n        this.addTerm(newCoefficient, variable);\r\n    } else {\r\n        // Term for given variable already exists\r\n        // updating its coefficient if changed\r\n        if (newCoefficient !== term.coefficient) {\r\n            var difference = newCoefficient - term.coefficient;\r\n            if (this.isUpperBound === true) {\r\n                difference = -difference;\r\n            }\r\n\r\n            term.coefficient = newCoefficient;\r\n            this.model.updateConstraintCoefficient(this, variable, difference);\r\n        }\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\nConstraint.prototype.relax = function (weight, priority) {\r\n    this.relaxation = createRelaxationVariable(this.model, weight, priority);\r\n    this._relax(this.relaxation);\r\n};\r\n\r\nConstraint.prototype._relax = function (relaxationVariable) {\r\n    if (relaxationVariable === null) {\r\n        // Relaxation variable not created, priority was probably \"required\"\r\n        return;\r\n    }\r\n\r\n    if (this.isUpperBound) {\r\n        this.setVariableCoefficient(-1, relaxationVariable);\r\n    } else {\r\n        this.setVariableCoefficient(1, relaxationVariable);\r\n    }\r\n};\r\n\r\n//-------------------------------------------------------------------\r\n//-------------------------------------------------------------------\r\nfunction Equality(constraintUpper, constraintLower) {\r\n    this.upperBound = constraintUpper;\r\n    this.lowerBound = constraintLower;\r\n    this.model = constraintUpper.model;\r\n    this.rhs = constraintUpper.rhs;\r\n    this.relaxation = null;\r\n}\r\n\r\nEquality.prototype.isEquality = true;\r\n\r\nEquality.prototype.addTerm = function (coefficient, variable) {\r\n    this.upperBound.addTerm(coefficient, variable);\r\n    this.lowerBound.addTerm(coefficient, variable);\r\n    return this;\r\n};\r\n\r\nEquality.prototype.removeTerm = function (term) {\r\n    this.upperBound.removeTerm(term);\r\n    this.lowerBound.removeTerm(term);\r\n    return this;\r\n};\r\n\r\nEquality.prototype.setRightHandSide = function (rhs) {\r\n    this.upperBound.setRightHandSide(rhs);\r\n    this.lowerBound.setRightHandSide(rhs);\r\n    this.rhs = rhs;\r\n};\r\n\r\nEquality.prototype.relax = function (weight, priority) {\r\n    this.relaxation = createRelaxationVariable(this.model, weight, priority);\r\n    this.upperBound.relaxation = this.relaxation;\r\n    this.upperBound._relax(this.relaxation);\r\n    this.lowerBound.relaxation = this.relaxation;\r\n    this.lowerBound._relax(this.relaxation);\r\n};\r\n\r\n\r\nmodule.exports = {\r\n    Constraint: Constraint,\r\n    Variable: Variable,\r\n    IntegerVariable: IntegerVariable,\r\n    SlackVariable: SlackVariable,\r\n    Equality: Equality,\r\n    Term: Term\r\n};\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/expressions.js?");

/***/ }),

/***/ "./node_modules/javascript-lp-solver/src/main.js":
/*!*******************************************************!*\
  !*** ./node_modules/javascript-lp-solver/src/main.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global describe*/\r\n/*global require*/\r\n/*global module*/\r\n/*global it*/\r\n/*global console*/\r\n/*global process*/\r\n/*global setTimeout*/\r\n/*global self*/\r\n\r\n\r\n//-------------------------------------------------------------------\r\n// SimplexJS\r\n// https://github.com/\r\n// An Object-Oriented Linear Programming Solver\r\n//\r\n// By Justin Wolcott (c)\r\n// Licensed under the MIT License.\r\n//-------------------------------------------------------------------\r\n\r\nvar Tableau = __webpack_require__(/*! ./Tableau/index.js */ \"./node_modules/javascript-lp-solver/src/Tableau/index.js\");\r\nvar Model = __webpack_require__(/*! ./Model */ \"./node_modules/javascript-lp-solver/src/Model.js\");\r\nvar branchAndCut = __webpack_require__(/*! ./Tableau/branchAndCut */ \"./node_modules/javascript-lp-solver/src/Tableau/branchAndCut.js\");\r\nvar expressions = __webpack_require__(/*! ./expressions.js */ \"./node_modules/javascript-lp-solver/src/expressions.js\");\r\nvar validation = __webpack_require__(/*! ./Validation */ \"./node_modules/javascript-lp-solver/src/Validation.js\");\r\nvar Constraint = expressions.Constraint;\r\nvar Variable = expressions.Variable;\r\nvar Numeral = expressions.Numeral;\r\nvar Term = expressions.Term;\r\nvar External = __webpack_require__(/*! ./External/main.js */ \"./node_modules/javascript-lp-solver/src/External/main.js\");\r\n\r\n// Place everything under the Solver Name Space\r\nvar Solver = function () {\r\n\r\n    \"use strict\";\r\n\r\n    this.Model = Model;\r\n    this.branchAndCut = branchAndCut;\r\n    this.Constraint = Constraint;\r\n    this.Variable = Variable;\r\n    this.Numeral = Numeral;\r\n    this.Term = Term;\r\n    this.Tableau = Tableau;\r\n    this.lastSolvedModel = null;\r\n\r\n    this.External = External;\r\n\r\n    /*************************************************************\r\n     * Method: Solve\r\n     * Scope: Public:\r\n     * Agruments:\r\n     *        model: The model we want solver to operate on\r\n     *        precision: If we're solving a MILP, how tight\r\n     *                   do we want to define an integer, given\r\n     *                   that 20.000000000000001 is not an integer.\r\n     *                   (defaults to 1e-9)\r\n     *            full: *get better description*\r\n     *        validate: if left blank, it will get ignored; otherwise\r\n     *                  it will run the model through all validation\r\n     *                  functions in the *Validate* module\r\n     **************************************************************/\r\n    this.Solve = function (model, precision, full, validate) {\r\n        //\r\n        // Run our validations on the model\r\n        // if the model doesn't have a validate\r\n        // attribute set to false\r\n        //\r\n        if(validate){\r\n            for(var test in validation){\r\n                model = validation[test](model);\r\n            }\r\n        }\r\n\r\n        // Make sure we at least have a model\r\n        if (!model) {\r\n            throw new Error(\"Solver requires a model to operate on\");\r\n        }\r\n\r\n        //\r\n        // If the objective function contains multiple objectives,\r\n        // pass it to the multi-solver thing...\r\n        //\r\n        if(typeof model.optimize === \"object\"){\r\n            if(Object.keys(model.optimize > 1)){\r\n                return __webpack_require__(/*! ./Polyopt */ \"./node_modules/javascript-lp-solver/src/Polyopt.js\")(this, model);\r\n            }\r\n        }\r\n\r\n// /////////////////////////////////////////////////////////////////////\r\n// *********************************************************************\r\n// START\r\n// Try our hand at handling external solvers...\r\n// START\r\n// *********************************************************************\r\n// /////////////////////////////////////////////////////////////////////\r\n        if(model.external){\r\n\r\n            var solvers = Object.keys(External);\r\n            solvers = JSON.stringify(solvers);\r\n            \r\n            //\r\n            // The model needs to have a \"solver\" attribute if nothing else\r\n            // for us to pass data into\r\n            //\r\n            if(!model.external.solver){\r\n                throw new Error(\"The model you provided has an 'external' object that doesn't have a solver attribute. Use one of the following:\" + solvers);\r\n            }\r\n            \r\n            //\r\n            // If the solver they request doesn't exist; provide them\r\n            // with a list of possible options:\r\n            //\r\n            if(!External[model.external.solver]){\r\n                throw new Error(\"No support (yet) for \" + model.external.solver + \". Please use one of these instead:\" + solvers);\r\n            }\r\n            \r\n            return External[model.external.solver].solve(model);\r\n            \r\n\r\n// /////////////////////////////////////////////////////////////////////\r\n// *********************************************************************\r\n//  END\r\n// Try our hand at handling external solvers...\r\n//  END\r\n// *********************************************************************\r\n// /////////////////////////////////////////////////////////////////////\r\n\r\n        } else {\r\n\r\n            if (model instanceof Model === false) {\r\n                model = new Model(precision).loadJson(model);\r\n            }\r\n\r\n            var solution = model.solve();\r\n            this.lastSolvedModel = model;\r\n            solution.solutionSet = solution.generateSolutionSet();\r\n\r\n            // If the user asks for a full breakdown\r\n            // of the tableau (e.g. full === true)\r\n            // this will return it\r\n            if (full) {\r\n                return solution;\r\n            } else {\r\n                // Otherwise; give the user the bare\r\n                // minimum of info necessary to carry on\r\n\r\n                var store = {};\r\n\r\n                // 1.) Add in feasibility to store;\r\n                store.feasible = solution.feasible;\r\n\r\n                // 2.) Add in the objective value\r\n                store.result = solution.evaluation;\r\n\r\n                store.bounded = solution.bounded;\r\n                \r\n                if(solution._tableau.__isIntegral){\r\n                    store.isIntegral = true;\r\n                }\r\n\r\n                // 3.) Load all of the variable values\r\n                Object.keys(solution.solutionSet)\r\n                    .forEach(function (d) {\r\n                        //\r\n                        // When returning data in standard format,\r\n                        // Remove all 0's\r\n                        //\r\n                        if(solution.solutionSet[d] !== 0){\r\n                            store[d] = solution.solutionSet[d];\r\n                        }\r\n                        \r\n                    });\r\n\r\n                return store;\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n    /*************************************************************\r\n     * Method: ReformatLP\r\n     * Scope: Public:\r\n     * Agruments: model: The model we want solver to operate on\r\n     * Purpose: Convert a friendly JSON model into a model for a\r\n     *          real solving library...in this case\r\n     *          lp_solver\r\n     **************************************************************/\r\n    this.ReformatLP = __webpack_require__(/*! ./External/lpsolve/Reformat.js */ \"./node_modules/javascript-lp-solver/src/External/lpsolve/Reformat.js\");\r\n\r\n\r\n     /*************************************************************\r\n     * Method: MultiObjective\r\n     * Scope: Public:\r\n     * Agruments:\r\n     *        model: The model we want solver to operate on\r\n     *        detail: if false, or undefined; it will return the\r\n     *                result of using the mid-point formula; otherwise\r\n     *                it will return an object containing:\r\n     *\r\n     *                1. The results from the mid point formula\r\n     *                2. The solution for each objective solved\r\n     *                   in isolation (pareto)\r\n     *                3. The min and max of each variable along\r\n     *                   the frontier of the polytope (ranges)\r\n     * Purpose: Solve a model with multiple objective functions.\r\n     *          Since a potential infinite number of solutions exist\r\n     *          this naively returns the mid-point between\r\n     *\r\n     * Note: The model has to be changed a little to work with this.\r\n     *       Before an *opType* was required. No more. The objective\r\n     *       attribute of the model is now an object instead of a\r\n     *       string.\r\n     *\r\n     *  *EXAMPLE MODEL*\r\n     *\r\n     *   model = {\r\n     *       optimize: {scotch: \"max\", soda: \"max\"},\r\n     *       constraints: {fluid: {equal: 100}},\r\n     *       variables: {\r\n     *           scotch: {fluid: 1, scotch: 1},\r\n     *           soda: {fluid: 1, soda: 1}\r\n     *       }\r\n     *   }\r\n     *\r\n     **************************************************************/\r\n    this.MultiObjective = function(model){\r\n        return __webpack_require__(/*! ./Polyopt */ \"./node_modules/javascript-lp-solver/src/Polyopt.js\")(this, model);\r\n    };\r\n};\r\n\r\n// var define = define || undefined;\r\n// var window = window || undefined;\r\n\r\n// If the project is loading through require.js, use `define` and exit\r\nif (true) {\r\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n        return new Solver();\r\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n// If the project doesn't see define, but sees window, put solver on window\r\n} else // removed by dead control flow\n{}\r\n// Ensure that its available in node.js env\r\nmodule.exports = new Solver();\r\n\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/javascript-lp-solver/src/main.js?");

/***/ }),

/***/ "./node_modules/jszip/dist/jszip.min.js":
/*!**********************************************!*\
  !*** ./node_modules/jszip/dist/jszip.min.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n\nJSZip v3.10.1 - A JavaScript class for generating and reading zip files\n<http://stuartk.com/jszip>\n\n(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>\nDual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.\n\nJSZip uses the library pako released under the MIT license :\nhttps://github.com/nodeca/pako/blob/main/LICENSE\n*/\n\n!function(e){if(true)module.exports=e();else // removed by dead control flow\n{}}(function(){return function s(a,o,h){function u(r,e){if(!o[r]){if(!a[r]){var t=undefined;if(!e&&t)return require(r,!0);if(l)return l(r,!0);var n=new Error(\"Cannot find module '\"+r+\"'\");throw n.code=\"MODULE_NOT_FOUND\",n}var i=o[r]={exports:{}};a[r][0].call(i.exports,function(e){var t=a[r][1][e];return u(t||e)},i,i.exports,s,a,o,h)}return o[r].exports}for(var l=undefined,e=0;e<h.length;e++)u(h[e]);return u}({1:[function(e,t,r){\"use strict\";var d=e(\"./utils\"),c=e(\"./support\"),p=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";r.encode=function(e){for(var t,r,n,i,s,a,o,h=[],u=0,l=e.length,f=l,c=\"string\"!==d.getTypeOf(e);u<e.length;)f=l-u,n=c?(t=e[u++],r=u<l?e[u++]:0,u<l?e[u++]:0):(t=e.charCodeAt(u++),r=u<l?e.charCodeAt(u++):0,u<l?e.charCodeAt(u++):0),i=t>>2,s=(3&t)<<4|r>>4,a=1<f?(15&r)<<2|n>>6:64,o=2<f?63&n:64,h.push(p.charAt(i)+p.charAt(s)+p.charAt(a)+p.charAt(o));return h.join(\"\")},r.decode=function(e){var t,r,n,i,s,a,o=0,h=0,u=\"data:\";if(e.substr(0,u.length)===u)throw new Error(\"Invalid base64 input, it looks like a data url.\");var l,f=3*(e=e.replace(/[^A-Za-z0-9+/=]/g,\"\")).length/4;if(e.charAt(e.length-1)===p.charAt(64)&&f--,e.charAt(e.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error(\"Invalid base64 input, bad content length.\");for(l=c.uint8array?new Uint8Array(0|f):new Array(0|f);o<e.length;)t=p.indexOf(e.charAt(o++))<<2|(i=p.indexOf(e.charAt(o++)))>>4,r=(15&i)<<4|(s=p.indexOf(e.charAt(o++)))>>2,n=(3&s)<<6|(a=p.indexOf(e.charAt(o++))),l[h++]=t,64!==s&&(l[h++]=r),64!==a&&(l[h++]=n);return l}},{\"./support\":30,\"./utils\":32}],2:[function(e,t,r){\"use strict\";var n=e(\"./external\"),i=e(\"./stream/DataWorker\"),s=e(\"./stream/Crc32Probe\"),a=e(\"./stream/DataLengthProbe\");function o(e,t,r,n,i){this.compressedSize=e,this.uncompressedSize=t,this.crc32=r,this.compression=n,this.compressedContent=i}o.prototype={getContentWorker:function(){var e=new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a(\"data_length\")),t=this;return e.on(\"end\",function(){if(this.streamInfo.data_length!==t.uncompressedSize)throw new Error(\"Bug : uncompressed data size mismatch\")}),e},getCompressedWorker:function(){return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo(\"compressedSize\",this.compressedSize).withStreamInfo(\"uncompressedSize\",this.uncompressedSize).withStreamInfo(\"crc32\",this.crc32).withStreamInfo(\"compression\",this.compression)}},o.createWorkerFrom=function(e,t,r){return e.pipe(new s).pipe(new a(\"uncompressedSize\")).pipe(t.compressWorker(r)).pipe(new a(\"compressedSize\")).withStreamInfo(\"compression\",t)},t.exports=o},{\"./external\":6,\"./stream/Crc32Probe\":25,\"./stream/DataLengthProbe\":26,\"./stream/DataWorker\":27}],3:[function(e,t,r){\"use strict\";var n=e(\"./stream/GenericWorker\");r.STORE={magic:\"\\0\\0\",compressWorker:function(){return new n(\"STORE compression\")},uncompressWorker:function(){return new n(\"STORE decompression\")}},r.DEFLATE=e(\"./flate\")},{\"./flate\":7,\"./stream/GenericWorker\":28}],4:[function(e,t,r){\"use strict\";var n=e(\"./utils\");var o=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}();t.exports=function(e,t){return void 0!==e&&e.length?\"string\"!==n.getTypeOf(e)?function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t[a])];return-1^e}(0|t,e,e.length,0):function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t.charCodeAt(a))];return-1^e}(0|t,e,e.length,0):0}},{\"./utils\":32}],5:[function(e,t,r){\"use strict\";r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null},{}],6:[function(e,t,r){\"use strict\";var n=null;n=\"undefined\"!=typeof Promise?Promise:e(\"lie\"),t.exports={Promise:n}},{lie:37}],7:[function(e,t,r){\"use strict\";var n=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Uint32Array,i=e(\"pako\"),s=e(\"./utils\"),a=e(\"./stream/GenericWorker\"),o=n?\"uint8array\":\"array\";function h(e,t){a.call(this,\"FlateWorker/\"+e),this._pako=null,this._pakoAction=e,this._pakoOptions=t,this.meta={}}r.magic=\"\\b\\0\",s.inherits(h,a),h.prototype.processChunk=function(e){this.meta=e.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,e.data),!1)},h.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},h.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null},h.prototype._createPako=function(){this._pako=new i[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var t=this;this._pako.onData=function(e){t.push({data:e,meta:t.meta})}},r.compressWorker=function(e){return new h(\"Deflate\",e)},r.uncompressWorker=function(){return new h(\"Inflate\",{})}},{\"./stream/GenericWorker\":28,\"./utils\":32,pako:38}],8:[function(e,t,r){\"use strict\";function A(e,t){var r,n=\"\";for(r=0;r<t;r++)n+=String.fromCharCode(255&e),e>>>=8;return n}function n(e,t,r,n,i,s){var a,o,h=e.file,u=e.compression,l=s!==O.utf8encode,f=I.transformTo(\"string\",s(h.name)),c=I.transformTo(\"string\",O.utf8encode(h.name)),d=h.comment,p=I.transformTo(\"string\",s(d)),m=I.transformTo(\"string\",O.utf8encode(d)),_=c.length!==h.name.length,g=m.length!==d.length,b=\"\",v=\"\",y=\"\",w=h.dir,k=h.date,x={crc32:0,compressedSize:0,uncompressedSize:0};t&&!r||(x.crc32=e.crc32,x.compressedSize=e.compressedSize,x.uncompressedSize=e.uncompressedSize);var S=0;t&&(S|=8),l||!_&&!g||(S|=2048);var z=0,C=0;w&&(z|=16),\"UNIX\"===i?(C=798,z|=function(e,t){var r=e;return e||(r=t?16893:33204),(65535&r)<<16}(h.unixPermissions,w)):(C=20,z|=function(e){return 63&(e||0)}(h.dosPermissions)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v=A(1,1)+A(B(f),4)+c,b+=\"up\"+A(v.length,2)+v),g&&(y=A(1,1)+A(B(p),4)+m,b+=\"uc\"+A(y.length,2)+y);var E=\"\";return E+=\"\\n\\0\",E+=A(S,2),E+=u.magic,E+=A(a,2),E+=A(o,2),E+=A(x.crc32,4),E+=A(x.compressedSize,4),E+=A(x.uncompressedSize,4),E+=A(f.length,2),E+=A(b.length,2),{fileRecord:R.LOCAL_FILE_HEADER+E+f+b,dirRecord:R.CENTRAL_FILE_HEADER+A(C,2)+E+A(p.length,2)+\"\\0\\0\\0\\0\"+A(z,4)+A(n,4)+f+b+p}}var I=e(\"../utils\"),i=e(\"../stream/GenericWorker\"),O=e(\"../utf8\"),B=e(\"../crc32\"),R=e(\"../signature\");function s(e,t,r,n){i.call(this,\"ZipFileWorker\"),this.bytesWritten=0,this.zipComment=t,this.zipPlatform=r,this.encodeFileName=n,this.streamFiles=e,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}I.inherits(s,i),s.prototype.push=function(e){var t=e.meta.percent||0,r=this.entriesCount,n=this._sources.length;this.accumulate?this.contentBuffer.push(e):(this.bytesWritten+=e.data.length,i.prototype.push.call(this,{data:e.data,meta:{currentFile:this.currentFile,percent:r?(t+100*(r-n-1))/r:100}}))},s.prototype.openedSource=function(e){this.currentSourceOffset=this.bytesWritten,this.currentFile=e.file.name;var t=this.streamFiles&&!e.file.dir;if(t){var r=n(e,t,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}})}else this.accumulate=!0},s.prototype.closedSource=function(e){this.accumulate=!1;var t=this.streamFiles&&!e.file.dir,r=n(e,t,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(r.dirRecord),t)this.push({data:function(e){return R.DATA_DESCRIPTOR+A(e.crc32,4)+A(e.compressedSize,4)+A(e.uncompressedSize,4)}(e),meta:{percent:100}});else for(this.push({data:r.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},s.prototype.flush=function(){for(var e=this.bytesWritten,t=0;t<this.dirRecords.length;t++)this.push({data:this.dirRecords[t],meta:{percent:100}});var r=this.bytesWritten-e,n=function(e,t,r,n,i){var s=I.transformTo(\"string\",i(n));return R.CENTRAL_DIRECTORY_END+\"\\0\\0\\0\\0\"+A(e,2)+A(e,2)+A(t,4)+A(r,4)+A(s.length,2)+s}(this.dirRecords.length,r,e,this.zipComment,this.encodeFileName);this.push({data:n,meta:{percent:100}})},s.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},s.prototype.registerPrevious=function(e){this._sources.push(e);var t=this;return e.on(\"data\",function(e){t.processChunk(e)}),e.on(\"end\",function(){t.closedSource(t.previous.streamInfo),t._sources.length?t.prepareNextSource():t.end()}),e.on(\"error\",function(e){t.error(e)}),this},s.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},s.prototype.error=function(e){var t=this._sources;if(!i.prototype.error.call(this,e))return!1;for(var r=0;r<t.length;r++)try{t[r].error(e)}catch(e){}return!0},s.prototype.lock=function(){i.prototype.lock.call(this);for(var e=this._sources,t=0;t<e.length;t++)e[t].lock()},t.exports=s},{\"../crc32\":4,\"../signature\":23,\"../stream/GenericWorker\":28,\"../utf8\":31,\"../utils\":32}],9:[function(e,t,r){\"use strict\";var u=e(\"../compressions\"),n=e(\"./ZipFileWorker\");r.generateWorker=function(e,a,t){var o=new n(a.streamFiles,t,a.platform,a.encodeFileName),h=0;try{e.forEach(function(e,t){h++;var r=function(e,t){var r=e||t,n=u[r];if(!n)throw new Error(r+\" is not a valid compression method !\");return n}(t.options.compression,a.compression),n=t.options.compressionOptions||a.compressionOptions||{},i=t.dir,s=t.date;t._compressWorker(r,n).withStreamInfo(\"file\",{name:e,dir:i,date:s,comment:t.comment||\"\",unixPermissions:t.unixPermissions,dosPermissions:t.dosPermissions}).pipe(o)}),o.entriesCount=h}catch(e){o.error(e)}return o}},{\"../compressions\":3,\"./ZipFileWorker\":8}],10:[function(e,t,r){\"use strict\";function n(){if(!(this instanceof n))return new n;if(arguments.length)throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");this.files=Object.create(null),this.comment=null,this.root=\"\",this.clone=function(){var e=new n;for(var t in this)\"function\"!=typeof this[t]&&(e[t]=this[t]);return e}}(n.prototype=e(\"./object\")).loadAsync=e(\"./load\"),n.support=e(\"./support\"),n.defaults=e(\"./defaults\"),n.version=\"3.10.1\",n.loadAsync=function(e,t){return(new n).loadAsync(e,t)},n.external=e(\"./external\"),t.exports=n},{\"./defaults\":5,\"./external\":6,\"./load\":11,\"./object\":15,\"./support\":30}],11:[function(e,t,r){\"use strict\";var u=e(\"./utils\"),i=e(\"./external\"),n=e(\"./utf8\"),s=e(\"./zipEntries\"),a=e(\"./stream/Crc32Probe\"),l=e(\"./nodejsUtils\");function f(n){return new i.Promise(function(e,t){var r=n.decompressed.getContentWorker().pipe(new a);r.on(\"error\",function(e){t(e)}).on(\"end\",function(){r.streamInfo.crc32!==n.decompressed.crc32?t(new Error(\"Corrupted zip : CRC32 mismatch\")):e()}).resume()})}t.exports=function(e,o){var h=this;return o=u.extend(o||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:n.utf8decode}),l.isNode&&l.isStream(e)?i.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\")):u.prepareContent(\"the loaded zip file\",e,!0,o.optimizedBinaryString,o.base64).then(function(e){var t=new s(o);return t.load(e),t}).then(function(e){var t=[i.Promise.resolve(e)],r=e.files;if(o.checkCRC32)for(var n=0;n<r.length;n++)t.push(f(r[n]));return i.Promise.all(t)}).then(function(e){for(var t=e.shift(),r=t.files,n=0;n<r.length;n++){var i=r[n],s=i.fileNameStr,a=u.resolve(i.fileNameStr);h.file(a,i.decompressed,{binary:!0,optimizedBinaryString:!0,date:i.date,dir:i.dir,comment:i.fileCommentStr.length?i.fileCommentStr:null,unixPermissions:i.unixPermissions,dosPermissions:i.dosPermissions,createFolders:o.createFolders}),i.dir||(h.file(a).unsafeOriginalName=s)}return t.zipComment.length&&(h.comment=t.zipComment),h})}},{\"./external\":6,\"./nodejsUtils\":14,\"./stream/Crc32Probe\":25,\"./utf8\":31,\"./utils\":32,\"./zipEntries\":33}],12:[function(e,t,r){\"use strict\";var n=e(\"../utils\"),i=e(\"../stream/GenericWorker\");function s(e,t){i.call(this,\"Nodejs stream input adapter for \"+e),this._upstreamEnded=!1,this._bindStream(t)}n.inherits(s,i),s.prototype._bindStream=function(e){var t=this;(this._stream=e).pause(),e.on(\"data\",function(e){t.push({data:e,meta:{percent:0}})}).on(\"error\",function(e){t.isPaused?this.generatedError=e:t.error(e)}).on(\"end\",function(){t.isPaused?t._upstreamEnded=!0:t.end()})},s.prototype.pause=function(){return!!i.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},t.exports=s},{\"../stream/GenericWorker\":28,\"../utils\":32}],13:[function(e,t,r){\"use strict\";var i=e(\"readable-stream\").Readable;function n(e,t,r){i.call(this,t),this._helper=e;var n=this;e.on(\"data\",function(e,t){n.push(e)||n._helper.pause(),r&&r(t)}).on(\"error\",function(e){n.emit(\"error\",e)}).on(\"end\",function(){n.push(null)})}e(\"../utils\").inherits(n,i),n.prototype._read=function(){this._helper.resume()},t.exports=n},{\"../utils\":32,\"readable-stream\":16}],14:[function(e,t,r){\"use strict\";t.exports={isNode:\"undefined\"!=typeof Buffer,newBufferFrom:function(e,t){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(e,t);if(\"number\"==typeof e)throw new Error('The \"data\" argument must not be a number');return new Buffer(e,t)},allocBuffer:function(e){if(Buffer.alloc)return Buffer.alloc(e);var t=new Buffer(e);return t.fill(0),t},isBuffer:function(e){return Buffer.isBuffer(e)},isStream:function(e){return e&&\"function\"==typeof e.on&&\"function\"==typeof e.pause&&\"function\"==typeof e.resume}}},{}],15:[function(e,t,r){\"use strict\";function s(e,t,r){var n,i=u.getTypeOf(t),s=u.extend(r||{},f);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),\"string\"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(e=g(e)),s.createFolders&&(n=_(e))&&b.call(this,n,!0);var a=\"string\"===i&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!a),(t instanceof c&&0===t.uncompressedSize||s.dir||!t||0===t.length)&&(s.base64=!1,s.binary=!0,t=\"\",s.compression=\"STORE\",i=\"string\");var o=null;o=t instanceof c||t instanceof l?t:p.isNode&&p.isStream(t)?new m(e,t):u.prepareContent(e,t,s.binary,s.optimizedBinaryString,s.base64);var h=new d(e,o,s);this.files[e]=h}var i=e(\"./utf8\"),u=e(\"./utils\"),l=e(\"./stream/GenericWorker\"),a=e(\"./stream/StreamHelper\"),f=e(\"./defaults\"),c=e(\"./compressedObject\"),d=e(\"./zipObject\"),o=e(\"./generate\"),p=e(\"./nodejsUtils\"),m=e(\"./nodejs/NodejsStreamInputAdapter\"),_=function(e){\"/\"===e.slice(-1)&&(e=e.substring(0,e.length-1));var t=e.lastIndexOf(\"/\");return 0<t?e.substring(0,t):\"\"},g=function(e){return\"/\"!==e.slice(-1)&&(e+=\"/\"),e},b=function(e,t){return t=void 0!==t?t:f.createFolders,e=g(e),this.files[e]||s.call(this,e,null,{dir:!0,createFolders:t}),this.files[e]};function h(e){return\"[object RegExp]\"===Object.prototype.toString.call(e)}var n={load:function(){throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\")},forEach:function(e){var t,r,n;for(t in this.files)n=this.files[t],(r=t.slice(this.root.length,t.length))&&t.slice(0,this.root.length)===this.root&&e(r,n)},filter:function(r){var n=[];return this.forEach(function(e,t){r(e,t)&&n.push(t)}),n},file:function(e,t,r){if(1!==arguments.length)return e=this.root+e,s.call(this,e,t,r),this;if(h(e)){var n=e;return this.filter(function(e,t){return!t.dir&&n.test(e)})}var i=this.files[this.root+e];return i&&!i.dir?i:null},folder:function(r){if(!r)return this;if(h(r))return this.filter(function(e,t){return t.dir&&r.test(e)});var e=this.root+r,t=b.call(this,e),n=this.clone();return n.root=t.name,n},remove:function(r){r=this.root+r;var e=this.files[r];if(e||(\"/\"!==r.slice(-1)&&(r+=\"/\"),e=this.files[r]),e&&!e.dir)delete this.files[r];else for(var t=this.filter(function(e,t){return t.name.slice(0,r.length)===r}),n=0;n<t.length;n++)delete this.files[t[n].name];return this},generate:function(){throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\")},generateInternalStream:function(e){var t,r={};try{if((r=u.extend(e||{},{streamFiles:!1,compression:\"STORE\",compressionOptions:null,type:\"\",platform:\"DOS\",comment:null,mimeType:\"application/zip\",encodeFileName:i.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),\"binarystring\"===r.type&&(r.type=\"string\"),!r.type)throw new Error(\"No output type specified.\");u.checkSupport(r.type),\"darwin\"!==r.platform&&\"freebsd\"!==r.platform&&\"linux\"!==r.platform&&\"sunos\"!==r.platform||(r.platform=\"UNIX\"),\"win32\"===r.platform&&(r.platform=\"DOS\");var n=r.comment||this.comment||\"\";t=o.generateWorker(this,r,n)}catch(e){(t=new l(\"error\")).error(e)}return new a(t,r.type||\"string\",r.mimeType)},generateAsync:function(e,t){return this.generateInternalStream(e).accumulate(t)},generateNodeStream:function(e,t){return(e=e||{}).type||(e.type=\"nodebuffer\"),this.generateInternalStream(e).toNodejsStream(t)}};t.exports=n},{\"./compressedObject\":2,\"./defaults\":5,\"./generate\":9,\"./nodejs/NodejsStreamInputAdapter\":12,\"./nodejsUtils\":14,\"./stream/GenericWorker\":28,\"./stream/StreamHelper\":29,\"./utf8\":31,\"./utils\":32,\"./zipObject\":35}],16:[function(e,t,r){\"use strict\";t.exports=e(\"stream\")},{stream:void 0}],17:[function(e,t,r){\"use strict\";var n=e(\"./DataReader\");function i(e){n.call(this,e);for(var t=0;t<this.data.length;t++)e[t]=255&e[t]}e(\"../utils\").inherits(i,n),i.prototype.byteAt=function(e){return this.data[this.zero+e]},i.prototype.lastIndexOfSignature=function(e){for(var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===t&&this.data[s+1]===r&&this.data[s+2]===n&&this.data[s+3]===i)return s-this.zero;return-1},i.prototype.readAndCheckSignature=function(e){var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.readData(4);return t===s[0]&&r===s[1]&&n===s[2]&&i===s[3]},i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return[];var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{\"../utils\":32,\"./DataReader\":18}],18:[function(e,t,r){\"use strict\";var n=e(\"../utils\");function i(e){this.data=e,this.length=e.length,this.index=0,this.zero=0}i.prototype={checkOffset:function(e){this.checkIndex(this.index+e)},checkIndex:function(e){if(this.length<this.zero+e||e<0)throw new Error(\"End of data reached (data length = \"+this.length+\", asked index = \"+e+\"). Corrupted zip ?\")},setIndex:function(e){this.checkIndex(e),this.index=e},skip:function(e){this.setIndex(this.index+e)},byteAt:function(){},readInt:function(e){var t,r=0;for(this.checkOffset(e),t=this.index+e-1;t>=this.index;t--)r=(r<<8)+this.byteAt(t);return this.index+=e,r},readString:function(e){return n.transformTo(\"string\",this.readData(e))},readData:function(){},lastIndexOfSignature:function(){},readAndCheckSignature:function(){},readDate:function(){var e=this.readInt(4);return new Date(Date.UTC(1980+(e>>25&127),(e>>21&15)-1,e>>16&31,e>>11&31,e>>5&63,(31&e)<<1))}},t.exports=i},{\"../utils\":32}],19:[function(e,t,r){\"use strict\";var n=e(\"./Uint8ArrayReader\");function i(e){n.call(this,e)}e(\"../utils\").inherits(i,n),i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{\"../utils\":32,\"./Uint8ArrayReader\":21}],20:[function(e,t,r){\"use strict\";var n=e(\"./DataReader\");function i(e){n.call(this,e)}e(\"../utils\").inherits(i,n),i.prototype.byteAt=function(e){return this.data.charCodeAt(this.zero+e)},i.prototype.lastIndexOfSignature=function(e){return this.data.lastIndexOf(e)-this.zero},i.prototype.readAndCheckSignature=function(e){return e===this.readData(4)},i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{\"../utils\":32,\"./DataReader\":18}],21:[function(e,t,r){\"use strict\";var n=e(\"./ArrayReader\");function i(e){n.call(this,e)}e(\"../utils\").inherits(i,n),i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return new Uint8Array(0);var t=this.data.subarray(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{\"../utils\":32,\"./ArrayReader\":17}],22:[function(e,t,r){\"use strict\";var n=e(\"../utils\"),i=e(\"../support\"),s=e(\"./ArrayReader\"),a=e(\"./StringReader\"),o=e(\"./NodeBufferReader\"),h=e(\"./Uint8ArrayReader\");t.exports=function(e){var t=n.getTypeOf(e);return n.checkSupport(t),\"string\"!==t||i.uint8array?\"nodebuffer\"===t?new o(e):i.uint8array?new h(n.transformTo(\"uint8array\",e)):new s(n.transformTo(\"array\",e)):new a(e)}},{\"../support\":30,\"../utils\":32,\"./ArrayReader\":17,\"./NodeBufferReader\":19,\"./StringReader\":20,\"./Uint8ArrayReader\":21}],23:[function(e,t,r){\"use strict\";r.LOCAL_FILE_HEADER=\"PK\u0003\u0004\",r.CENTRAL_FILE_HEADER=\"PK\u0001\u0002\",r.CENTRAL_DIRECTORY_END=\"PK\u0005\u0006\",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR=\"PK\u0006\u0007\",r.ZIP64_CENTRAL_DIRECTORY_END=\"PK\u0006\u0006\",r.DATA_DESCRIPTOR=\"PK\u0007\\b\"},{}],24:[function(e,t,r){\"use strict\";var n=e(\"./GenericWorker\"),i=e(\"../utils\");function s(e){n.call(this,\"ConvertWorker to \"+e),this.destType=e}i.inherits(s,n),s.prototype.processChunk=function(e){this.push({data:i.transformTo(this.destType,e.data),meta:e.meta})},t.exports=s},{\"../utils\":32,\"./GenericWorker\":28}],25:[function(e,t,r){\"use strict\";var n=e(\"./GenericWorker\"),i=e(\"../crc32\");function s(){n.call(this,\"Crc32Probe\"),this.withStreamInfo(\"crc32\",0)}e(\"../utils\").inherits(s,n),s.prototype.processChunk=function(e){this.streamInfo.crc32=i(e.data,this.streamInfo.crc32||0),this.push(e)},t.exports=s},{\"../crc32\":4,\"../utils\":32,\"./GenericWorker\":28}],26:[function(e,t,r){\"use strict\";var n=e(\"../utils\"),i=e(\"./GenericWorker\");function s(e){i.call(this,\"DataLengthProbe for \"+e),this.propName=e,this.withStreamInfo(e,0)}n.inherits(s,i),s.prototype.processChunk=function(e){if(e){var t=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=t+e.data.length}i.prototype.processChunk.call(this,e)},t.exports=s},{\"../utils\":32,\"./GenericWorker\":28}],27:[function(e,t,r){\"use strict\";var n=e(\"../utils\"),i=e(\"./GenericWorker\");function s(e){i.call(this,\"DataWorker\");var t=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type=\"\",this._tickScheduled=!1,e.then(function(e){t.dataIsReady=!0,t.data=e,t.max=e&&e.length||0,t.type=n.getTypeOf(e),t.isPaused||t._tickAndRepeat()},function(e){t.error(e)})}n.inherits(s,i),s.prototype.cleanUp=function(){i.prototype.cleanUp.call(this),this.data=null},s.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,n.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(n.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var e=null,t=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case\"string\":e=this.data.substring(this.index,t);break;case\"uint8array\":e=this.data.subarray(this.index,t);break;case\"array\":case\"nodebuffer\":e=this.data.slice(this.index,t)}return this.index=t,this.push({data:e,meta:{percent:this.max?this.index/this.max*100:0}})},t.exports=s},{\"../utils\":32,\"./GenericWorker\":28}],28:[function(e,t,r){\"use strict\";function n(e){this.name=e||\"default\",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}n.prototype={push:function(e){this.emit(\"data\",e)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit(\"end\"),this.cleanUp(),this.isFinished=!0}catch(e){this.emit(\"error\",e)}return!0},error:function(e){return!this.isFinished&&(this.isPaused?this.generatedError=e:(this.isFinished=!0,this.emit(\"error\",e),this.previous&&this.previous.error(e),this.cleanUp()),!0)},on:function(e,t){return this._listeners[e].push(t),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(e,t){if(this._listeners[e])for(var r=0;r<this._listeners[e].length;r++)this._listeners[e][r].call(this,t)},pipe:function(e){return e.registerPrevious(this)},registerPrevious:function(e){if(this.isLocked)throw new Error(\"The stream '\"+this+\"' has already been used.\");this.streamInfo=e.streamInfo,this.mergeStreamInfo(),this.previous=e;var t=this;return e.on(\"data\",function(e){t.processChunk(e)}),e.on(\"end\",function(){t.end()}),e.on(\"error\",function(e){t.error(e)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var e=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),e=!0),this.previous&&this.previous.resume(),!e},flush:function(){},processChunk:function(e){this.push(e)},withStreamInfo:function(e,t){return this.extraStreamInfo[e]=t,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var e in this.extraStreamInfo)Object.prototype.hasOwnProperty.call(this.extraStreamInfo,e)&&(this.streamInfo[e]=this.extraStreamInfo[e])},lock:function(){if(this.isLocked)throw new Error(\"The stream '\"+this+\"' has already been used.\");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var e=\"Worker \"+this.name;return this.previous?this.previous+\" -> \"+e:e}},t.exports=n},{}],29:[function(e,t,r){\"use strict\";var h=e(\"../utils\"),i=e(\"./ConvertWorker\"),s=e(\"./GenericWorker\"),u=e(\"../base64\"),n=e(\"../support\"),a=e(\"../external\"),o=null;if(n.nodestream)try{o=e(\"../nodejs/NodejsStreamOutputAdapter\")}catch(e){}function l(e,o){return new a.Promise(function(t,r){var n=[],i=e._internalType,s=e._outputType,a=e._mimeType;e.on(\"data\",function(e,t){n.push(e),o&&o(t)}).on(\"error\",function(e){n=[],r(e)}).on(\"end\",function(){try{var e=function(e,t,r){switch(e){case\"blob\":return h.newBlob(h.transformTo(\"arraybuffer\",t),r);case\"base64\":return u.encode(t);default:return h.transformTo(e,t)}}(s,function(e,t){var r,n=0,i=null,s=0;for(r=0;r<t.length;r++)s+=t[r].length;switch(e){case\"string\":return t.join(\"\");case\"array\":return Array.prototype.concat.apply([],t);case\"uint8array\":for(i=new Uint8Array(s),r=0;r<t.length;r++)i.set(t[r],n),n+=t[r].length;return i;case\"nodebuffer\":return Buffer.concat(t);default:throw new Error(\"concat : unsupported type '\"+e+\"'\")}}(i,n),a);t(e)}catch(e){r(e)}n=[]}).resume()})}function f(e,t,r){var n=t;switch(t){case\"blob\":case\"arraybuffer\":n=\"uint8array\";break;case\"base64\":n=\"string\"}try{this._internalType=n,this._outputType=t,this._mimeType=r,h.checkSupport(n),this._worker=e.pipe(new i(n)),e.lock()}catch(e){this._worker=new s(\"error\"),this._worker.error(e)}}f.prototype={accumulate:function(e){return l(this,e)},on:function(e,t){var r=this;return\"data\"===e?this._worker.on(e,function(e){t.call(r,e.data,e.meta)}):this._worker.on(e,function(){h.delay(t,arguments,r)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(e){if(h.checkSupport(\"nodestream\"),\"nodebuffer\"!==this._outputType)throw new Error(this._outputType+\" is not supported by this method\");return new o(this,{objectMode:\"nodebuffer\"!==this._outputType},e)}},t.exports=f},{\"../base64\":1,\"../external\":6,\"../nodejs/NodejsStreamOutputAdapter\":13,\"../support\":30,\"../utils\":32,\"./ConvertWorker\":24,\"./GenericWorker\":28}],30:[function(e,t,r){\"use strict\";if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer=\"undefined\"!=typeof ArrayBuffer&&\"undefined\"!=typeof Uint8Array,r.nodebuffer=\"undefined\"!=typeof Buffer,r.uint8array=\"undefined\"!=typeof Uint8Array,\"undefined\"==typeof ArrayBuffer)r.blob=!1;else{var n=new ArrayBuffer(0);try{r.blob=0===new Blob([n],{type:\"application/zip\"}).size}catch(e){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);i.append(n),r.blob=0===i.getBlob(\"application/zip\").size}catch(e){r.blob=!1}}}try{r.nodestream=!!e(\"readable-stream\").Readable}catch(e){r.nodestream=!1}},{\"readable-stream\":16}],31:[function(e,t,s){\"use strict\";for(var o=e(\"./utils\"),h=e(\"./support\"),r=e(\"./nodejsUtils\"),n=e(\"./stream/GenericWorker\"),u=new Array(256),i=0;i<256;i++)u[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;u[254]=u[254]=1;function a(){n.call(this,\"utf-8 decode\"),this.leftOver=null}function l(){n.call(this,\"utf-8 encode\")}s.utf8encode=function(e){return h.nodebuffer?r.newBufferFrom(e,\"utf-8\"):function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=h.uint8array?new Uint8Array(o):new Array(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t}(e)},s.utf8decode=function(e){return h.nodebuffer?o.transformTo(\"nodebuffer\",e).toString(\"utf-8\"):function(e){var t,r,n,i,s=e.length,a=new Array(2*s);for(t=r=0;t<s;)if((n=e[t++])<128)a[r++]=n;else if(4<(i=u[n]))a[r++]=65533,t+=i-1;else{for(n&=2===i?31:3===i?15:7;1<i&&t<s;)n=n<<6|63&e[t++],i--;1<i?a[r++]=65533:n<65536?a[r++]=n:(n-=65536,a[r++]=55296|n>>10&1023,a[r++]=56320|1023&n)}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(e=o.transformTo(h.uint8array?\"uint8array\":\"array\",e))},o.inherits(a,n),a.prototype.processChunk=function(e){var t=o.transformTo(h.uint8array?\"uint8array\":\"array\",e.data);if(this.leftOver&&this.leftOver.length){if(h.uint8array){var r=t;(t=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),t.set(r,this.leftOver.length)}else t=this.leftOver.concat(t);this.leftOver=null}var n=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+u[e[r]]>t?r:t}(t),i=t;n!==t.length&&(h.uint8array?(i=t.subarray(0,n),this.leftOver=t.subarray(n,t.length)):(i=t.slice(0,n),this.leftOver=t.slice(n,t.length))),this.push({data:s.utf8decode(i),meta:e.meta})},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},s.Utf8DecodeWorker=a,o.inherits(l,n),l.prototype.processChunk=function(e){this.push({data:s.utf8encode(e.data),meta:e.meta})},s.Utf8EncodeWorker=l},{\"./nodejsUtils\":14,\"./stream/GenericWorker\":28,\"./support\":30,\"./utils\":32}],32:[function(e,t,a){\"use strict\";var o=e(\"./support\"),h=e(\"./base64\"),r=e(\"./nodejsUtils\"),u=e(\"./external\");function n(e){return e}function l(e,t){for(var r=0;r<e.length;++r)t[r]=255&e.charCodeAt(r);return t}e(\"setimmediate\"),a.newBlob=function(t,r){a.checkSupport(\"blob\");try{return new Blob([t],{type:r})}catch(e){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return n.append(t),n.getBlob(r)}catch(e){throw new Error(\"Bug : can't construct the Blob.\")}}};var i={stringifyByChunk:function(e,t,r){var n=[],i=0,s=e.length;if(s<=r)return String.fromCharCode.apply(null,e);for(;i<s;)\"array\"===t||\"nodebuffer\"===t?n.push(String.fromCharCode.apply(null,e.slice(i,Math.min(i+r,s)))):n.push(String.fromCharCode.apply(null,e.subarray(i,Math.min(i+r,s)))),i+=r;return n.join(\"\")},stringifyByChar:function(e){for(var t=\"\",r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t},applyCanBeUsed:{uint8array:function(){try{return o.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(e){return!1}}(),nodebuffer:function(){try{return o.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(e){return!1}}()}};function s(e){var t=65536,r=a.getTypeOf(e),n=!0;if(\"uint8array\"===r?n=i.applyCanBeUsed.uint8array:\"nodebuffer\"===r&&(n=i.applyCanBeUsed.nodebuffer),n)for(;1<t;)try{return i.stringifyByChunk(e,r,t)}catch(e){t=Math.floor(t/2)}return i.stringifyByChar(e)}function f(e,t){for(var r=0;r<e.length;r++)t[r]=e[r];return t}a.applyFromCharCode=s;var c={};c.string={string:n,array:function(e){return l(e,new Array(e.length))},arraybuffer:function(e){return c.string.uint8array(e).buffer},uint8array:function(e){return l(e,new Uint8Array(e.length))},nodebuffer:function(e){return l(e,r.allocBuffer(e.length))}},c.array={string:s,array:n,arraybuffer:function(e){return new Uint8Array(e).buffer},uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(e)}},c.arraybuffer={string:function(e){return s(new Uint8Array(e))},array:function(e){return f(new Uint8Array(e),new Array(e.byteLength))},arraybuffer:n,uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(new Uint8Array(e))}},c.uint8array={string:s,array:function(e){return f(e,new Array(e.length))},arraybuffer:function(e){return e.buffer},uint8array:n,nodebuffer:function(e){return r.newBufferFrom(e)}},c.nodebuffer={string:s,array:function(e){return f(e,new Array(e.length))},arraybuffer:function(e){return c.nodebuffer.uint8array(e).buffer},uint8array:function(e){return f(e,new Uint8Array(e.length))},nodebuffer:n},a.transformTo=function(e,t){if(t=t||\"\",!e)return t;a.checkSupport(e);var r=a.getTypeOf(t);return c[r][e](t)},a.resolve=function(e){for(var t=e.split(\"/\"),r=[],n=0;n<t.length;n++){var i=t[n];\".\"===i||\"\"===i&&0!==n&&n!==t.length-1||(\"..\"===i?r.pop():r.push(i))}return r.join(\"/\")},a.getTypeOf=function(e){return\"string\"==typeof e?\"string\":\"[object Array]\"===Object.prototype.toString.call(e)?\"array\":o.nodebuffer&&r.isBuffer(e)?\"nodebuffer\":o.uint8array&&e instanceof Uint8Array?\"uint8array\":o.arraybuffer&&e instanceof ArrayBuffer?\"arraybuffer\":void 0},a.checkSupport=function(e){if(!o[e.toLowerCase()])throw new Error(e+\" is not supported by this platform\")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function(e){var t,r,n=\"\";for(r=0;r<(e||\"\").length;r++)n+=\"\\\\x\"+((t=e.charCodeAt(r))<16?\"0\":\"\")+t.toString(16).toUpperCase();return n},a.delay=function(e,t,r){setImmediate(function(){e.apply(r||null,t||[])})},a.inherits=function(e,t){function r(){}r.prototype=t.prototype,e.prototype=new r},a.extend=function(){var e,t,r={};for(e=0;e<arguments.length;e++)for(t in arguments[e])Object.prototype.hasOwnProperty.call(arguments[e],t)&&void 0===r[t]&&(r[t]=arguments[e][t]);return r},a.prepareContent=function(r,e,n,i,s){return u.Promise.resolve(e).then(function(n){return o.blob&&(n instanceof Blob||-1!==[\"[object File]\",\"[object Blob]\"].indexOf(Object.prototype.toString.call(n)))&&\"undefined\"!=typeof FileReader?new u.Promise(function(t,r){var e=new FileReader;e.onload=function(e){t(e.target.result)},e.onerror=function(e){r(e.target.error)},e.readAsArrayBuffer(n)}):n}).then(function(e){var t=a.getTypeOf(e);return t?(\"arraybuffer\"===t?e=a.transformTo(\"uint8array\",e):\"string\"===t&&(s?e=h.decode(e):n&&!0!==i&&(e=function(e){return l(e,o.uint8array?new Uint8Array(e.length):new Array(e.length))}(e))),e):u.Promise.reject(new Error(\"Can't read the data of '\"+r+\"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\"))})}},{\"./base64\":1,\"./external\":6,\"./nodejsUtils\":14,\"./support\":30,setimmediate:54}],33:[function(e,t,r){\"use strict\";var n=e(\"./reader/readerFor\"),i=e(\"./utils\"),s=e(\"./signature\"),a=e(\"./zipEntry\"),o=e(\"./support\");function h(e){this.files=[],this.loadOptions=e}h.prototype={checkSignature:function(e){if(!this.reader.readAndCheckSignature(e)){this.reader.index-=4;var t=this.reader.readString(4);throw new Error(\"Corrupted zip or bug: unexpected signature (\"+i.pretty(t)+\", expected \"+i.pretty(e)+\")\")}},isSignature:function(e,t){var r=this.reader.index;this.reader.setIndex(e);var n=this.reader.readString(4)===t;return this.reader.setIndex(r),n},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var e=this.reader.readData(this.zipCommentLength),t=o.uint8array?\"uint8array\":\"array\",r=i.transformTo(t,e);this.zipComment=this.loadOptions.decodeFileName(r)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var e,t,r,n=this.zip64EndOfCentralSize-44;0<n;)e=this.reader.readInt(2),t=this.reader.readInt(4),r=this.reader.readData(t),this.zip64ExtensibleData[e]={id:e,length:t,value:r}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error(\"Multi-volumes zip are not supported\")},readLocalFiles:function(){var e,t;for(e=0;e<this.files.length;e++)t=this.files[e],this.reader.setIndex(t.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),t.readLocalPart(this.reader),t.handleUTF8(),t.processAttributes()},readCentralDir:function(){var e;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(e=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(e);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error(\"Corrupted zip or bug: expected \"+this.centralDirRecords+\" records in central dir, got \"+this.files.length)},readEndOfCentral:function(){var e=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(e<0)throw!this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error(\"Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html\"):new Error(\"Corrupted zip: can't find end of central directory\");this.reader.setIndex(e);var t=e;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===i.MAX_VALUE_16BITS||this.diskWithCentralDirStart===i.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===i.MAX_VALUE_16BITS||this.centralDirRecords===i.MAX_VALUE_16BITS||this.centralDirSize===i.MAX_VALUE_32BITS||this.centralDirOffset===i.MAX_VALUE_32BITS){if(this.zip64=!0,(e=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");if(this.reader.setIndex(e),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var n=t-r;if(0<n)this.isSignature(t,s.CENTRAL_FILE_HEADER)||(this.reader.zero=n);else if(n<0)throw new Error(\"Corrupted zip: missing \"+Math.abs(n)+\" bytes.\")},prepareReader:function(e){this.reader=n(e)},load:function(e){this.prepareReader(e),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},t.exports=h},{\"./reader/readerFor\":22,\"./signature\":23,\"./support\":30,\"./utils\":32,\"./zipEntry\":34}],34:[function(e,t,r){\"use strict\";var n=e(\"./reader/readerFor\"),s=e(\"./utils\"),i=e(\"./compressedObject\"),a=e(\"./crc32\"),o=e(\"./utf8\"),h=e(\"./compressions\"),u=e(\"./support\");function l(e,t){this.options=e,this.loadOptions=t}l.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(e){var t,r;if(e.skip(22),this.fileNameLength=e.readInt(2),r=e.readInt(2),this.fileName=e.readData(this.fileNameLength),e.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)\");if(null===(t=function(e){for(var t in h)if(Object.prototype.hasOwnProperty.call(h,t)&&h[t].magic===e)return h[t];return null}(this.compressionMethod)))throw new Error(\"Corrupted zip : compression \"+s.pretty(this.compressionMethod)+\" unknown (inner file : \"+s.transformTo(\"string\",this.fileName)+\")\");this.decompressed=new i(this.compressedSize,this.uncompressedSize,this.crc32,t,e.readData(this.compressedSize))},readCentralPart:function(e){this.versionMadeBy=e.readInt(2),e.skip(2),this.bitFlag=e.readInt(2),this.compressionMethod=e.readString(2),this.date=e.readDate(),this.crc32=e.readInt(4),this.compressedSize=e.readInt(4),this.uncompressedSize=e.readInt(4);var t=e.readInt(2);if(this.extraFieldsLength=e.readInt(2),this.fileCommentLength=e.readInt(2),this.diskNumberStart=e.readInt(2),this.internalFileAttributes=e.readInt(2),this.externalFileAttributes=e.readInt(4),this.localHeaderOffset=e.readInt(4),this.isEncrypted())throw new Error(\"Encrypted zip are not supported\");e.skip(t),this.readExtraFields(e),this.parseZIP64ExtraField(e),this.fileComment=e.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var e=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==e&&(this.dosPermissions=63&this.externalFileAttributes),3==e&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||\"/\"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(){if(this.extraFields[1]){var e=n(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4))}},readExtraFields:function(e){var t,r,n,i=e.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});e.index+4<i;)t=e.readInt(2),r=e.readInt(2),n=e.readData(r),this.extraFields[t]={id:t,length:r,value:n};e.setIndex(i)},handleUTF8:function(){var e=u.uint8array?\"uint8array\":\"array\";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else{var t=this.findExtraFieldUnicodePath();if(null!==t)this.fileNameStr=t;else{var r=s.transformTo(e,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r)}var n=this.findExtraFieldUnicodeComment();if(null!==n)this.fileCommentStr=n;else{var i=s.transformTo(e,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(i)}}},findExtraFieldUnicodePath:function(){var e=this.extraFields[28789];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileName)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null},findExtraFieldUnicodeComment:function(){var e=this.extraFields[25461];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileComment)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null}},t.exports=l},{\"./compressedObject\":2,\"./compressions\":3,\"./crc32\":4,\"./reader/readerFor\":22,\"./support\":30,\"./utf8\":31,\"./utils\":32}],35:[function(e,t,r){\"use strict\";function n(e,t,r){this.name=e,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=t,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions}}var s=e(\"./stream/StreamHelper\"),i=e(\"./stream/DataWorker\"),a=e(\"./utf8\"),o=e(\"./compressedObject\"),h=e(\"./stream/GenericWorker\");n.prototype={internalStream:function(e){var t=null,r=\"string\";try{if(!e)throw new Error(\"No output type specified.\");var n=\"string\"===(r=e.toLowerCase())||\"text\"===r;\"binarystring\"!==r&&\"text\"!==r||(r=\"string\"),t=this._decompressWorker();var i=!this._dataBinary;i&&!n&&(t=t.pipe(new a.Utf8EncodeWorker)),!i&&n&&(t=t.pipe(new a.Utf8DecodeWorker))}catch(e){(t=new h(\"error\")).error(e)}return new s(t,r,\"\")},async:function(e,t){return this.internalStream(e).accumulate(t)},nodeStream:function(e,t){return this.internalStream(e||\"nodebuffer\").toNodejsStream(t)},_compressWorker:function(e,t){if(this._data instanceof o&&this._data.compression.magic===e.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,e,t)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof h?this._data:new i(this._data)}};for(var u=[\"asText\",\"asBinary\",\"asNodeBuffer\",\"asUint8Array\",\"asArrayBuffer\"],l=function(){throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\")},f=0;f<u.length;f++)n.prototype[u[f]]=l;t.exports=n},{\"./compressedObject\":2,\"./stream/DataWorker\":27,\"./stream/GenericWorker\":28,\"./stream/StreamHelper\":29,\"./utf8\":31}],36:[function(e,l,t){(function(t){\"use strict\";var r,n,e=t.MutationObserver||t.WebKitMutationObserver;if(e){var i=0,s=new e(u),a=t.document.createTextNode(\"\");s.observe(a,{characterData:!0}),r=function(){a.data=i=++i%2}}else if(t.setImmediate||void 0===t.MessageChannel)r=\"document\"in t&&\"onreadystatechange\"in t.document.createElement(\"script\")?function(){var e=t.document.createElement(\"script\");e.onreadystatechange=function(){u(),e.onreadystatechange=null,e.parentNode.removeChild(e),e=null},t.document.documentElement.appendChild(e)}:function(){setTimeout(u,0)};else{var o=new t.MessageChannel;o.port1.onmessage=u,r=function(){o.port2.postMessage(0)}}var h=[];function u(){var e,t;n=!0;for(var r=h.length;r;){for(t=h,h=[],e=-1;++e<r;)t[e]();r=h.length}n=!1}l.exports=function(e){1!==h.push(e)||n||r()}}).call(this,\"undefined\"!=typeof __webpack_require__.g?__webpack_require__.g:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],37:[function(e,t,r){\"use strict\";var i=e(\"immediate\");function u(){}var l={},s=[\"REJECTED\"],a=[\"FULFILLED\"],n=[\"PENDING\"];function o(e){if(\"function\"!=typeof e)throw new TypeError(\"resolver must be a function\");this.state=n,this.queue=[],this.outcome=void 0,e!==u&&d(this,e)}function h(e,t,r){this.promise=e,\"function\"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),\"function\"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected)}function f(t,r,n){i(function(){var e;try{e=r(n)}catch(e){return l.reject(t,e)}e===t?l.reject(t,new TypeError(\"Cannot resolve promise with itself\")):l.resolve(t,e)})}function c(e){var t=e&&e.then;if(e&&(\"object\"==typeof e||\"function\"==typeof e)&&\"function\"==typeof t)return function(){t.apply(e,arguments)}}function d(t,e){var r=!1;function n(e){r||(r=!0,l.reject(t,e))}function i(e){r||(r=!0,l.resolve(t,e))}var s=p(function(){e(i,n)});\"error\"===s.status&&n(s.value)}function p(e,t){var r={};try{r.value=e(t),r.status=\"success\"}catch(e){r.status=\"error\",r.value=e}return r}(t.exports=o).prototype.finally=function(t){if(\"function\"!=typeof t)return this;var r=this.constructor;return this.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})})},o.prototype.catch=function(e){return this.then(null,e)},o.prototype.then=function(e,t){if(\"function\"!=typeof e&&this.state===a||\"function\"!=typeof t&&this.state===s)return this;var r=new this.constructor(u);this.state!==n?f(r,this.state===a?e:t,this.outcome):this.queue.push(new h(r,e,t));return r},h.prototype.callFulfilled=function(e){l.resolve(this.promise,e)},h.prototype.otherCallFulfilled=function(e){f(this.promise,this.onFulfilled,e)},h.prototype.callRejected=function(e){l.reject(this.promise,e)},h.prototype.otherCallRejected=function(e){f(this.promise,this.onRejected,e)},l.resolve=function(e,t){var r=p(c,t);if(\"error\"===r.status)return l.reject(e,r.value);var n=r.value;if(n)d(e,n);else{e.state=a,e.outcome=t;for(var i=-1,s=e.queue.length;++i<s;)e.queue[i].callFulfilled(t)}return e},l.reject=function(e,t){e.state=s,e.outcome=t;for(var r=-1,n=e.queue.length;++r<n;)e.queue[r].callRejected(t);return e},o.resolve=function(e){if(e instanceof this)return e;return l.resolve(new this(u),e)},o.reject=function(e){var t=new this(u);return l.reject(t,e)},o.all=function(e){var r=this;if(\"[object Array]\"!==Object.prototype.toString.call(e))return this.reject(new TypeError(\"must be an array\"));var n=e.length,i=!1;if(!n)return this.resolve([]);var s=new Array(n),a=0,t=-1,o=new this(u);for(;++t<n;)h(e[t],t);return o;function h(e,t){r.resolve(e).then(function(e){s[t]=e,++a!==n||i||(i=!0,l.resolve(o,s))},function(e){i||(i=!0,l.reject(o,e))})}},o.race=function(e){var t=this;if(\"[object Array]\"!==Object.prototype.toString.call(e))return this.reject(new TypeError(\"must be an array\"));var r=e.length,n=!1;if(!r)return this.resolve([]);var i=-1,s=new this(u);for(;++i<r;)a=e[i],t.resolve(a).then(function(e){n||(n=!0,l.resolve(s,e))},function(e){n||(n=!0,l.reject(s,e))});var a;return s}},{immediate:36}],38:[function(e,t,r){\"use strict\";var n={};(0,e(\"./lib/utils/common\").assign)(n,e(\"./lib/deflate\"),e(\"./lib/inflate\"),e(\"./lib/zlib/constants\")),t.exports=n},{\"./lib/deflate\":39,\"./lib/inflate\":40,\"./lib/utils/common\":41,\"./lib/zlib/constants\":44}],39:[function(e,t,r){\"use strict\";var a=e(\"./zlib/deflate\"),o=e(\"./utils/common\"),h=e(\"./utils/strings\"),i=e(\"./zlib/messages\"),s=e(\"./zlib/zstream\"),u=Object.prototype.toString,l=0,f=-1,c=0,d=8;function p(e){if(!(this instanceof p))return new p(e);this.options=o.assign({level:f,method:d,chunkSize:16384,windowBits:15,memLevel:8,strategy:c,to:\"\"},e||{});var t=this.options;t.raw&&0<t.windowBits?t.windowBits=-t.windowBits:t.gzip&&0<t.windowBits&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(r!==l)throw new Error(i[r]);if(t.header&&a.deflateSetHeader(this.strm,t.header),t.dictionary){var n;if(n=\"string\"==typeof t.dictionary?h.string2buf(t.dictionary):\"[object ArrayBuffer]\"===u.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,(r=a.deflateSetDictionary(this.strm,n))!==l)throw new Error(i[r]);this._dict_set=!0}}function n(e,t){var r=new p(t);if(r.push(e,!0),r.err)throw r.msg||i[r.err];return r.result}p.prototype.push=function(e,t){var r,n,i=this.strm,s=this.options.chunkSize;if(this.ended)return!1;n=t===~~t?t:!0===t?4:0,\"string\"==typeof e?i.input=h.string2buf(e):\"[object ArrayBuffer]\"===u.call(e)?i.input=new Uint8Array(e):i.input=e,i.next_in=0,i.avail_in=i.input.length;do{if(0===i.avail_out&&(i.output=new o.Buf8(s),i.next_out=0,i.avail_out=s),1!==(r=a.deflate(i,n))&&r!==l)return this.onEnd(r),!(this.ended=!0);0!==i.avail_out&&(0!==i.avail_in||4!==n&&2!==n)||(\"string\"===this.options.to?this.onData(h.buf2binstring(o.shrinkBuf(i.output,i.next_out))):this.onData(o.shrinkBuf(i.output,i.next_out)))}while((0<i.avail_in||0===i.avail_out)&&1!==r);return 4===n?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l):2!==n||(this.onEnd(l),!(i.avail_out=0))},p.prototype.onData=function(e){this.chunks.push(e)},p.prototype.onEnd=function(e){e===l&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},r.Deflate=p,r.deflate=n,r.deflateRaw=function(e,t){return(t=t||{}).raw=!0,n(e,t)},r.gzip=function(e,t){return(t=t||{}).gzip=!0,n(e,t)}},{\"./utils/common\":41,\"./utils/strings\":42,\"./zlib/deflate\":46,\"./zlib/messages\":51,\"./zlib/zstream\":53}],40:[function(e,t,r){\"use strict\";var c=e(\"./zlib/inflate\"),d=e(\"./utils/common\"),p=e(\"./utils/strings\"),m=e(\"./zlib/constants\"),n=e(\"./zlib/messages\"),i=e(\"./zlib/zstream\"),s=e(\"./zlib/gzheader\"),_=Object.prototype.toString;function a(e){if(!(this instanceof a))return new a(e);this.options=d.assign({chunkSize:16384,windowBits:0,to:\"\"},e||{});var t=this.options;t.raw&&0<=t.windowBits&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(0<=t.windowBits&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),15<t.windowBits&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new i,this.strm.avail_out=0;var r=c.inflateInit2(this.strm,t.windowBits);if(r!==m.Z_OK)throw new Error(n[r]);this.header=new s,c.inflateGetHeader(this.strm,this.header)}function o(e,t){var r=new a(t);if(r.push(e,!0),r.err)throw r.msg||n[r.err];return r.result}a.prototype.push=function(e,t){var r,n,i,s,a,o,h=this.strm,u=this.options.chunkSize,l=this.options.dictionary,f=!1;if(this.ended)return!1;n=t===~~t?t:!0===t?m.Z_FINISH:m.Z_NO_FLUSH,\"string\"==typeof e?h.input=p.binstring2buf(e):\"[object ArrayBuffer]\"===_.call(e)?h.input=new Uint8Array(e):h.input=e,h.next_in=0,h.avail_in=h.input.length;do{if(0===h.avail_out&&(h.output=new d.Buf8(u),h.next_out=0,h.avail_out=u),(r=c.inflate(h,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&l&&(o=\"string\"==typeof l?p.string2buf(l):\"[object ArrayBuffer]\"===_.call(l)?new Uint8Array(l):l,r=c.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===f&&(r=m.Z_OK,f=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);h.next_out&&(0!==h.avail_out&&r!==m.Z_STREAM_END&&(0!==h.avail_in||n!==m.Z_FINISH&&n!==m.Z_SYNC_FLUSH)||(\"string\"===this.options.to?(i=p.utf8border(h.output,h.next_out),s=h.next_out-i,a=p.buf2string(h.output,i),h.next_out=s,h.avail_out=u-s,s&&d.arraySet(h.output,h.output,i,s,0),this.onData(a)):this.onData(d.shrinkBuf(h.output,h.next_out)))),0===h.avail_in&&0===h.avail_out&&(f=!0)}while((0<h.avail_in||0===h.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(n=m.Z_FINISH),n===m.Z_FINISH?(r=c.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):n!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(h.avail_out=0))},a.prototype.onData=function(e){this.chunks.push(e)},a.prototype.onEnd=function(e){e===m.Z_OK&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=d.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},r.Inflate=a,r.inflate=o,r.inflateRaw=function(e,t){return(t=t||{}).raw=!0,o(e,t)},r.ungzip=o},{\"./utils/common\":41,\"./utils/strings\":42,\"./zlib/constants\":44,\"./zlib/gzheader\":47,\"./zlib/inflate\":49,\"./zlib/messages\":51,\"./zlib/zstream\":53}],41:[function(e,t,r){\"use strict\";var n=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Int32Array;r.assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var r=t.shift();if(r){if(\"object\"!=typeof r)throw new TypeError(r+\"must be non-object\");for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n])}}return e},r.shrinkBuf=function(e,t){return e.length===t?e:e.subarray?e.subarray(0,t):(e.length=t,e)};var i={arraySet:function(e,t,r,n,i){if(t.subarray&&e.subarray)e.set(t.subarray(r,r+n),i);else for(var s=0;s<n;s++)e[i+s]=t[r+s]},flattenChunks:function(e){var t,r,n,i,s,a;for(t=n=0,r=e.length;t<r;t++)n+=e[t].length;for(a=new Uint8Array(n),t=i=0,r=e.length;t<r;t++)s=e[t],a.set(s,i),i+=s.length;return a}},s={arraySet:function(e,t,r,n,i){for(var s=0;s<n;s++)e[i+s]=t[r+s]},flattenChunks:function(e){return[].concat.apply([],e)}};r.setTyped=function(e){e?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,i)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s))},r.setTyped(n)},{}],42:[function(e,t,r){\"use strict\";var h=e(\"./common\"),i=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(e){i=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){s=!1}for(var u=new h.Buf8(256),n=0;n<256;n++)u[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;function l(e,t){if(t<65537&&(e.subarray&&s||!e.subarray&&i))return String.fromCharCode.apply(null,h.shrinkBuf(e,t));for(var r=\"\",n=0;n<t;n++)r+=String.fromCharCode(e[n]);return r}u[254]=u[254]=1,r.string2buf=function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=new h.Buf8(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t},r.buf2binstring=function(e){return l(e,e.length)},r.binstring2buf=function(e){for(var t=new h.Buf8(e.length),r=0,n=t.length;r<n;r++)t[r]=e.charCodeAt(r);return t},r.buf2string=function(e,t){var r,n,i,s,a=t||e.length,o=new Array(2*a);for(r=n=0;r<a;)if((i=e[r++])<128)o[n++]=i;else if(4<(s=u[i]))o[n++]=65533,r+=s-1;else{for(i&=2===s?31:3===s?15:7;1<s&&r<a;)i=i<<6|63&e[r++],s--;1<s?o[n++]=65533:i<65536?o[n++]=i:(i-=65536,o[n++]=55296|i>>10&1023,o[n++]=56320|1023&i)}return l(o,n)},r.utf8border=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+u[e[r]]>t?r:t}},{\"./common\":41}],43:[function(e,t,r){\"use strict\";t.exports=function(e,t,r,n){for(var i=65535&e|0,s=e>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(i=i+t[n++]|0)|0,--a;);i%=65521,s%=65521}return i|s<<16|0}},{}],44:[function(e,t,r){\"use strict\";t.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(e,t,r){\"use strict\";var o=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}();t.exports=function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t[a])];return-1^e}},{}],46:[function(e,t,r){\"use strict\";var h,c=e(\"../utils/common\"),u=e(\"./trees\"),d=e(\"./adler32\"),p=e(\"./crc32\"),n=e(\"./messages\"),l=0,f=4,m=0,_=-2,g=-1,b=4,i=2,v=8,y=9,s=286,a=30,o=19,w=2*s+1,k=15,x=3,S=258,z=S+x+1,C=42,E=113,A=1,I=2,O=3,B=4;function R(e,t){return e.msg=n[t],t}function T(e){return(e<<1)-(4<e?9:0)}function D(e){for(var t=e.length;0<=--t;)e[t]=0}function F(e){var t=e.state,r=t.pending;r>e.avail_out&&(r=e.avail_out),0!==r&&(c.arraySet(e.output,t.pending_buf,t.pending_out,r,e.next_out),e.next_out+=r,t.pending_out+=r,e.total_out+=r,e.avail_out-=r,t.pending-=r,0===t.pending&&(t.pending_out=0))}function N(e,t){u._tr_flush_block(e,0<=e.block_start?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,F(e.strm)}function U(e,t){e.pending_buf[e.pending++]=t}function P(e,t){e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t}function L(e,t){var r,n,i=e.max_chain_length,s=e.strstart,a=e.prev_length,o=e.nice_match,h=e.strstart>e.w_size-z?e.strstart-(e.w_size-z):0,u=e.window,l=e.w_mask,f=e.prev,c=e.strstart+S,d=u[s+a-1],p=u[s+a];e.prev_length>=e.good_match&&(i>>=2),o>e.lookahead&&(o=e.lookahead);do{if(u[(r=t)+a]===p&&u[r+a-1]===d&&u[r]===u[s]&&u[++r]===u[s+1]){s+=2,r++;do{}while(u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&s<c);if(n=S-(c-s),s=c-S,a<n){if(e.match_start=t,o<=(a=n))break;d=u[s+a-1],p=u[s+a]}}}while((t=f[t&l])>h&&0!=--i);return a<=e.lookahead?a:e.lookahead}function j(e){var t,r,n,i,s,a,o,h,u,l,f=e.w_size;do{if(i=e.window_size-e.lookahead-e.strstart,e.strstart>=f+(f-z)){for(c.arraySet(e.window,e.window,f,f,0),e.match_start-=f,e.strstart-=f,e.block_start-=f,t=r=e.hash_size;n=e.head[--t],e.head[t]=f<=n?n-f:0,--r;);for(t=r=f;n=e.prev[--t],e.prev[t]=f<=n?n-f:0,--r;);i+=f}if(0===e.strm.avail_in)break;if(a=e.strm,o=e.window,h=e.strstart+e.lookahead,u=i,l=void 0,l=a.avail_in,u<l&&(l=u),r=0===l?0:(a.avail_in-=l,c.arraySet(o,a.input,a.next_in,l,h),1===a.state.wrap?a.adler=d(a.adler,o,l,h):2===a.state.wrap&&(a.adler=p(a.adler,o,l,h)),a.next_in+=l,a.total_in+=l,l),e.lookahead+=r,e.lookahead+e.insert>=x)for(s=e.strstart-e.insert,e.ins_h=e.window[s],e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+1])&e.hash_mask;e.insert&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+x-1])&e.hash_mask,e.prev[s&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=s,s++,e.insert--,!(e.lookahead+e.insert<x)););}while(e.lookahead<z&&0!==e.strm.avail_in)}function Z(e,t){for(var r,n;;){if(e.lookahead<z){if(j(e),e.lookahead<z&&t===l)return A;if(0===e.lookahead)break}if(r=0,e.lookahead>=x&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==r&&e.strstart-r<=e.w_size-z&&(e.match_length=L(e,r)),e.match_length>=x)if(n=u._tr_tally(e,e.strstart-e.match_start,e.match_length-x),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=x){for(e.match_length--;e.strstart++,e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart,0!=--e.match_length;);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask;else n=u._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(n&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=e.strstart<x-1?e.strstart:x-1,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}function W(e,t){for(var r,n,i;;){if(e.lookahead<z){if(j(e),e.lookahead<z&&t===l)return A;if(0===e.lookahead)break}if(r=0,e.lookahead>=x&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=x-1,0!==r&&e.prev_length<e.max_lazy_match&&e.strstart-r<=e.w_size-z&&(e.match_length=L(e,r),e.match_length<=5&&(1===e.strategy||e.match_length===x&&4096<e.strstart-e.match_start)&&(e.match_length=x-1)),e.prev_length>=x&&e.match_length<=e.prev_length){for(i=e.strstart+e.lookahead-x,n=u._tr_tally(e,e.strstart-1-e.prev_match,e.prev_length-x),e.lookahead-=e.prev_length-1,e.prev_length-=2;++e.strstart<=i&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!=--e.prev_length;);if(e.match_available=0,e.match_length=x-1,e.strstart++,n&&(N(e,!1),0===e.strm.avail_out))return A}else if(e.match_available){if((n=u._tr_tally(e,0,e.window[e.strstart-1]))&&N(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return A}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(n=u._tr_tally(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<x-1?e.strstart:x-1,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}function M(e,t,r,n,i){this.good_length=e,this.max_lazy=t,this.nice_length=r,this.max_chain=n,this.func=i}function H(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=v,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new c.Buf16(2*w),this.dyn_dtree=new c.Buf16(2*(2*a+1)),this.bl_tree=new c.Buf16(2*(2*o+1)),D(this.dyn_ltree),D(this.dyn_dtree),D(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new c.Buf16(k+1),this.heap=new c.Buf16(2*s+1),D(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new c.Buf16(2*s+1),D(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function G(e){var t;return e&&e.state?(e.total_in=e.total_out=0,e.data_type=i,(t=e.state).pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?C:E,e.adler=2===t.wrap?0:1,t.last_flush=l,u._tr_init(t),m):R(e,_)}function K(e){var t=G(e);return t===m&&function(e){e.window_size=2*e.w_size,D(e.head),e.max_lazy_match=h[e.level].max_lazy,e.good_match=h[e.level].good_length,e.nice_match=h[e.level].nice_length,e.max_chain_length=h[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=x-1,e.match_available=0,e.ins_h=0}(e.state),t}function Y(e,t,r,n,i,s){if(!e)return _;var a=1;if(t===g&&(t=6),n<0?(a=0,n=-n):15<n&&(a=2,n-=16),i<1||y<i||r!==v||n<8||15<n||t<0||9<t||s<0||b<s)return R(e,_);8===n&&(n=9);var o=new H;return(e.state=o).strm=e,o.wrap=a,o.gzhead=null,o.w_bits=n,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=i+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+x-1)/x),o.window=new c.Buf8(2*o.w_size),o.head=new c.Buf16(o.hash_size),o.prev=new c.Buf16(o.w_size),o.lit_bufsize=1<<i+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new c.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=t,o.strategy=s,o.method=r,K(e)}h=[new M(0,0,0,0,function(e,t){var r=65535;for(r>e.pending_buf_size-5&&(r=e.pending_buf_size-5);;){if(e.lookahead<=1){if(j(e),0===e.lookahead&&t===l)return A;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;var n=e.block_start+r;if((0===e.strstart||e.strstart>=n)&&(e.lookahead=e.strstart-n,e.strstart=n,N(e,!1),0===e.strm.avail_out))return A;if(e.strstart-e.block_start>=e.w_size-z&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=0,t===f?(N(e,!0),0===e.strm.avail_out?O:B):(e.strstart>e.block_start&&(N(e,!1),e.strm.avail_out),A)}),new M(4,4,8,4,Z),new M(4,5,16,8,Z),new M(4,6,32,32,Z),new M(4,4,16,16,W),new M(8,16,32,32,W),new M(8,16,128,128,W),new M(8,32,128,256,W),new M(32,128,258,1024,W),new M(32,258,258,4096,W)],r.deflateInit=function(e,t){return Y(e,t,v,15,8,0)},r.deflateInit2=Y,r.deflateReset=K,r.deflateResetKeep=G,r.deflateSetHeader=function(e,t){return e&&e.state?2!==e.state.wrap?_:(e.state.gzhead=t,m):_},r.deflate=function(e,t){var r,n,i,s;if(!e||!e.state||5<t||t<0)return e?R(e,_):_;if(n=e.state,!e.output||!e.input&&0!==e.avail_in||666===n.status&&t!==f)return R(e,0===e.avail_out?-5:_);if(n.strm=e,r=n.last_flush,n.last_flush=t,n.status===C)if(2===n.wrap)e.adler=0,U(n,31),U(n,139),U(n,8),n.gzhead?(U(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),U(n,255&n.gzhead.time),U(n,n.gzhead.time>>8&255),U(n,n.gzhead.time>>16&255),U(n,n.gzhead.time>>24&255),U(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),U(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(U(n,255&n.gzhead.extra.length),U(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=p(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=69):(U(n,0),U(n,0),U(n,0),U(n,0),U(n,0),U(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),U(n,3),n.status=E);else{var a=v+(n.w_bits-8<<4)<<8;a|=(2<=n.strategy||n.level<2?0:n.level<6?1:6===n.level?2:3)<<6,0!==n.strstart&&(a|=32),a+=31-a%31,n.status=E,P(n,a),0!==n.strstart&&(P(n,e.adler>>>16),P(n,65535&e.adler)),e.adler=1}if(69===n.status)if(n.gzhead.extra){for(i=n.pending;n.gzindex<(65535&n.gzhead.extra.length)&&(n.pending!==n.pending_buf_size||(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),F(e),i=n.pending,n.pending!==n.pending_buf_size));)U(n,255&n.gzhead.extra[n.gzindex]),n.gzindex++;n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),n.gzindex===n.gzhead.extra.length&&(n.gzindex=0,n.status=73)}else n.status=73;if(73===n.status)if(n.gzhead.name){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),F(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,U(n,s)}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.gzindex=0,n.status=91)}else n.status=91;if(91===n.status)if(n.gzhead.comment){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),F(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,U(n,s)}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.status=103)}else n.status=103;if(103===n.status&&(n.gzhead.hcrc?(n.pending+2>n.pending_buf_size&&F(e),n.pending+2<=n.pending_buf_size&&(U(n,255&e.adler),U(n,e.adler>>8&255),e.adler=0,n.status=E)):n.status=E),0!==n.pending){if(F(e),0===e.avail_out)return n.last_flush=-1,m}else if(0===e.avail_in&&T(t)<=T(r)&&t!==f)return R(e,-5);if(666===n.status&&0!==e.avail_in)return R(e,-5);if(0!==e.avail_in||0!==n.lookahead||t!==l&&666!==n.status){var o=2===n.strategy?function(e,t){for(var r;;){if(0===e.lookahead&&(j(e),0===e.lookahead)){if(t===l)return A;break}if(e.match_length=0,r=u._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,r&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=0,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}(n,t):3===n.strategy?function(e,t){for(var r,n,i,s,a=e.window;;){if(e.lookahead<=S){if(j(e),e.lookahead<=S&&t===l)return A;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=x&&0<e.strstart&&(n=a[i=e.strstart-1])===a[++i]&&n===a[++i]&&n===a[++i]){s=e.strstart+S;do{}while(n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&i<s);e.match_length=S-(s-i),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=x?(r=u._tr_tally(e,1,e.match_length-x),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(r=u._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),r&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=0,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}(n,t):h[n.level].func(n,t);if(o!==O&&o!==B||(n.status=666),o===A||o===O)return 0===e.avail_out&&(n.last_flush=-1),m;if(o===I&&(1===t?u._tr_align(n):5!==t&&(u._tr_stored_block(n,0,0,!1),3===t&&(D(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),F(e),0===e.avail_out))return n.last_flush=-1,m}return t!==f?m:n.wrap<=0?1:(2===n.wrap?(U(n,255&e.adler),U(n,e.adler>>8&255),U(n,e.adler>>16&255),U(n,e.adler>>24&255),U(n,255&e.total_in),U(n,e.total_in>>8&255),U(n,e.total_in>>16&255),U(n,e.total_in>>24&255)):(P(n,e.adler>>>16),P(n,65535&e.adler)),F(e),0<n.wrap&&(n.wrap=-n.wrap),0!==n.pending?m:1)},r.deflateEnd=function(e){var t;return e&&e.state?(t=e.state.status)!==C&&69!==t&&73!==t&&91!==t&&103!==t&&t!==E&&666!==t?R(e,_):(e.state=null,t===E?R(e,-3):m):_},r.deflateSetDictionary=function(e,t){var r,n,i,s,a,o,h,u,l=t.length;if(!e||!e.state)return _;if(2===(s=(r=e.state).wrap)||1===s&&r.status!==C||r.lookahead)return _;for(1===s&&(e.adler=d(e.adler,t,l,0)),r.wrap=0,l>=r.w_size&&(0===s&&(D(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new c.Buf8(r.w_size),c.arraySet(u,t,l-r.w_size,r.w_size,0),t=u,l=r.w_size),a=e.avail_in,o=e.next_in,h=e.input,e.avail_in=l,e.next_in=0,e.input=t,j(r);r.lookahead>=x;){for(n=r.strstart,i=r.lookahead-(x-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[n+x-1])&r.hash_mask,r.prev[n&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=n,n++,--i;);r.strstart=n,r.lookahead=x-1,j(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=x-1,r.match_available=0,e.next_in=o,e.input=h,e.avail_in=a,r.wrap=s,m},r.deflateInfo=\"pako deflate (from Nodeca project)\"},{\"../utils/common\":41,\"./adler32\":43,\"./crc32\":45,\"./messages\":51,\"./trees\":52}],47:[function(e,t,r){\"use strict\";t.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name=\"\",this.comment=\"\",this.hcrc=0,this.done=!1}},{}],48:[function(e,t,r){\"use strict\";t.exports=function(e,t){var r,n,i,s,a,o,h,u,l,f,c,d,p,m,_,g,b,v,y,w,k,x,S,z,C;r=e.state,n=e.next_in,z=e.input,i=n+(e.avail_in-5),s=e.next_out,C=e.output,a=s-(t-e.avail_out),o=s+(e.avail_out-257),h=r.dmax,u=r.wsize,l=r.whave,f=r.wnext,c=r.window,d=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,b=(1<<r.distbits)-1;e:do{p<15&&(d+=z[n++]<<p,p+=8,d+=z[n++]<<p,p+=8),v=m[d&g];t:for(;;){if(d>>>=y=v>>>24,p-=y,0===(y=v>>>16&255))C[s++]=65535&v;else{if(!(16&y)){if(0==(64&y)){v=m[(65535&v)+(d&(1<<y)-1)];continue t}if(32&y){r.mode=12;break e}e.msg=\"invalid literal/length code\",r.mode=30;break e}w=65535&v,(y&=15)&&(p<y&&(d+=z[n++]<<p,p+=8),w+=d&(1<<y)-1,d>>>=y,p-=y),p<15&&(d+=z[n++]<<p,p+=8,d+=z[n++]<<p,p+=8),v=_[d&b];r:for(;;){if(d>>>=y=v>>>24,p-=y,!(16&(y=v>>>16&255))){if(0==(64&y)){v=_[(65535&v)+(d&(1<<y)-1)];continue r}e.msg=\"invalid distance code\",r.mode=30;break e}if(k=65535&v,p<(y&=15)&&(d+=z[n++]<<p,(p+=8)<y&&(d+=z[n++]<<p,p+=8)),h<(k+=d&(1<<y)-1)){e.msg=\"invalid distance too far back\",r.mode=30;break e}if(d>>>=y,p-=y,(y=s-a)<k){if(l<(y=k-y)&&r.sane){e.msg=\"invalid distance too far back\",r.mode=30;break e}if(S=c,(x=0)===f){if(x+=u-y,y<w){for(w-=y;C[s++]=c[x++],--y;);x=s-k,S=C}}else if(f<y){if(x+=u+f-y,(y-=f)<w){for(w-=y;C[s++]=c[x++],--y;);if(x=0,f<w){for(w-=y=f;C[s++]=c[x++],--y;);x=s-k,S=C}}}else if(x+=f-y,y<w){for(w-=y;C[s++]=c[x++],--y;);x=s-k,S=C}for(;2<w;)C[s++]=S[x++],C[s++]=S[x++],C[s++]=S[x++],w-=3;w&&(C[s++]=S[x++],1<w&&(C[s++]=S[x++]))}else{for(x=s-k;C[s++]=C[x++],C[s++]=C[x++],C[s++]=C[x++],2<(w-=3););w&&(C[s++]=C[x++],1<w&&(C[s++]=C[x++]))}break}}break}}while(n<i&&s<o);n-=w=p>>3,d&=(1<<(p-=w<<3))-1,e.next_in=n,e.next_out=s,e.avail_in=n<i?i-n+5:5-(n-i),e.avail_out=s<o?o-s+257:257-(s-o),r.hold=d,r.bits=p}},{}],49:[function(e,t,r){\"use strict\";var I=e(\"../utils/common\"),O=e(\"./adler32\"),B=e(\"./crc32\"),R=e(\"./inffast\"),T=e(\"./inftrees\"),D=1,F=2,N=0,U=-2,P=1,n=852,i=592;function L(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function a(e){var t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg=\"\",t.wrap&&(e.adler=1&t.wrap),t.mode=P,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new I.Buf32(n),t.distcode=t.distdyn=new I.Buf32(i),t.sane=1,t.back=-1,N):U}function o(e){var t;return e&&e.state?((t=e.state).wsize=0,t.whave=0,t.wnext=0,a(e)):U}function h(e,t){var r,n;return e&&e.state?(n=e.state,t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||15<t)?U:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,o(e))):U}function u(e,t){var r,n;return e?(n=new s,(e.state=n).window=null,(r=h(e,t))!==N&&(e.state=null),r):U}var l,f,c=!0;function j(e){if(c){var t;for(l=new I.Buf32(512),f=new I.Buf32(32),t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(T(D,e.lens,0,288,l,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;T(F,e.lens,0,32,f,0,e.work,{bits:5}),c=!1}e.lencode=l,e.lenbits=9,e.distcode=f,e.distbits=5}function Z(e,t,r,n){var i,s=e.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),n>=s.wsize?(I.arraySet(s.window,t,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(n<(i=s.wsize-s.wnext)&&(i=n),I.arraySet(s.window,t,r-n,i,s.wnext),(n-=i)?(I.arraySet(s.window,t,r-n,n,0),s.wnext=n,s.whave=s.wsize):(s.wnext+=i,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=i))),0}r.inflateReset=o,r.inflateReset2=h,r.inflateResetKeep=a,r.inflateInit=function(e){return u(e,15)},r.inflateInit2=u,r.inflate=function(e,t){var r,n,i,s,a,o,h,u,l,f,c,d,p,m,_,g,b,v,y,w,k,x,S,z,C=0,E=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return U;12===(r=e.state).mode&&(r.mode=13),a=e.next_out,i=e.output,h=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,u=r.hold,l=r.bits,f=o,c=h,x=N;e:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(2&r.wrap&&35615===u){E[r.check=0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0),l=u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&u)<<8)+(u>>8))%31){e.msg=\"incorrect header check\",r.mode=30;break}if(8!=(15&u)){e.msg=\"unknown compression method\",r.mode=30;break}if(l-=4,k=8+(15&(u>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){e.msg=\"invalid window size\",r.mode=30;break}r.dmax=1<<k,e.adler=r.check=1,r.mode=512&u?10:12,l=u=0;break;case 2:for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(r.flags=u,8!=(255&r.flags)){e.msg=\"unknown compression method\",r.mode=30;break}if(57344&r.flags){e.msg=\"unknown header flags set\",r.mode=30;break}r.head&&(r.head.text=u>>8&1),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=3;case 3:for(;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}r.head&&(r.head.time=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,E[2]=u>>>16&255,E[3]=u>>>24&255,r.check=B(r.check,E,4,0)),l=u=0,r.mode=4;case 4:for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}r.head&&(r.head.xflags=255&u,r.head.os=u>>8),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=5;case 5:if(1024&r.flags){for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}r.length=u,r.head&&(r.head.extra_len=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(d=r.length)&&(d=o),d&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,n,s,d,k)),512&r.flags&&(r.check=B(r.check,n,d,s)),o-=d,s+=d,r.length-=d),r.length))break e;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break e;for(d=0;k=n[s+d++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&d<o;);if(512&r.flags&&(r.check=B(r.check,n,d,s)),o-=d,s+=d,k)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break e;for(d=0;k=n[s+d++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&d<o;);if(512&r.flags&&(r.check=B(r.check,n,d,s)),o-=d,s+=d,k)break e}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(u!==(65535&r.check)){e.msg=\"header crc mismatch\",r.mode=30;break}l=u=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=12;break;case 10:for(;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}e.adler=r.check=L(u),l=u=0,r.mode=11;case 11:if(0===r.havedict)return e.next_out=a,e.avail_out=h,e.next_in=s,e.avail_in=o,r.hold=u,r.bits=l,2;e.adler=r.check=1,r.mode=12;case 12:if(5===t||6===t)break e;case 13:if(r.last){u>>>=7&l,l-=7&l,r.mode=27;break}for(;l<3;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}switch(r.last=1&u,l-=1,3&(u>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==t)break;u>>>=2,l-=2;break e;case 2:r.mode=17;break;case 3:e.msg=\"invalid block type\",r.mode=30}u>>>=2,l-=2;break;case 14:for(u>>>=7&l,l-=7&l;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if((65535&u)!=(u>>>16^65535)){e.msg=\"invalid stored block lengths\",r.mode=30;break}if(r.length=65535&u,l=u=0,r.mode=15,6===t)break e;case 15:r.mode=16;case 16:if(d=r.length){if(o<d&&(d=o),h<d&&(d=h),0===d)break e;I.arraySet(i,n,s,d,a),o-=d,s+=d,h-=d,a+=d,r.length-=d;break}r.mode=12;break;case 17:for(;l<14;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(r.nlen=257+(31&u),u>>>=5,l-=5,r.ndist=1+(31&u),u>>>=5,l-=5,r.ncode=4+(15&u),u>>>=4,l-=4,286<r.nlen||30<r.ndist){e.msg=\"too many length or distance symbols\",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;l<3;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}r.lens[A[r.have++]]=7&u,u>>>=3,l-=3}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=T(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg=\"invalid code lengths set\",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(b<16)u>>>=_,l-=_,r.lens[r.have++]=b;else{if(16===b){for(z=_+2;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(u>>>=_,l-=_,0===r.have){e.msg=\"invalid bit length repeat\",r.mode=30;break}k=r.lens[r.have-1],d=3+(3&u),u>>>=2,l-=2}else if(17===b){for(z=_+3;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}l-=_,k=0,d=3+(7&(u>>>=_)),u>>>=3,l-=3}else{for(z=_+7;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}l-=_,k=0,d=11+(127&(u>>>=_)),u>>>=7,l-=7}if(r.have+d>r.nlen+r.ndist){e.msg=\"invalid bit length repeat\",r.mode=30;break}for(;d--;)r.lens[r.have++]=k}}if(30===r.mode)break;if(0===r.lens[256]){e.msg=\"invalid code -- missing end-of-block\",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=T(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg=\"invalid literal/lengths set\",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=T(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){e.msg=\"invalid distances set\",r.mode=30;break}if(r.mode=20,6===t)break e;case 20:r.mode=21;case 21:if(6<=o&&258<=h){e.next_out=a,e.avail_out=h,e.next_in=s,e.avail_in=o,r.hold=u,r.bits=l,R(e,c),a=e.next_out,i=e.output,h=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,u=r.hold,l=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(g&&0==(240&g)){for(v=_,y=g,w=b;g=(C=r.lencode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,r.length=b,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){e.msg=\"invalid literal/length code\",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}r.length+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;g=(C=r.distcode[u&(1<<r.distbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(0==(240&g)){for(v=_,y=g,w=b;g=(C=r.distcode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,64&g){e.msg=\"invalid distance code\",r.mode=30;break}r.offset=b,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}r.offset+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg=\"invalid distance too far back\",r.mode=30;break}r.mode=25;case 25:if(0===h)break e;if(d=c-h,r.offset>d){if((d=r.offset-d)>r.whave&&r.sane){e.msg=\"invalid distance too far back\",r.mode=30;break}p=d>r.wnext?(d-=r.wnext,r.wsize-d):r.wnext-d,d>r.length&&(d=r.length),m=r.window}else m=i,p=a-r.offset,d=r.length;for(h<d&&(d=h),h-=d,r.length-=d;i[a++]=m[p++],--d;);0===r.length&&(r.mode=21);break;case 26:if(0===h)break e;i[a++]=r.length,h--,r.mode=21;break;case 27:if(r.wrap){for(;l<32;){if(0===o)break e;o--,u|=n[s++]<<l,l+=8}if(c-=h,e.total_out+=c,r.total+=c,c&&(e.adler=r.check=r.flags?B(r.check,i,c,a-c):O(r.check,i,c,a-c)),c=h,(r.flags?u:L(u))!==r.check){e.msg=\"incorrect data check\",r.mode=30;break}l=u=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(u!==(4294967295&r.total)){e.msg=\"incorrect length check\",r.mode=30;break}l=u=0}r.mode=29;case 29:x=1;break e;case 30:x=-3;break e;case 31:return-4;case 32:default:return U}return e.next_out=a,e.avail_out=h,e.next_in=s,e.avail_in=o,r.hold=u,r.bits=l,(r.wsize||c!==e.avail_out&&r.mode<30&&(r.mode<27||4!==t))&&Z(e,e.output,e.next_out,c-e.avail_out)?(r.mode=31,-4):(f-=e.avail_in,c-=e.avail_out,e.total_in+=f,e.total_out+=c,r.total+=c,r.wrap&&c&&(e.adler=r.check=r.flags?B(r.check,i,c,e.next_out-c):O(r.check,i,c,e.next_out-c)),e.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==f&&0===c||4===t)&&x===N&&(x=-5),x)},r.inflateEnd=function(e){if(!e||!e.state)return U;var t=e.state;return t.window&&(t.window=null),e.state=null,N},r.inflateGetHeader=function(e,t){var r;return e&&e.state?0==(2&(r=e.state).wrap)?U:((r.head=t).done=!1,N):U},r.inflateSetDictionary=function(e,t){var r,n=t.length;return e&&e.state?0!==(r=e.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,t,n,0)!==r.check?-3:Z(e,t,n,n)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo=\"pako inflate (from Nodeca project)\"},{\"../utils/common\":41,\"./adler32\":43,\"./crc32\":45,\"./inffast\":48,\"./inftrees\":50}],50:[function(e,t,r){\"use strict\";var D=e(\"../utils/common\"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];t.exports=function(e,t,r,n,i,s,a,o){var h,u,l,f,c,d,p,m,_,g=o.bits,b=0,v=0,y=0,w=0,k=0,x=0,S=0,z=0,C=0,E=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),R=null,T=0;for(b=0;b<=15;b++)O[b]=0;for(v=0;v<n;v++)O[t[r+v]]++;for(k=g,w=15;1<=w&&0===O[w];w--);if(w<k&&(k=w),0===w)return i[s++]=20971520,i[s++]=20971520,o.bits=1,0;for(y=1;y<w&&0===O[y];y++);for(k<y&&(k=y),b=z=1;b<=15;b++)if(z<<=1,(z-=O[b])<0)return-1;if(0<z&&(0===e||1!==w))return-1;for(B[1]=0,b=1;b<15;b++)B[b+1]=B[b]+O[b];for(v=0;v<n;v++)0!==t[r+v]&&(a[B[t[r+v]]++]=v);if(d=0===e?(A=R=a,19):1===e?(A=F,I-=257,R=N,T-=257,256):(A=U,R=P,-1),b=y,c=s,S=v=E=0,l=-1,f=(C=1<<(x=k))-1,1===e&&852<C||2===e&&592<C)return 1;for(;;){for(p=b-S,_=a[v]<d?(m=0,a[v]):a[v]>d?(m=R[T+a[v]],A[I+a[v]]):(m=96,0),h=1<<b-S,y=u=1<<x;i[c+(E>>S)+(u-=h)]=p<<24|m<<16|_|0,0!==u;);for(h=1<<b-1;E&h;)h>>=1;if(0!==h?(E&=h-1,E+=h):E=0,v++,0==--O[b]){if(b===w)break;b=t[r+a[v]]}if(k<b&&(E&f)!==l){for(0===S&&(S=k),c+=y,z=1<<(x=b-S);x+S<w&&!((z-=O[x+S])<=0);)x++,z<<=1;if(C+=1<<x,1===e&&852<C||2===e&&592<C)return 1;i[l=E&f]=k<<24|x<<16|c-s|0}}return 0!==E&&(i[c+E]=b-S<<24|64<<16|0),o.bits=k,0}},{\"../utils/common\":41}],51:[function(e,t,r){\"use strict\";t.exports={2:\"need dictionary\",1:\"stream end\",0:\"\",\"-1\":\"file error\",\"-2\":\"stream error\",\"-3\":\"data error\",\"-4\":\"insufficient memory\",\"-5\":\"buffer error\",\"-6\":\"incompatible version\"}},{}],52:[function(e,t,r){\"use strict\";var i=e(\"../utils/common\"),o=0,h=1;function n(e){for(var t=e.length;0<=--t;)e[t]=0}var s=0,a=29,u=256,l=u+1+a,f=30,c=19,_=2*l+1,g=15,d=16,p=7,m=256,b=16,v=17,y=18,w=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],k=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],x=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],S=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=new Array(2*(l+2));n(z);var C=new Array(2*f);n(C);var E=new Array(512);n(E);var A=new Array(256);n(A);var I=new Array(a);n(I);var O,B,R,T=new Array(f);function D(e,t,r,n,i){this.static_tree=e,this.extra_bits=t,this.extra_base=r,this.elems=n,this.max_length=i,this.has_stree=e&&e.length}function F(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t}function N(e){return e<256?E[e]:E[256+(e>>>7)]}function U(e,t){e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255}function P(e,t,r){e.bi_valid>d-r?(e.bi_buf|=t<<e.bi_valid&65535,U(e,e.bi_buf),e.bi_buf=t>>d-e.bi_valid,e.bi_valid+=r-d):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=r)}function L(e,t,r){P(e,r[2*t],r[2*t+1])}function j(e,t){for(var r=0;r|=1&e,e>>>=1,r<<=1,0<--t;);return r>>>1}function Z(e,t,r){var n,i,s=new Array(g+1),a=0;for(n=1;n<=g;n++)s[n]=a=a+r[n-1]<<1;for(i=0;i<=t;i++){var o=e[2*i+1];0!==o&&(e[2*i]=j(s[o]++,o))}}function W(e){var t;for(t=0;t<l;t++)e.dyn_ltree[2*t]=0;for(t=0;t<f;t++)e.dyn_dtree[2*t]=0;for(t=0;t<c;t++)e.bl_tree[2*t]=0;e.dyn_ltree[2*m]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0}function M(e){8<e.bi_valid?U(e,e.bi_buf):0<e.bi_valid&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0}function H(e,t,r,n){var i=2*t,s=2*r;return e[i]<e[s]||e[i]===e[s]&&n[t]<=n[r]}function G(e,t,r){for(var n=e.heap[r],i=r<<1;i<=e.heap_len&&(i<e.heap_len&&H(t,e.heap[i+1],e.heap[i],e.depth)&&i++,!H(t,n,e.heap[i],e.depth));)e.heap[r]=e.heap[i],r=i,i<<=1;e.heap[r]=n}function K(e,t,r){var n,i,s,a,o=0;if(0!==e.last_lit)for(;n=e.pending_buf[e.d_buf+2*o]<<8|e.pending_buf[e.d_buf+2*o+1],i=e.pending_buf[e.l_buf+o],o++,0===n?L(e,i,t):(L(e,(s=A[i])+u+1,t),0!==(a=w[s])&&P(e,i-=I[s],a),L(e,s=N(--n),r),0!==(a=k[s])&&P(e,n-=T[s],a)),o<e.last_lit;);L(e,m,t)}function Y(e,t){var r,n,i,s=t.dyn_tree,a=t.stat_desc.static_tree,o=t.stat_desc.has_stree,h=t.stat_desc.elems,u=-1;for(e.heap_len=0,e.heap_max=_,r=0;r<h;r++)0!==s[2*r]?(e.heap[++e.heap_len]=u=r,e.depth[r]=0):s[2*r+1]=0;for(;e.heap_len<2;)s[2*(i=e.heap[++e.heap_len]=u<2?++u:0)]=1,e.depth[i]=0,e.opt_len--,o&&(e.static_len-=a[2*i+1]);for(t.max_code=u,r=e.heap_len>>1;1<=r;r--)G(e,s,r);for(i=h;r=e.heap[1],e.heap[1]=e.heap[e.heap_len--],G(e,s,1),n=e.heap[1],e.heap[--e.heap_max]=r,e.heap[--e.heap_max]=n,s[2*i]=s[2*r]+s[2*n],e.depth[i]=(e.depth[r]>=e.depth[n]?e.depth[r]:e.depth[n])+1,s[2*r+1]=s[2*n+1]=i,e.heap[1]=i++,G(e,s,1),2<=e.heap_len;);e.heap[--e.heap_max]=e.heap[1],function(e,t){var r,n,i,s,a,o,h=t.dyn_tree,u=t.max_code,l=t.stat_desc.static_tree,f=t.stat_desc.has_stree,c=t.stat_desc.extra_bits,d=t.stat_desc.extra_base,p=t.stat_desc.max_length,m=0;for(s=0;s<=g;s++)e.bl_count[s]=0;for(h[2*e.heap[e.heap_max]+1]=0,r=e.heap_max+1;r<_;r++)p<(s=h[2*h[2*(n=e.heap[r])+1]+1]+1)&&(s=p,m++),h[2*n+1]=s,u<n||(e.bl_count[s]++,a=0,d<=n&&(a=c[n-d]),o=h[2*n],e.opt_len+=o*(s+a),f&&(e.static_len+=o*(l[2*n+1]+a)));if(0!==m){do{for(s=p-1;0===e.bl_count[s];)s--;e.bl_count[s]--,e.bl_count[s+1]+=2,e.bl_count[p]--,m-=2}while(0<m);for(s=p;0!==s;s--)for(n=e.bl_count[s];0!==n;)u<(i=e.heap[--r])||(h[2*i+1]!==s&&(e.opt_len+=(s-h[2*i+1])*h[2*i],h[2*i+1]=s),n--)}}(e,t),Z(s,u,e.bl_count)}function X(e,t,r){var n,i,s=-1,a=t[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),t[2*(r+1)+1]=65535,n=0;n<=r;n++)i=a,a=t[2*(n+1)+1],++o<h&&i===a||(o<u?e.bl_tree[2*i]+=o:0!==i?(i!==s&&e.bl_tree[2*i]++,e.bl_tree[2*b]++):o<=10?e.bl_tree[2*v]++:e.bl_tree[2*y]++,s=i,u=(o=0)===a?(h=138,3):i===a?(h=6,3):(h=7,4))}function V(e,t,r){var n,i,s=-1,a=t[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),n=0;n<=r;n++)if(i=a,a=t[2*(n+1)+1],!(++o<h&&i===a)){if(o<u)for(;L(e,i,e.bl_tree),0!=--o;);else 0!==i?(i!==s&&(L(e,i,e.bl_tree),o--),L(e,b,e.bl_tree),P(e,o-3,2)):o<=10?(L(e,v,e.bl_tree),P(e,o-3,3)):(L(e,y,e.bl_tree),P(e,o-11,7));s=i,u=(o=0)===a?(h=138,3):i===a?(h=6,3):(h=7,4)}}n(T);var q=!1;function J(e,t,r,n){P(e,(s<<1)+(n?1:0),3),function(e,t,r,n){M(e),n&&(U(e,r),U(e,~r)),i.arraySet(e.pending_buf,e.window,t,r,e.pending),e.pending+=r}(e,t,r,!0)}r._tr_init=function(e){q||(function(){var e,t,r,n,i,s=new Array(g+1);for(n=r=0;n<a-1;n++)for(I[n]=r,e=0;e<1<<w[n];e++)A[r++]=n;for(A[r-1]=n,n=i=0;n<16;n++)for(T[n]=i,e=0;e<1<<k[n];e++)E[i++]=n;for(i>>=7;n<f;n++)for(T[n]=i<<7,e=0;e<1<<k[n]-7;e++)E[256+i++]=n;for(t=0;t<=g;t++)s[t]=0;for(e=0;e<=143;)z[2*e+1]=8,e++,s[8]++;for(;e<=255;)z[2*e+1]=9,e++,s[9]++;for(;e<=279;)z[2*e+1]=7,e++,s[7]++;for(;e<=287;)z[2*e+1]=8,e++,s[8]++;for(Z(z,l+1,s),e=0;e<f;e++)C[2*e+1]=5,C[2*e]=j(e,5);O=new D(z,w,u+1,l,g),B=new D(C,k,0,f,g),R=new D(new Array(0),x,0,c,p)}(),q=!0),e.l_desc=new F(e.dyn_ltree,O),e.d_desc=new F(e.dyn_dtree,B),e.bl_desc=new F(e.bl_tree,R),e.bi_buf=0,e.bi_valid=0,W(e)},r._tr_stored_block=J,r._tr_flush_block=function(e,t,r,n){var i,s,a=0;0<e.level?(2===e.strm.data_type&&(e.strm.data_type=function(e){var t,r=4093624447;for(t=0;t<=31;t++,r>>>=1)if(1&r&&0!==e.dyn_ltree[2*t])return o;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return h;for(t=32;t<u;t++)if(0!==e.dyn_ltree[2*t])return h;return o}(e)),Y(e,e.l_desc),Y(e,e.d_desc),a=function(e){var t;for(X(e,e.dyn_ltree,e.l_desc.max_code),X(e,e.dyn_dtree,e.d_desc.max_code),Y(e,e.bl_desc),t=c-1;3<=t&&0===e.bl_tree[2*S[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t}(e),i=e.opt_len+3+7>>>3,(s=e.static_len+3+7>>>3)<=i&&(i=s)):i=s=r+5,r+4<=i&&-1!==t?J(e,t,r,n):4===e.strategy||s===i?(P(e,2+(n?1:0),3),K(e,z,C)):(P(e,4+(n?1:0),3),function(e,t,r,n){var i;for(P(e,t-257,5),P(e,r-1,5),P(e,n-4,4),i=0;i<n;i++)P(e,e.bl_tree[2*S[i]+1],3);V(e,e.dyn_ltree,t-1),V(e,e.dyn_dtree,r-1)}(e,e.l_desc.max_code+1,e.d_desc.max_code+1,a+1),K(e,e.dyn_ltree,e.dyn_dtree)),W(e),n&&M(e)},r._tr_tally=function(e,t,r){return e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&r,e.last_lit++,0===t?e.dyn_ltree[2*r]++:(e.matches++,t--,e.dyn_ltree[2*(A[r]+u+1)]++,e.dyn_dtree[2*N(t)]++),e.last_lit===e.lit_bufsize-1},r._tr_align=function(e){P(e,2,3),L(e,m,z),function(e){16===e.bi_valid?(U(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):8<=e.bi_valid&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8)}(e)}},{\"../utils/common\":41}],53:[function(e,t,r){\"use strict\";t.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\"\",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(e,t,r){(function(e){!function(r,n){\"use strict\";if(!r.setImmediate){var i,s,t,a,o=1,h={},u=!1,l=r.document,e=Object.getPrototypeOf&&Object.getPrototypeOf(r);e=e&&e.setTimeout?e:r,i=\"[object process]\"==={}.toString.call(r.process)?function(e){process.nextTick(function(){c(e)})}:function(){if(r.postMessage&&!r.importScripts){var e=!0,t=r.onmessage;return r.onmessage=function(){e=!1},r.postMessage(\"\",\"*\"),r.onmessage=t,e}}()?(a=\"setImmediate$\"+Math.random()+\"$\",r.addEventListener?r.addEventListener(\"message\",d,!1):r.attachEvent(\"onmessage\",d),function(e){r.postMessage(a+e,\"*\")}):r.MessageChannel?((t=new MessageChannel).port1.onmessage=function(e){c(e.data)},function(e){t.port2.postMessage(e)}):l&&\"onreadystatechange\"in l.createElement(\"script\")?(s=l.documentElement,function(e){var t=l.createElement(\"script\");t.onreadystatechange=function(){c(e),t.onreadystatechange=null,s.removeChild(t),t=null},s.appendChild(t)}):function(e){setTimeout(c,0,e)},e.setImmediate=function(e){\"function\"!=typeof e&&(e=new Function(\"\"+e));for(var t=new Array(arguments.length-1),r=0;r<t.length;r++)t[r]=arguments[r+1];var n={callback:e,args:t};return h[o]=n,i(o),o++},e.clearImmediate=f}function f(e){delete h[e]}function c(e){if(u)setTimeout(c,0,e);else{var t=h[e];if(t){u=!0;try{!function(e){var t=e.callback,r=e.args;switch(r.length){case 0:t();break;case 1:t(r[0]);break;case 2:t(r[0],r[1]);break;case 3:t(r[0],r[1],r[2]);break;default:t.apply(n,r)}}(t)}finally{f(e),u=!1}}}}function d(e){e.source===r&&\"string\"==typeof e.data&&0===e.data.indexOf(a)&&c(+e.data.slice(a.length))}}(\"undefined\"==typeof self?void 0===e?this:e:self)}).call(this,\"undefined\"!=typeof __webpack_require__.g?__webpack_require__.g:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}]},{},[10])(10)});\n\n//# sourceURL=webpack://parser-optimizer/./node_modules/jszip/dist/jszip.min.js?");

/***/ }),

/***/ "./src/css/base.css":
/*!**************************!*\
  !*** ./src/css/base.css ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://parser-optimizer/./src/css/base.css?");

/***/ }),

/***/ "./src/css/components.css":
/*!********************************!*\
  !*** ./src/css/components.css ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://parser-optimizer/./src/css/components.css?");

/***/ }),

/***/ "./src/css/layout.css":
/*!****************************!*\
  !*** ./src/css/layout.css ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://parser-optimizer/./src/css/layout.css?");

/***/ }),

/***/ "./src/css/sections.css":
/*!******************************!*\
  !*** ./src/css/sections.css ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://parser-optimizer/./src/css/sections.css?");

/***/ }),

/***/ "./src/js/algorithm-service.js":
/*!*************************************!*\
  !*** ./src/js/algorithm-service.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlgorithmService: () => (/* binding */ AlgorithmService)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"./src/js/index.js\");\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\n/**\n * AlgorithmService - Handles algorithm execution and results processing\n * No UI concerns are handled here\n */\nvar AlgorithmService = {\n  /**\n   * Run the selected cutting optimization algorithm\n   * @param {string} type - Algorithm type ('ffd', 'ilp', 'compare')\n   * @param {Object} data - Data to process\n   * @returns {Object} Algorithm results\n   * @throws {Error} If data is invalid or algorithm fails\n   */\n  runAlgorithm: function runAlgorithm(type, data) {\n    try {\n      var results;\n      if (type === 'compare') {\n        // Run both algorithms and compare results\n        var ffdResults = this.runFFDAlgorithm(data);\n        var ilpResults = this.runILPAlgorithm(data);\n\n        // Compare results and select the best\n        results = this.compareAndSelectBest(ffdResults, ilpResults);\n      } else if (type === 'greedy' || type === 'ffd') {\n        results = this.runFFDAlgorithm(data);\n      } else if (type === 'ilp') {\n        results = this.runILPAlgorithm(data);\n      } else {\n        throw new Error(\"Type d'algorithme non reconnu: \".concat(type));\n      }\n      return results;\n    } catch (error) {\n      console.error('Algorithm error:', error);\n      throw error;\n    }\n  },\n  /**\n   * Run the First-Fit Decreasing algorithm\n   * @param {Object} data - Data to process\n   * @returns {Object} Algorithm results\n   */\n  runFFDAlgorithm: function runFFDAlgorithm(data) {\n    var results = _index_js__WEBPACK_IMPORTED_MODULE_0__.algorithms.solveGreedyFFD(data.motherBars, data.pieces);\n    results.algorithmName = 'First-Fit Decreasing';\n    results.algorithmType = 'ffd';\n    return results;\n  },\n  /**\n   * Run the Integer Linear Programming algorithm\n   * @param {Object} data - Data to process\n   * @returns {Object} Algorithm results\n   */\n  runILPAlgorithm: function runILPAlgorithm(data) {\n    var results = _index_js__WEBPACK_IMPORTED_MODULE_0__.algorithms.solveWithILP(data.motherBars, data.pieces);\n    results.algorithmName = 'Programmation Linéaire (ILP)';\n    results.algorithmType = 'ilp';\n    return results;\n  },\n  /**\n   * Compare results and select the best algorithm\n   * @param {Object} ffdResults - FFD algorithm results\n   * @param {Object} ilpResults - ILP algorithm results \n   * @returns {Object} Best algorithm results with comparison data\n   */\n  compareAndSelectBest: function compareAndSelectBest(ffdResults, ilpResults) {\n    var _ffdResults$globalSta, _ilpResults$globalSta;\n    // Validate results have needed properties\n    if (!(ffdResults !== null && ffdResults !== void 0 && (_ffdResults$globalSta = ffdResults.globalStats) !== null && _ffdResults$globalSta !== void 0 && (_ffdResults$globalSta = _ffdResults$globalSta.statistics) !== null && _ffdResults$globalSta !== void 0 && _ffdResults$globalSta.utilizationRate) || !(ilpResults !== null && ilpResults !== void 0 && (_ilpResults$globalSta = ilpResults.globalStats) !== null && _ilpResults$globalSta !== void 0 && (_ilpResults$globalSta = _ilpResults$globalSta.statistics) !== null && _ilpResults$globalSta !== void 0 && _ilpResults$globalSta.utilizationRate)) {\n      throw new Error(\"Les résultats d'algorithme sont incomplets pour la comparaison.\");\n    }\n\n    // Get efficiency values from results\n    var ffdEfficiency = parseFloat(ffdResults.globalStats.statistics.utilizationRate);\n    var ilpEfficiency = parseFloat(ilpResults.globalStats.statistics.utilizationRate);\n\n    // Determine best algorithm\n    var bestAlgorithm = ffdEfficiency >= ilpEfficiency ? 'ffd' : 'ilp';\n    var bestResults = bestAlgorithm === 'ffd' ? ffdResults : ilpResults;\n\n    // Add comparison data to results\n    bestResults.comparison = {\n      ffdEfficiency: ffdEfficiency,\n      ilpEfficiency: ilpEfficiency,\n      bestAlgorithm: bestAlgorithm,\n      differencePercentage: Math.abs(ffdEfficiency - ilpEfficiency).toFixed(2)\n    };\n    bestResults.bestAlgorithm = bestAlgorithm;\n    bestResults.algorithmName = bestAlgorithm === 'ffd' ? 'First-Fit Decreasing (meilleur)' : 'Programmation Linéaire (meilleur)';\n    bestResults.algorithmType = 'compare';\n    return bestResults;\n  },\n  /**\n   * Process cutting patterns for visualization\n   * @param {Object} layout - Layout pattern to process\n   * @returns {Object} Processed pattern with visualization data\n   */\n  processPattern: function processPattern(layout) {\n    var pattern = layout.pattern || layout;\n    var count = layout.count || 1;\n    var cuts = pattern.cuts || pattern.pieces || [];\n    var waste = pattern.remainingLength || pattern.waste || 0;\n    var barLength = pattern.originalLength || pattern.totalLength + waste;\n\n    // Group cuts by length\n    var cutCounts = {};\n    cuts.forEach(function (cut) {\n      cutCounts[cut] = (cutCounts[cut] || 0) + 1;\n    });\n\n    // Sort cuts by length (descending)\n    var sortedCuts = Object.entries(cutCounts).sort(function (a, b) {\n      return b[0] - a[0];\n    }).map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        length = _ref2[0],\n        count = _ref2[1];\n      return {\n        length: parseInt(length),\n        count: count\n      };\n    });\n\n    // Calculate visual representations\n    var visualPieces = cuts.map(function (cut, index) {\n      return {\n        length: cut,\n        percentage: cut / barLength * 100,\n        isLast: index === cuts.length - 1 && waste === 0\n      };\n    });\n    return {\n      count: count,\n      barLength: barLength,\n      waste: waste,\n      cuts: sortedCuts,\n      visualPieces: visualPieces,\n      wastePercentage: waste / barLength * 100\n    };\n  },\n  /**\n   * Calculate global statistics from results\n   * @param {Object} results - Algorithm results\n   * @returns {Object} Calculated global statistics\n   */\n  calculateGlobalStats: function calculateGlobalStats(results) {\n    var modelResults = results.modelResults || {};\n    var totalUsedBars = 0;\n    var totalWaste = 0;\n    var totalBarLength = 0;\n\n    // Calculate totals across all models\n    for (var model in modelResults) {\n      var modelResult = modelResults[model];\n      totalUsedBars += modelResult.rawData.usedBars.length;\n\n      // Calculate waste and total length\n      var _iterator = _createForOfIteratorHelper(modelResult.rawData.usedBars),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var bar = _step.value;\n          totalBarLength += bar.originalLength;\n          totalWaste += bar.remainingLength || bar.waste || 0;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    // Calculate global efficiency\n    var totalEfficiency = totalBarLength > 0 ? ((1 - totalWaste / totalBarLength) * 100).toFixed(2) : \"100.00\";\n    return {\n      totalUsedBars: totalUsedBars,\n      totalWaste: totalWaste,\n      totalBarLength: totalBarLength,\n      totalEfficiency: totalEfficiency\n    };\n  },\n  /**\n   * Calculate statistics for an individual model\n   * @param {Object} modelResult - Model result data\n   * @returns {Object} Calculated model statistics\n   */\n  calculateModelStats: function calculateModelStats(modelResult) {\n    var usedBars = modelResult.rawData.usedBars;\n    var totalModelBarLength = 0;\n    var totalModelWasteLength = 0;\n\n    // Calculate model totals\n    var _iterator2 = _createForOfIteratorHelper(usedBars),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var bar = _step2.value;\n        totalModelBarLength += bar.originalLength;\n        totalModelWasteLength += bar.remainingLength || bar.waste || 0;\n      }\n\n      // Calculate model efficiency\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    var modelEfficiency = totalModelBarLength > 0 ? ((1 - totalModelWasteLength / totalModelBarLength) * 100).toFixed(2) : \"100.00\";\n    return {\n      barCount: usedBars.length,\n      totalLength: totalModelBarLength,\n      wasteLength: totalModelWasteLength,\n      efficiency: modelEfficiency\n    };\n  }\n};\n\n//# sourceURL=webpack://parser-optimizer/./src/js/algorithm-service.js?");

/***/ }),

/***/ "./src/js/algorithms/First-Fit-Decreasing.js":
/*!***************************************************!*\
  !*** ./src/js/algorithms/First-Fit-Decreasing.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   solveGreedyFFD: () => (/* binding */ solveGreedyFFD)\n/* harmony export */ });\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n/**\n * Résout le problème de découpe de barres avec l'algorithme First-Fit Decreasing (FFD)\n */\nfunction solveGreedyFFD(motherBars, pieces) {\n  var results = {};\n  var globalStats = {\n    totalBarsUsed: 0,\n    totalWaste: 0,\n    totalRemainingPieces: 0\n  };\n\n  // Traiter chaque modèle séparément\n  var _loop = function _loop(model) {\n    if (pieces[model].length === 0 || !motherBars[model] || motherBars[model].length === 0) {\n      return 1; // continue\n    }\n\n    // Initialiser les résultats pour ce modèle\n    var modelResult = {\n      rawData: {\n        usedBars: [],\n        // Données brutes des barres utilisées\n        wasteLength: 0,\n        // Chutes totales\n        totalMotherBarsUsed: 0,\n        // Nombre total de barres mères utilisées\n        remainingPieces: [],\n        // Pièces qu'on n'a pas pu découper\n        motherBarLength: 0 // Longueur des barres mères\n      },\n      layouts: [],\n      // Schémas de coupe regroupés (sera rempli plus tard)\n      availableStock: {\n        totalBars: 0,\n        bars: []\n      }\n    };\n\n    // Copier les informations sur le stock disponible\n    modelResult.availableStock.bars = motherBars[model].map(function (bar) {\n      return {\n        model: model,\n        length: bar.length,\n        quantity: bar.quantity\n      };\n    });\n\n    // Obtenir la longueur standard des barres mères pour ce modèle\n    var motherBarLength = motherBars[model][0].length;\n    modelResult.rawData.motherBarLength = motherBarLength;\n\n    // Calculer le nombre total de barres disponibles\n    var availableBars = 0;\n    motherBars[model].forEach(function (bar) {\n      availableBars += bar.quantity;\n      modelResult.availableStock.totalBars += bar.quantity;\n    });\n\n    // Créer un tableau de toutes les pièces pour ce modèle\n    var allPieces = [];\n    pieces[model].forEach(function (piece) {\n      for (var i = 0; i < piece.quantity; i++) {\n        allPieces.push(piece.length);\n      }\n    });\n\n    // Trier les pièces par ordre décroissant\n    allPieces.sort(function (a, b) {\n      return b - a;\n    });\n\n    // Tableau des barres utilisées\n    var usedBars = [];\n    var currentBarIndex = -1;\n\n    // First-Fit Decreasing\n    for (var _i = 0, _allPieces = allPieces; _i < _allPieces.length; _i++) {\n      var pieceLength = _allPieces[_i];\n      // Vérifier si la pièce peut être placée dans une barre existante\n      var placed = false;\n      for (var i = 0; i <= currentBarIndex; i++) {\n        if (usedBars[i].remainingLength >= pieceLength) {\n          // Placer dans cette barre\n          usedBars[i].cuts.push(pieceLength);\n          usedBars[i].remainingLength -= pieceLength;\n          placed = true;\n          break;\n        }\n      }\n\n      // Si pas placée et des barres mères sont encore disponibles, ouvrir une nouvelle\n      if (!placed) {\n        if (availableBars > 0) {\n          currentBarIndex++;\n          availableBars--;\n          usedBars.push({\n            barId: currentBarIndex + 1,\n            cuts: [pieceLength],\n            remainingLength: motherBarLength - pieceLength,\n            originalLength: motherBarLength,\n            model: model // Ajouter le modèle à la barre\n          });\n        } else {\n          // Plus de barres mères disponibles\n          modelResult.rawData.remainingPieces.push(pieceLength);\n        }\n      }\n    }\n\n    // Calculer les statistiques\n    var totalWaste = 0;\n    usedBars.forEach(function (bar) {\n      totalWaste += bar.remainingLength;\n    });\n    modelResult.rawData.usedBars = usedBars;\n    modelResult.rawData.wasteLength = totalWaste;\n    modelResult.rawData.totalMotherBarsUsed = usedBars.length;\n\n    // Calculer les statistiques détaillées pour ce modèle\n    modelResult.stats = calculateModelStats(modelResult, motherBars[model], pieces[model]);\n\n    // Mettre à jour les statistiques globales\n    globalStats.totalBarsUsed += usedBars.length;\n    globalStats.totalWaste += totalWaste;\n    globalStats.totalRemainingPieces += modelResult.rawData.remainingPieces.length;\n\n    // Regrouper les barres par layout identique\n    var layoutPatterns = {};\n    usedBars.forEach(function (bar) {\n      // Créer une clé unique pour ce layout basée sur les coupes et la longueur restante\n      // Trier les coupes pour s'assurer que l'ordre n'affecte pas le regroupement\n      var sortedCuts = _toConsumableArray(bar.cuts).sort(function (a, b) {\n        return b - a;\n      });\n      var layoutKey = sortedCuts.join(',') + '_' + bar.remainingLength;\n      if (!layoutPatterns[layoutKey]) {\n        layoutPatterns[layoutKey] = {\n          pattern: bar,\n          count: 1,\n          // Ajouter des propriétés compatibles avec l'affichage\n          pieces: sortedCuts,\n          cuts: sortedCuts,\n          waste: bar.remainingLength || 0,\n          remainingLength: bar.remainingLength || 0,\n          originalLength: bar.originalLength,\n          totalLength: bar.originalLength - (bar.remainingLength || 0)\n        };\n      } else {\n        layoutPatterns[layoutKey].count++;\n      }\n    });\n\n    // Convertir l'objet en tableau pour faciliter le tri\n    var layoutsArray = Object.values(layoutPatterns);\n\n    // Trier les layouts par ordre décroissant de fréquence\n    layoutsArray.sort(function (a, b) {\n      return b.count - a.count;\n    });\n\n    // Stocker les layouts pour ce modèle\n    modelResult.layouts = layoutsArray;\n\n    // Afficher uniquement une ligne de statistique importante pour ce modèle\n    console.log(\"\\uD83D\\uDCCA Mod\\xE8le \".concat(model, \": \").concat(usedBars.length, \" barres utilis\\xE9es, taux d'utilisation: \").concat(modelResult.stats.utilizationRate, \"%\"));\n\n    // Ajouter les résultats pour ce modèle\n    results[model] = modelResult;\n  };\n  for (var model in pieces) {\n    if (_loop(model)) continue;\n  }\n\n  // Calculer les statistiques globales pour tous les modèles\n  var totalStockLength = 0;\n  var totalDemandLength = 0;\n  var totalUsedLength = 0;\n  var totalWasteLength = 0;\n  var totalBarsLength = 0;\n  for (var _model in results) {\n    var modelStats = results[_model].stats;\n    if (modelStats) {\n      totalStockLength += modelStats.totalStockLength || 0;\n      totalDemandLength += modelStats.totalDemandLength || 0;\n      totalUsedLength += modelStats.totalUsedLength || 0;\n      totalWasteLength += modelStats.totalWasteLength || 0;\n    }\n    if (results[_model].rawData && results[_model].rawData.usedBars) {\n      totalBarsLength += results[_model].rawData.usedBars.reduce(function (sum, bar) {\n        return sum + bar.originalLength;\n      }, 0);\n    }\n  }\n\n  // Ajouter les statistiques globales\n  globalStats.statistics = {\n    totalStockLength: totalStockLength,\n    totalDemandLength: totalDemandLength,\n    totalUsedLength: totalUsedLength,\n    totalWasteLength: totalWasteLength,\n    utilizationRate: totalBarsLength > 0 ? (totalUsedLength / totalBarsLength * 100).toFixed(3) : 0\n  };\n\n  // Afficher uniquement une ligne de statistique importante globale\n  console.log(\"\\uD83D\\uDCC8 GLOBAL: \".concat(globalStats.totalBarsUsed, \" barres utilis\\xE9es, taux d'utilisation: \").concat(globalStats.statistics.utilizationRate, \"%\"));\n\n  // Retourner un objet complet avec les résultats et les statistiques globales\n  return {\n    modelResults: results,\n    globalStats: globalStats\n  };\n}\n\n/**\n * Calcule les statistiques clés pour un modèle\n * @param {Object} modelResult - Résultats pour un modèle spécifique\n * @param {Array} stockBars - Barres mères disponibles\n * @param {Array} demandPieces - Pièces à découper\n * @returns {Object} Statistiques calculées\n */\nfunction calculateModelStats(modelResult, stockBars, demandPieces) {\n  // Initialiser les compteurs\n  var totalDemandLength = 0;\n  var totalStockLength = 0;\n  var totalUsedLength = 0;\n  var totalWasteLength = 0;\n\n  // Initialiser les variables de statut de production\n  var hasOverproduction = false;\n  var hasUnderproduction = false;\n  var overproductionDetails = [];\n  var underproductionDetails = [];\n  var totalOverproduced = 0;\n  var totalUnderproduced = 0;\n\n  // 1. Calculer la somme des longueurs de toutes les pièces à découper\n  var demandByPieceLength = new Map();\n  var _iterator = _createForOfIteratorHelper(demandPieces),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var piece = _step.value;\n      totalDemandLength += piece.length * piece.quantity;\n      demandByPieceLength.set(piece.length, piece.quantity);\n    }\n\n    // 2. Calculer la somme des longueurs de toutes les barres mères disponibles\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var _iterator2 = _createForOfIteratorHelper(stockBars),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _bar = _step2.value;\n      totalStockLength += _bar.length * _bar.quantity;\n    }\n\n    // 3. Calculer la somme des longueurs utilisées et des chutes dans les layouts\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  if (modelResult.rawData && modelResult.rawData.usedBars) {\n    // Garder trace des pièces découpées par longueur\n    var cutPiecesByLength = new Map();\n    var _iterator3 = _createForOfIteratorHelper(modelResult.rawData.usedBars),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var bar = _step3.value;\n        // Pour chaque barre utilisée\n        var pieces = bar.cuts || [];\n\n        // Compter les pièces par longueur\n        var _iterator5 = _createForOfIteratorHelper(pieces),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var pieceLength = _step5.value;\n            var currentCount = cutPiecesByLength.get(pieceLength) || 0;\n            cutPiecesByLength.set(pieceLength, currentCount + 1);\n          }\n\n          // Calculer la longueur totale des pièces et la chute\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        var pieceSum = pieces.reduce(function (sum, piece) {\n          return sum + piece;\n        }, 0);\n        var wasteLength = bar.remainingLength || 0;\n        totalUsedLength += pieceSum;\n        totalWasteLength += wasteLength;\n      }\n\n      // Vérifier s'il y a une surproduction ou sous-production\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    var _iterator4 = _createForOfIteratorHelper(cutPiecesByLength.entries()),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _step4$value = _slicedToArray(_step4.value, 2),\n          _pieceLength = _step4$value[0],\n          cutCount = _step4$value[1];\n        var demandCount = demandByPieceLength.get(_pieceLength) || 0;\n        var diff = cutCount - demandCount;\n        if (diff > 0) {\n          hasOverproduction = true;\n          totalOverproduced += diff;\n          overproductionDetails.push(\"\".concat(diff, \" pi\\xE8ces de longueur \").concat(_pieceLength));\n        } else if (diff < 0) {\n          hasUnderproduction = true;\n          totalUnderproduced += Math.abs(diff);\n          underproductionDetails.push(\"\".concat(Math.abs(diff), \" pi\\xE8ces de longueur \").concat(_pieceLength));\n        }\n      }\n\n      // Calculer la longueur totale utilisée par les barres mères\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    var totalBarsLength = modelResult.rawData.usedBars.reduce(function (sum, bar) {\n      return sum + bar.originalLength;\n    }, 0);\n\n    // CORRECTION: Ne pas recalculer totalUsedLength et totalWasteLength ici\n    // Il y avait une référence à une variable 'pieces' non définie\n    // Suppression des deux lignes suivantes qui sont erronées:\n    // totalUsedLength = pieces.reduce((sum, piece) => sum + piece, 0);\n    // totalWasteLength = wasteLength;\n\n    // Le taux d'utilisation est déjà calculé correctement par la valeur accumulée de totalUsedLength\n  }\n  return {\n    totalDemandLength: totalDemandLength,\n    totalStockLength: totalStockLength,\n    totalUsedLength: totalUsedLength,\n    totalWasteLength: totalWasteLength,\n    // Le taux d'utilisation est déjà calculé correctement ici\n    utilizationRate: totalUsedLength > 0 && modelResult.rawData.usedBars.length > 0 ? (totalUsedLength / modelResult.rawData.usedBars.reduce(function (sum, bar) {\n      return sum + bar.originalLength;\n    }, 0) * 100).toFixed(3) : 0,\n    overproductionDetails: hasOverproduction ? overproductionDetails.join(', ') : null,\n    underproductionDetails: hasUnderproduction ? underproductionDetails.join(', ') : null,\n    hasOverproduction: hasOverproduction,\n    hasUnderproduction: hasUnderproduction,\n    totalOverproduced: totalOverproduced,\n    totalUnderproduced: totalUnderproduced\n  };\n}\n\n//# sourceURL=webpack://parser-optimizer/./src/js/algorithms/First-Fit-Decreasing.js?");

/***/ }),

/***/ "./src/js/algorithms/Integer-Linear-Programming.js":
/*!*********************************************************!*\
  !*** ./src/js/algorithms/Integer-Linear-Programming.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   solveWithILP: () => (/* binding */ solveWithILP)\n/* harmony export */ });\n/* harmony import */ var javascript_lp_solver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! javascript-lp-solver */ \"./node_modules/javascript-lp-solver/src/main.js\");\n/* harmony import */ var javascript_lp_solver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(javascript_lp_solver__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n // ou l'équivalent dans votre projet\n\n/**\n * Adapte un pattern pour éviter la surproduction en n'incluant que les pièces nécessaires\n * @param {Object} pattern - Le pattern original à adapter\n * @param {Map} remainingDemand - Demande restante pour chaque longueur de pièce\n * @param {Number} iteration - Numéro de l'itération actuelle\n * @returns {Object} Pattern modifié évitant la surproduction\n */\nfunction adaptPatternToPreventOverproduction(pattern, remainingDemand, iteration) {\n  // Analyser les pièces du pattern original\n  var pieceCounts = {};\n  var _iterator = _createForOfIteratorHelper(pattern.pieces),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _pieceLength = _step.value;\n      pieceCounts[_pieceLength] = (pieceCounts[_pieceLength] || 0) + 1;\n    }\n\n    // Créer un pattern modifié pour éviter la surproduction\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var modifiedPattern = _objectSpread(_objectSpread({}, pattern), {}, {\n    pieces: [],\n    waste: pattern.waste,\n    isModifiedPattern: true\n  });\n  var overproductionDetected = false;\n\n  // Parcourir chaque type de pièce dans le pattern et n'inclure que ce qui est nécessaire\n  var usedPiecesLog = [];\n  for (var _i = 0, _Object$entries = Object.entries(pieceCounts); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n      pieceLength = _Object$entries$_i[0],\n      count = _Object$entries$_i[1];\n    var lengthInt = parseInt(pieceLength, 10);\n    var currentDemand = remainingDemand.get(lengthInt) || 0;\n\n    // Déterminer combien de pièces de cette longueur peuvent être utilisées\n    var usableCount = Math.min(count, currentDemand);\n\n    // Ajouter uniquement les pièces nécessaires au pattern modifié\n    for (var i = 0; i < usableCount; i++) {\n      modifiedPattern.pieces.push(lengthInt);\n    }\n\n    // Déduire de la demande restante\n    if (usableCount > 0) {\n      remainingDemand.set(lengthInt, currentDemand - usableCount);\n      usedPiecesLog.push(\"\".concat(usableCount, \"x\").concat(lengthInt));\n    }\n\n    // Signaler une surproduction potentielle\n    if (count > currentDemand) {\n      overproductionDetected = true;\n\n      // Enregistrer les pièces qui ont été supprimées pour éviter la surproduction\n      if (modifiedPattern.originInfo && modifiedPattern.originInfo.removedPieces) {\n        for (var _i2 = 0; _i2 < count - usableCount; _i2++) {\n          modifiedPattern.originInfo.removedPieces.push(lengthInt);\n        }\n      }\n\n      // Augmenter la chute pour les pièces non utilisées\n      modifiedPattern.waste += (count - usableCount) * lengthInt;\n    }\n  }\n\n  // Si le pattern modifié ne contient pas assez de pièces, il peut ne pas être économique de l'utiliser\n  var originalUsage = pattern.pieces.reduce(function (sum, len) {\n    return sum + len;\n  }, 0);\n  var modifiedUsage = modifiedPattern.pieces.reduce(function (sum, len) {\n    return sum + len;\n  }, 0);\n  var usageRatio = modifiedUsage / (originalUsage || 1);\n\n  // Transférer l'identifiant du pattern original vers le pattern modifié\n  modifiedPattern.originalPatternIndex = pattern.originalPatternIndex || pattern.id || -1;\n\n  // Ajout des métadonnées du pattern original pour le suivi\n  modifiedPattern.originInfo = {\n    originalPieces: _toConsumableArray(pattern.pieces),\n    removedPieces: overproductionDetected ? [] : null\n  };\n\n  // Rejeter le pattern si l'utilisation est trop faible (moins de 50%)\n  if (usageRatio < 0.5 && modifiedPattern.pieces.length > 0) {\n    modifiedPattern.hasUsablePieces = false;\n    return modifiedPattern;\n  }\n\n  // Marquer si le pattern a été modifié\n  modifiedPattern.isModified = overproductionDetected;\n  modifiedPattern.hasUsablePieces = usedPiecesLog.length > 0;\n  return modifiedPattern;\n}\n\n/**\n * Résout le problème de découpe de barres en utilisant la programmation linéaire en nombres entiers\n * avec le solveur jsLPSolver et des techniques avancées de recherche opérationnelle.\n * \n * @param {Object} motherBars - Dictionnaire des barres mères disponibles par modèle\n * @param {Object} pieces - Dictionnaire des pièces à découper par modèle\n * @param {Function} progressCallback - Fonction de callback pour indiquer la progression\n * @returns {Object} Résultats de l'optimisation\n */\nfunction solveWithILP(motherBars, pieces) {\n  var progressCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n  // Vérifier que le solveur est chargé\n  if (typeof (javascript_lp_solver__WEBPACK_IMPORTED_MODULE_0___default()) === 'undefined') {\n    throw new Error(\"Le solveur jsLPSolver n'est pas défini. Assurez-vous qu'il est correctement importé.\");\n  }\n\n  // Structure de résultat finale\n  var results = {};\n  var globalStats = {\n    totalBarsUsed: 0,\n    totalWaste: 0,\n    totalRemainingPieces: 0\n  };\n  console.log(\"Début de l'exécution ILP optimisée\");\n\n  // Traiter chaque modèle séparément\n  for (var model in pieces) {\n    if (pieces[model].length === 0 || !motherBars[model] || motherBars[model].length === 0) {\n      continue;\n    }\n    progressCallback({\n      step: \"Traitement du mod\\xE8le \".concat(model),\n      percentage: 10\n    });\n\n    // Initialiser les résultats pour ce modèle\n    var modelResult = {\n      rawData: {\n        usedBars: [],\n        wasteLength: 0,\n        totalMotherBarsUsed: 0,\n        remainingPieces: [],\n        motherBarLength: 0\n      },\n      layouts: []\n    };\n    try {\n      console.log(\"Optimisation du mod\\xE8le \".concat(model));\n\n      // Préparer les données\n      var _stockBars = prepareStockBarsData(motherBars[model]);\n      var _demandPieces = preparePiecesData(pieces[model]);\n\n      // Vérifier que les données sont valides\n      if (_demandPieces.length === 0) {\n        console.log(\"Mod\\xE8le \".concat(model, \" : aucune pi\\xE8ce \\xE0 d\\xE9couper\"));\n        continue;\n      }\n      if (_stockBars.length === 0) {\n        console.log(\"Mod\\xE8le \".concat(model, \" : aucune barre m\\xE8re disponible\"));\n        continue;\n      }\n      progressCallback({\n        step: \"G\\xE9n\\xE9ration des patterns pour \".concat(model),\n        percentage: 30\n      });\n\n      // Générer des patterns de découpe efficaces\n      var initialPatterns = generatePatternsForBars(_stockBars, _demandPieces);\n      console.log(\"\".concat(initialPatterns.length, \" patterns g\\xE9n\\xE9r\\xE9s pour le mod\\xE8le \").concat(model));\n\n      // Résoudre le problème de découpe avec la méthode la plus appropriée\n      progressCallback({\n        step: \"R\\xE9solution ILP pour \".concat(model),\n        percentage: 70\n      });\n\n      // Résoudre avec la méthode principale (ILP) ou fallback si nécessaire\n      var optimizationResult = solveWithCuttingStockILP(_stockBars, _demandPieces, initialPatterns);\n\n      // Traiter les résultats\n      var processedResult = processOptimizationResult(optimizationResult, _stockBars, _demandPieces);\n\n      // Mettre à jour les statistiques globales\n      globalStats.totalBarsUsed += processedResult.rawData.totalMotherBarsUsed;\n      globalStats.totalWaste += processedResult.rawData.wasteLength;\n      globalStats.totalRemainingPieces += processedResult.rawData.remainingPieces.length;\n\n      // Assigner les résultats pour ce modèle\n      modelResult.rawData = processedResult.rawData;\n      modelResult.layouts = processedResult.layouts;\n      console.log(\"Mod\\xE8le \".concat(model, \" trait\\xE9 : \").concat(processedResult.rawData.totalMotherBarsUsed, \" barres utilis\\xE9es\"));\n\n      // Vérifier si des pièces n'ont pas été découpées\n      if (processedResult.rawData.remainingPieces.length > 0) {\n        console.warn(\"\\u26A0\\uFE0F \".concat(processedResult.rawData.remainingPieces.length, \" pi\\xE8ces non d\\xE9coup\\xE9es pour le mod\\xE8le \").concat(model));\n      }\n    } catch (error) {\n      console.error(\"Erreur lors du traitement du mod\\xE8le \".concat(model, \":\"), error);\n\n      // Essayer de récupérer avec un algorithme glouton simple en cas d'erreur critique\n      var _stockBars2 = prepareStockBarsData(motherBars[model]);\n      var _demandPieces2 = preparePiecesData(pieces[model]);\n      var fallbackResult = solveWithSimpleGreedy(_stockBars2, _demandPieces2);\n      modelResult.rawData = fallbackResult.rawData;\n      modelResult.layouts = fallbackResult.layouts;\n\n      // Mettre à jour les statistiques globales\n      globalStats.totalBarsUsed += fallbackResult.rawData.totalMotherBarsUsed;\n      globalStats.totalWaste += fallbackResult.rawData.wasteLength;\n      globalStats.totalRemainingPieces += fallbackResult.rawData.remainingPieces.length;\n      console.warn(\"\\u26A0\\uFE0F Utilisation de l'algorithme de secours pour le mod\\xE8le \".concat(model));\n    }\n\n    // Calculer et afficher les statistiques pour ce modèle\n    var stockBars = prepareStockBarsData(motherBars[model]);\n    var demandPieces = preparePiecesData(pieces[model]);\n    var modelStats = calculateModelStats(modelResult, stockBars, demandPieces);\n\n    // Afficher uniquement les informations essentielles\n    console.log(\"\\uD83D\\uDCCA Mod\\xE8le \".concat(model, \": \").concat(modelResult.rawData.totalMotherBarsUsed, \" barres utilis\\xE9es, taux d'utilisation: \").concat(modelStats.utilizationRate, \"%\"));\n\n    // Ajouter les résultats et statistiques pour ce modèle\n    results[model] = _objectSpread(_objectSpread({}, modelResult), {}, {\n      stats: modelStats\n    });\n    progressCallback({\n      step: \"Mod\\xE8le \".concat(model, \" termin\\xE9\"),\n      percentage: 100\n    });\n  }\n\n  // Calculer les statistiques globales\n  var globalStatistics = {\n    totalDemandLength: 0,\n    totalStockLength: 0,\n    totalUsedLength: 0,\n    totalWasteLength: 0,\n    totalBarsLength: 0 // Ajouter cette ligne\n  };\n  for (var _model in results) {\n    if (results[_model].stats) {\n      globalStatistics.totalDemandLength += results[_model].stats.totalDemandLength;\n      globalStatistics.totalStockLength += results[_model].stats.totalStockLength;\n      globalStatistics.totalUsedLength += results[_model].stats.totalUsedLength;\n      globalStatistics.totalWasteLength += results[_model].stats.totalWasteLength;\n\n      // Ajouter le calcul de la longueur totale des barres\n      if (results[_model].rawData && results[_model].rawData.usedBars) {\n        globalStatistics.totalBarsLength += results[_model].rawData.usedBars.reduce(function (sum, bar) {\n          return sum + bar.originalLength;\n        }, 0);\n      }\n    }\n  }\n\n  // Calculer le taux d'utilisation global basé sur le ratio correct\n  globalStatistics.utilizationRate = globalStatistics.totalBarsLength > 0 ? (globalStatistics.totalUsedLength / globalStatistics.totalBarsLength * 100).toFixed(3) : 0;\n\n  // Afficher uniquement une ligne de statistique importante globale\n  console.log(\"\\uD83D\\uDCC8 GLOBAL: \".concat(globalStats.totalBarsUsed, \" barres utilis\\xE9es, taux d'utilisation: \").concat(globalStatistics.utilizationRate, \"%\"));\n  return {\n    modelResults: results,\n    globalStats: _objectSpread(_objectSpread({}, globalStats), {}, {\n      statistics: globalStatistics\n    })\n  };\n}\n\n/**\n * Prépare les données des barres mères\n * @param {Array} motherBars - Liste des barres mères\n * @returns {Array} Données préparées\n */\nfunction prepareStockBarsData(motherBars) {\n  var stockBars = [];\n  var _iterator2 = _createForOfIteratorHelper(motherBars),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var bar = _step2.value;\n      stockBars.push({\n        length: parseInt(bar.length, 10),\n        quantity: parseInt(bar.quantity, 10)\n      });\n    }\n\n    // Tri par ordre décroissant de longueur\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  stockBars.sort(function (a, b) {\n    return b.length - a.length;\n  });\n  return stockBars;\n}\n\n/**\n * Prépare les données des pièces à découper\n * @param {Array} pieces - Liste des pièces\n * @returns {Array} Données préparées\n */\nfunction preparePiecesData(pieces) {\n  var demandPieces = [];\n  var _iterator3 = _createForOfIteratorHelper(pieces),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var piece = _step3.value;\n      demandPieces.push({\n        length: parseInt(piece.length, 10),\n        quantity: parseInt(piece.quantity, 10)\n      });\n    }\n\n    // Tri par ordre décroissant de longueur\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  demandPieces.sort(function (a, b) {\n    return b.length - a.length;\n  });\n  return demandPieces;\n}\n\n/**\n * Génère des patterns de découpe efficaces pour toutes les barres disponibles\n * @param {Array} stockBars - Barres mères disponibles\n * @param {Array} demandPieces - Pièces à découper\n * @returns {Array} Patterns de découpe\n */\nfunction generatePatternsForBars(stockBars, demandPieces) {\n  var allPatterns = [];\n\n  // Limiter le nombre de patrons par barre pour éviter une explosion combinatoire\n  var maxPatternsPerBar = 3000;\n  var totalMaxPatterns = 10000;\n\n  // Pour chaque longueur de barre mère\n  var _iterator4 = _createForOfIteratorHelper(stockBars),\n    _step4;\n  try {\n    var _loop = function _loop() {\n      var stockBar = _step4.value;\n      var stockLength = stockBar.length;\n      var patternsForThisLength = generatePatternsForSingleBar(demandPieces, stockLength, maxPatternsPerBar);\n\n      // Ajouter la longueur de la barre mère à chaque pattern\n      patternsForThisLength.forEach(function (pattern) {\n        pattern.stockLength = stockLength;\n        pattern.stockBarId = stockBar.id || null;\n      });\n      allPatterns.push.apply(allPatterns, _toConsumableArray(patternsForThisLength));\n\n      // Limiter le nombre total de patterns pour éviter les problèmes de mémoire\n      if (allPatterns.length >= totalMaxPatterns) {\n        console.warn(\"\\u26A0\\uFE0F Nombre maximum de patterns atteint (\".concat(totalMaxPatterns, \"), certains patterns ignor\\xE9s\"));\n        return 1; // break\n      }\n    };\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      if (_loop()) break;\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return allPatterns;\n}\n\n/**\n * Génère des patterns de découpe efficaces pour une seule barre\n * Amélioration: utilise une approche plus efficace avec un cache de patterns\n * @param {Array} pieces - Pièces à découper\n * @param {Number} stockLength - Longueur de la barre mère\n * @param {Number} maxPatterns - Nombre maximum de patterns à générer\n * @returns {Array} Patterns de découpe\n */\nfunction generatePatternsForSingleBar(pieces, stockLength) {\n  var maxPatterns = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3000;\n  // Éliminer les pièces trop longues\n  var validPieces = pieces.filter(function (piece) {\n    return piece.length <= stockLength;\n  });\n\n  // Si aucune pièce valide, retourner un pattern vide\n  if (validPieces.length === 0) {\n    return [{\n      pieces: [],\n      waste: stockLength,\n      composition: {}\n    }];\n  }\n\n  // Générer les patterns avec l'algorithme de programmation dynamique\n  var patterns = generatePatternsDP(validPieces, stockLength, maxPatterns);\n\n  // Trier les patterns par efficacité (moins de déchets et plus de pièces)\n  patterns.sort(function (a, b) {\n    // D'abord trier par déchets\n    if (a.waste !== b.waste) {\n      return a.waste - b.waste;\n    }\n    // Ensuite par nombre de pièces (préférer plus de pièces)\n    return b.pieces.length - a.pieces.length;\n  });\n  return patterns.slice(0, maxPatterns);\n}\n\n/**\n * Génère des patterns de découpe avec programmation dynamique\n * Cette approche est beaucoup plus efficace que la recherche en profondeur\n * @param {Array} pieces - Pièces à découper\n * @param {Number} stockLength - Longueur de la barre mère\n * @param {Number} maxPatterns - Nombre maximum de patterns à générer\n * @returns {Array} Patterns de découpe\n */\nfunction generatePatternsDP(pieces, stockLength, maxPatterns) {\n  // Définir un cache pour les sous-problèmes\n  var patternsCache = new Map();\n  var patterns = [];\n  var visited = new Set();\n\n  // Fonction auxiliaire pour générer un pattern key\n  function getPatternKey(composition) {\n    return Object.entries(composition).sort(function (_ref, _ref2) {\n      var _ref3 = _slicedToArray(_ref, 1),\n        a = _ref3[0];\n      var _ref4 = _slicedToArray(_ref2, 1),\n        b = _ref4[0];\n      return parseInt(a) - parseInt(b);\n    }).map(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n        len = _ref6[0],\n        count = _ref6[1];\n      return \"\".concat(len, \":\").concat(count);\n    }).join(',');\n  }\n\n  // Phase 1: Générer tous les patterns possibles avec programmation dynamique\n  function generateWithDP(remainingLength, pieceIndex) {\n    var currentComposition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // Clé de cache pour ce sous-problème\n    var cacheKey = \"\".concat(remainingLength, \":\").concat(pieceIndex);\n\n    // Si déjà calculé, retourner le résultat\n    if (patternsCache.has(cacheKey)) {\n      return patternsCache.get(cacheKey);\n    }\n\n    // Si nous avons atteint la fin des pièces ou la longueur restante est trop petite\n    if (pieceIndex >= pieces.length || remainingLength < pieces[pieces.length - 1].length) {\n      var patternKey = getPatternKey(currentComposition);\n\n      // Éviter les doublons\n      if (!visited.has(patternKey) && patterns.length < maxPatterns) {\n        // Convertir la composition en liste de pièces\n        var patternPieces = [];\n        for (var _i3 = 0, _Object$entries2 = Object.entries(currentComposition); _i3 < _Object$entries2.length; _i3++) {\n          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2),\n            pieceLength = _Object$entries2$_i[0],\n            count = _Object$entries2$_i[1];\n          for (var i = 0; i < count; i++) {\n            patternPieces.push(parseInt(pieceLength, 10));\n          }\n        }\n        patterns.push({\n          pieces: patternPieces,\n          waste: remainingLength,\n          composition: _objectSpread({}, currentComposition)\n        });\n        visited.add(patternKey);\n      }\n      return []; // Retourner un tableau vide pour la récursion\n    }\n\n    // Données de la pièce actuelle\n    var piece = pieces[pieceIndex];\n    var maxCount = Math.min(Math.floor(remainingLength / piece.length), piece.quantity);\n    var subResults = [];\n\n    // Essayer différentes quantités de la pièce actuelle\n    for (var _count = maxCount; _count >= 0; _count--) {\n      var newComposition = _objectSpread({}, currentComposition);\n      if (_count > 0) {\n        newComposition[piece.length] = (newComposition[piece.length] || 0) + _count;\n      }\n      var newRemainingLength = remainingLength - _count * piece.length;\n\n      // Récursivement résoudre pour la pièce suivante\n      var nextResults = generateWithDP(newRemainingLength, pieceIndex + 1, newComposition);\n      subResults.push.apply(subResults, _toConsumableArray(nextResults));\n\n      // Limiter le nombre de sous-résultats pour éviter une explosion combinatoire\n      if (subResults.length > 100) break;\n    }\n\n    // Mettre en cache les résultats pour ce sous-problème\n    patternsCache.set(cacheKey, subResults);\n    return subResults;\n  }\n\n  // Lancer la génération de patterns\n  generateWithDP(stockLength, 0);\n\n  // Phase 2: Ajouter des patterns heuristiques qui pourraient être manqués\n  addHeuristicPatterns(pieces, stockLength, patterns, maxPatterns);\n  return patterns;\n}\n\n/**\n * Ajoute des patterns heuristiques basés sur des règles empiriques\n * @param {Array} pieces - Pièces à découper\n * @param {Number} stockLength - Longueur de la barre mère\n * @param {Array} patterns - Tableau de patterns existants à compléter\n * @param {Number} maxPatterns - Nombre maximum de patterns\n */\nfunction addHeuristicPatterns(pieces, stockLength, patterns, maxPatterns) {\n  // Si on a déjà atteint le maximum de patterns, ne rien faire\n  if (patterns.length >= maxPatterns) return;\n\n  // Heuristique 1: Essayer de combiner les pièces les plus grandes d'abord\n  var sortedPieces = _toConsumableArray(pieces).sort(function (a, b) {\n    return b.length - a.length;\n  });\n  var remainingLength = stockLength;\n  var composition = {};\n  var patternPieces = [];\n  var _iterator5 = _createForOfIteratorHelper(sortedPieces),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var piece = _step5.value;\n      var maxFit = Math.min(Math.floor(remainingLength / piece.length), piece.quantity);\n      if (maxFit > 0) {\n        composition[piece.length] = maxFit;\n        for (var i = 0; i < maxFit; i++) {\n          patternPieces.push(piece.length);\n        }\n        remainingLength -= maxFit * piece.length;\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  if (patternPieces.length > 0) {\n    patterns.push({\n      pieces: patternPieces,\n      waste: remainingLength,\n      composition: composition\n    });\n  }\n\n  // Heuristique 2: Essayer de combiner des pièces de taille similaire\n  // pour minimiser les petits déchets\n  addHomogeneousPatterns(pieces, stockLength, patterns);\n\n  // Heuristique 3: Patterns pour les pièces les plus demandées\n  addHighDemandPatterns(pieces, stockLength, patterns);\n}\n\n/**\n * Ajoute des patterns avec des pièces de taille similaire\n */\nfunction addHomogeneousPatterns(pieces, stockLength, patterns) {\n  for (var i = 0; i < Math.min(pieces.length, 5); i++) {\n    var piece = pieces[i];\n    var maxFit = Math.min(Math.floor(stockLength / piece.length), piece.quantity);\n    if (maxFit > 0) {\n      var patternPieces = Array(maxFit).fill(piece.length);\n      var waste = stockLength - maxFit * piece.length;\n      var composition = _defineProperty({}, piece.length, maxFit);\n      patterns.push({\n        pieces: patternPieces,\n        waste: waste,\n        composition: composition\n      });\n    }\n  }\n}\n\n/**\n * Ajoute des patterns pour les pièces les plus demandées\n */\nfunction addHighDemandPatterns(pieces, stockLength, patterns) {\n  var highDemandPieces = _toConsumableArray(pieces).sort(function (a, b) {\n    return b.quantity - a.quantity;\n  }).slice(0, 3);\n  var _iterator6 = _createForOfIteratorHelper(highDemandPieces),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var piece = _step6.value;\n      var maxFit = Math.min(Math.floor(stockLength / piece.length), piece.quantity);\n      if (maxFit > 0) {\n        var patternPieces = Array(maxFit).fill(piece.length);\n        var waste = stockLength - maxFit * piece.length;\n        var composition = _defineProperty({}, piece.length, maxFit);\n        patterns.push({\n          pieces: patternPieces,\n          waste: waste,\n          composition: composition\n        });\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n}\n\n/**\n * Résout le problème de découpe avec la programmation linéaire en nombres entiers\n * @param {Array} stockBars - Barres mères disponibles\n * @param {Array} demandPieces - Pièces à découper\n * @param {Array} patterns - Patterns de découpe\n * @returns {Object} Résultats de l'optimisation\n */\nfunction solveWithCuttingStockILP(stockBars, demandPieces, patterns) {\n  console.log(\"Tentative de r\\xE9solution ILP avec \".concat(patterns.length, \" patterns\"));\n\n  // Générer des patterns sécurisés qui évitent la surproduction\n  var _generateSafePatterns = generateSafePatterns(stockBars, demandPieces, patterns),\n    safePatterns = _generateSafePatterns.patterns,\n    maxUsage = _generateSafePatterns.maxUsage;\n  if (safePatterns.length === 0) {\n    console.warn(\"⚠️ Aucun pattern sécurisé n'a pu être généré, utilisation de l'algorithme de secours\");\n    return solveWithColumnGeneration(patterns, stockBars, demandPieces);\n  }\n\n  // Réduire le nombre de patterns si nécessaire pour garantir la stabilité\n  var maxPatternsToUse = Math.min(800, safePatterns.length);\n\n  // Sélectionner les patterns les plus efficaces\n  var sortedPatterns = _toConsumableArray(safePatterns).sort(function (a, b) {\n    return a.waste - b.waste;\n  }).slice(0, maxPatternsToUse);\n  console.log(\"Utilisation des \".concat(sortedPatterns.length, \" meilleurs patterns s\\xE9curis\\xE9s\"));\n\n  // Créer un modèle ILP correctement structuré\n  var model = createILPModel(sortedPatterns, stockBars, demandPieces, maxUsage);\n\n  // Essayer de résoudre avec le solveur ILP\n  try {\n    var options = {\n      timeout: 10000,\n      // Augmenter le timeout à 10 secondes\n      strategy: 0,\n      // Stratégie de base pour la stabilité\n      msg: true // Activer les messages de debug\n    };\n    console.log(\"Lancement du solveur ILP...\");\n    var solution = javascript_lp_solver__WEBPACK_IMPORTED_MODULE_0___default().Solve(model, options);\n    console.log(\"Solution ILP obtenue:\", solution.feasible, \"valeur:\", solution.result);\n\n    // Vérifier si la solution est valide et utilisable\n    if (solution.feasible && !isNaN(solution.result) && solution.result > 0) {\n      // Vérifier que des patterns ont été utilisés\n      var patternsUsed = false;\n      for (var key in solution) {\n        if (key.startsWith('pattern_') && !isNaN(solution[key]) && solution[key] > 0) {\n          patternsUsed = true;\n          break;\n        }\n      }\n      if (patternsUsed) {\n        console.log(\"Solution ILP valide, utilisation de cette solution\");\n        return {\n          method: \"ILP\",\n          solution: solution,\n          patterns: sortedPatterns\n        };\n      } else {\n        console.warn(\"⚠️ Solution ILP sans patterns utilisés, utilisation du fallback\");\n      }\n    } else {\n      console.warn(\"⚠️ Solution ILP non valide, utilisation du fallback\");\n    }\n  } catch (error) {\n    console.error(\"Erreur lors de la résolution ILP:\", error);\n  }\n  console.log(\"Utilisation de l'algorithme de secours...\");\n  return solveWithColumnGeneration(sortedPatterns, stockBars, demandPieces);\n}\n\n/**\n * Crée un modèle ILP correctement structuré pour le solveur\n * @param {Array} patterns - Patterns de découpe\n * @param {Array} stockBars - Barres mères disponibles\n * @param {Array} demandPieces - Pièces à découper\n * @param {Map} patternMaxUsage - Limites d'utilisation pour chaque pattern\n * @returns {Object} Modèle ILP\n */\nfunction createILPModel(patterns, stockBars, demandPieces) {\n  var patternMaxUsage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  // Modèle pour minimiser le nombre de barres utilisées\n  var model = {\n    optimize: 'bars',\n    opType: 'min',\n    constraints: {},\n    variables: {},\n    ints: {}\n  };\n\n  // 1. CONTRAINTES DE DEMANDE: garantir que toutes les pièces sont découpées exactement selon la demande\n  var _iterator7 = _createForOfIteratorHelper(demandPieces),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var piece = _step7.value;\n      model.constraints[\"demand_\".concat(piece.length)] = {\n        equal: piece.quantity\n      };\n    }\n\n    // 2. CONTRAINTES DE STOCK: garantir qu'on ne dépasse pas le stock disponible\n    // Création d'une contrainte par longueur de barre stock\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  var stockLengths = new Map();\n  var _iterator8 = _createForOfIteratorHelper(stockBars),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var bar = _step8.value;\n      if (stockLengths.has(bar.length)) {\n        stockLengths.set(bar.length, stockLengths.get(bar.length) + bar.quantity);\n      } else {\n        stockLengths.set(bar.length, bar.quantity);\n      }\n    }\n\n    // Ajouter les contraintes de stock\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  var _iterator9 = _createForOfIteratorHelper(stockLengths.entries()),\n    _step9;\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var _step9$value = _slicedToArray(_step9.value, 2),\n        length = _step9$value[0],\n        quantity = _step9$value[1];\n      model.constraints[\"stock_\".concat(length)] = {\n        max: quantity\n      };\n    }\n\n    // 3. DÉFINIR LES VARIABLES (chaque variable = nombre de fois qu'un pattern est utilisé)\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n  for (var i = 0; i < patterns.length; i++) {\n    var pattern = patterns[i];\n    var varName = \"pattern_\".concat(i);\n\n    // Chaque pattern contribue 1 à l'objectif (une barre utilisée)\n    model.variables[varName] = {\n      bars: 1\n    };\n\n    // Chaque variable doit être un entier\n    model.ints[varName] = 1;\n\n    // Si une limite d'utilisation est spécifiée pour ce pattern, l'ajouter comme contrainte\n    if (patternMaxUsage && pattern.maxUsage) {\n      model.constraints[\"max_usage_\".concat(i)] = {\n        max: pattern.maxUsage\n      };\n      model.variables[varName][\"max_usage_\".concat(i)] = 1;\n    }\n\n    // Compter les occurrences de chaque type de pièce dans ce pattern\n    var pieceCounts = {};\n    var _iterator0 = _createForOfIteratorHelper(pattern.pieces),\n      _step0;\n    try {\n      for (_iterator0.s(); !(_step0 = _iterator0.n()).done;) {\n        var _pieceLength2 = _step0.value;\n        pieceCounts[_pieceLength2] = (pieceCounts[_pieceLength2] || 0) + 1;\n      }\n\n      // Ajouter la contribution aux contraintes de demande\n    } catch (err) {\n      _iterator0.e(err);\n    } finally {\n      _iterator0.f();\n    }\n    for (var _i4 = 0, _Object$entries3 = Object.entries(pieceCounts); _i4 < _Object$entries3.length; _i4++) {\n      var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i4], 2),\n        pieceLength = _Object$entries3$_i[0],\n        count = _Object$entries3$_i[1];\n      model.variables[varName][\"demand_\".concat(pieceLength)] = count;\n    }\n\n    // Ajouter la contribution aux contraintes de stock\n    if (stockLengths.has(pattern.stockLength)) {\n      model.variables[varName][\"stock_\".concat(pattern.stockLength)] = 1;\n    }\n  }\n  console.log(\"Modèle ILP créé:\");\n  console.log(\"- Contraintes:\", Object.keys(model.constraints).length);\n  console.log(\"- Variables:\", Object.keys(model.variables).length);\n  return model;\n}\n\n/**\n * Génère des patterns sur mesure qui évitent strictement la surproduction\n * @param {Array} stockBars - Barres mères disponibles\n * @param {Array} demandPieces - Pièces à découper\n * @returns {Array} Patterns adaptés sans surproduction\n */\nfunction generateSafePatterns(stockBars, demandPieces) {\n  console.log(\"Génération de patterns sans risque de surproduction...\");\n\n  // Créer une copie des patterns standards\n  var basicPatterns = generatePatternsForBars(stockBars, demandPieces);\n\n  // Éliminer tout pattern qui pourrait causer une surproduction\n  var safePatterns = [];\n\n  // Créer un tableau pour suivre le nombre maximal de fois qu'un pattern peut être utilisé\n  var patternMaxUsage = new Map();\n\n  // Pour chaque pattern, calculer combien de fois il peut être utilisé sans surproduction\n  var _iterator1 = _createForOfIteratorHelper(basicPatterns),\n    _step1;\n  try {\n    for (_iterator1.s(); !(_step1 = _iterator1.n()).done;) {\n      var pattern = _step1.value;\n      var pieceCounts = {};\n      var _iterator10 = _createForOfIteratorHelper(pattern.pieces),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var pieceLength = _step10.value;\n          pieceCounts[pieceLength] = (pieceCounts[pieceLength] || 0) + 1;\n        }\n\n        // Vérifier que ce pattern pourrait être utilisé au moins une fois\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      var minUsageCount = Infinity;\n      var hasPieces = false;\n      var _loop2 = function _loop2() {\n        var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i5], 2),\n          pieceLength = _Object$entries4$_i[0],\n          count = _Object$entries4$_i[1];\n        hasPieces = true;\n        var lengthInt = parseInt(pieceLength, 10);\n\n        // Trouver la pièce correspondante dans la demande\n        var demandPiece = demandPieces.find(function (p) {\n          return p.length === lengthInt;\n        });\n        if (demandPiece) {\n          // Calculer combien de fois ce pattern peut être utilisé\n          var maxUsage = Math.floor(demandPiece.quantity / count);\n          minUsageCount = Math.min(minUsageCount, maxUsage);\n        } else {\n          // Ce pattern utilise une pièce qui n'est pas demandée\n          minUsageCount = 0;\n          return 1; // break\n        }\n      };\n      for (var _i5 = 0, _Object$entries4 = Object.entries(pieceCounts); _i5 < _Object$entries4.length; _i5++) {\n        if (_loop2()) break;\n      }\n\n      // Si ce pattern peut être utilisé, l'ajouter à la liste\n      if (minUsageCount > 0 && hasPieces) {\n        safePatterns.push(pattern);\n        patternMaxUsage.set(pattern, minUsageCount);\n      }\n    }\n  } catch (err) {\n    _iterator1.e(err);\n  } finally {\n    _iterator1.f();\n  }\n  console.log(\"\".concat(safePatterns.length, \" patterns s\\xFBrs g\\xE9n\\xE9r\\xE9s (sur \").concat(basicPatterns.length, \" patterns initiaux)\"));\n  return {\n    patterns: safePatterns,\n    maxUsage: patternMaxUsage\n  };\n}\nfunction solveWithColumnGeneration(patterns, stockBars, demandPieces) {\n  console.log(\"Exécution de la génération de colonnes...\");\n\n  // Solution finale à construire\n  var solution = {\n    feasible: true,\n    result: 0\n  };\n  var selectedPatterns = new Map();\n\n  // Créer une copie des demandes qu'on va satisfaire progressivement\n  var remainingDemand = new Map();\n  console.log(\"\\n📋 RÉSUMÉ DES PIÈCES À DÉCOUPER:\");\n  console.log(\"─────────────────────────────────────────────────────\");\n  var _iterator11 = _createForOfIteratorHelper(demandPieces),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var piece = _step11.value;\n      remainingDemand.set(piece.length, piece.quantity);\n      console.log(\"  \\u2022 Pi\\xE8ce de longueur \".concat(piece.length, \": \").concat(piece.quantity, \" unit\\xE9s demand\\xE9es\"));\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n  console.log(\"─────────────────────────────────────────────────────\\n\");\n\n  // Garder trace des barres disponibles\n  var availableStock = new Map();\n  var _iterator12 = _createForOfIteratorHelper(stockBars),\n    _step12;\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var bar = _step12.value;\n      if (availableStock.has(bar.length)) {\n        availableStock.set(bar.length, availableStock.get(bar.length) + bar.quantity);\n      } else {\n        availableStock.set(bar.length, bar.quantity);\n      }\n    }\n\n    // Garder trace du nombre maximum de fois que chaque pattern peut être utilisé\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n  var patternUsageLimits = new Map();\n  var patternCurrentUsage = new Map();\n\n  // Initialiser les limites d'utilisation des patterns en fonction des demandes\n  for (var i = 0; i < patterns.length; i++) {\n    var pattern = patterns[i];\n\n    // Compter les pièces par longueur dans ce pattern\n    var pieceCounts = {};\n    var _iterator13 = _createForOfIteratorHelper(pattern.pieces),\n      _step13;\n    try {\n      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n        var _pieceLength3 = _step13.value;\n        pieceCounts[_pieceLength3] = (pieceCounts[_pieceLength3] || 0) + 1;\n      }\n\n      // Calculer le nombre maximum de fois que ce pattern peut être utilisé\n    } catch (err) {\n      _iterator13.e(err);\n    } finally {\n      _iterator13.f();\n    }\n    var maxUsage = Infinity;\n    for (var _i6 = 0, _Object$entries5 = Object.entries(pieceCounts); _i6 < _Object$entries5.length; _i6++) {\n      var _Object$entries5$_i = _slicedToArray(_Object$entries5[_i6], 2),\n        pieceLength = _Object$entries5$_i[0],\n        count = _Object$entries5$_i[1];\n      var lengthInt = parseInt(pieceLength, 10);\n      var demand = remainingDemand.get(lengthInt) || 0;\n      if (count > 0) {\n        maxUsage = Math.min(maxUsage, Math.floor(demand / count));\n      }\n    }\n\n    // Stocker cette limite\n    patternUsageLimits.set(i, maxUsage);\n    patternCurrentUsage.set(i, 0);\n  }\n\n  // Algorithme de column generation simplifié\n  var iteration = 0;\n  var maxIterations = 100;\n  console.log(\"\\n🔄 DÉMARRAGE DES ITÉRATIONS\");\n  console.log(\"─────────────────────────────────────────────────────\");\n\n  // Tant qu'il reste des pièces à découper et qu'on n'a pas atteint le max d'itérations\n  while (Array.from(remainingDemand.values()).some(function (qty) {\n    return qty > 0;\n  }) && iteration < maxIterations) {\n    iteration++;\n    console.log(\"\\n\\uD83D\\uDCCC IT\\xC9RATION \".concat(iteration, \" :\"));\n\n    // État actuel de la demande\n    var demandStatusLog = [];\n    var _iterator14 = _createForOfIteratorHelper(remainingDemand.entries()),\n      _step14;\n    try {\n      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n        var _step14$value = _slicedToArray(_step14.value, 2),\n          length = _step14$value[0],\n          qty = _step14$value[1];\n        if (qty > 0) {\n          demandStatusLog.push(\"\".concat(qty, \"x\").concat(length));\n        }\n      }\n    } catch (err) {\n      _iterator14.e(err);\n    } finally {\n      _iterator14.f();\n    }\n    if (demandStatusLog.length === 0) {\n      console.log(\"✅ Toutes les pièces ont été satisfaites!\");\n      break;\n    }\n    console.log(\"  \\u2022 Demande restante: \".concat(demandStatusLog.join(', ')));\n\n    // 1. PHASE DE PRICING: Trouver le meilleur pattern pour la demande restante\n    var bestPattern = null;\n    var bestScore = -Infinity;\n    var bestPatternIndex = -1;\n    for (var _i7 = 0; _i7 < patterns.length; _i7++) {\n      var _pattern = patterns[_i7];\n\n      // Vérifier si ce pattern a atteint sa limite d'utilisation\n      var currentUsage = patternCurrentUsage.get(_i7) || 0;\n      var _maxUsage = patternUsageLimits.get(_i7) || 0;\n      if (currentUsage >= _maxUsage) {\n        // Pattern déjà utilisé au maximum, ignorer\n        continue;\n      }\n\n      // Calculer la valeur de ce pattern pour la demande restante\n      var score = 0;\n      var useful = false;\n\n      // Compter les pièces de chaque type dans ce pattern\n      var _pieceCounts = {};\n      var _iterator15 = _createForOfIteratorHelper(_pattern.pieces),\n        _step15;\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var _pieceLength6 = _step15.value;\n          _pieceCounts[_pieceLength6] = (_pieceCounts[_pieceLength6] || 0) + 1;\n        }\n\n        // Évaluer ce pattern\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n      for (var _i8 = 0, _Object$entries6 = Object.entries(_pieceCounts); _i8 < _Object$entries6.length; _i8++) {\n        var _Object$entries6$_i = _slicedToArray(_Object$entries6[_i8], 2),\n          _pieceLength4 = _Object$entries6$_i[0],\n          _count2 = _Object$entries6$_i[1];\n        var _lengthInt = parseInt(_pieceLength4, 10);\n        var demandLeft = remainingDemand.get(_lengthInt) || 0;\n        if (demandLeft > 0) {\n          useful = true;\n          // Récompense pour chaque pièce satisfaite (proportionnelle à sa taille)\n          // Ne compter que les pièces qui sont réellement nécessaires (pas plus que la demande)\n          var usableCount = Math.min(_count2, demandLeft);\n          score += usableCount * _lengthInt;\n        }\n      }\n\n      // Si le pattern contient des pièces qui ne sont plus nécessaires,\n      // il devrait être fortement pénalisé ou ignoré complètement\n      var isPatternViable = true; // Commencer par supposer que le pattern est viable\n\n      // Pénaliser le gaspillage et les pièces superflues\n      var overproduction = 0;\n      var totalOverproduction = 0;\n      var hasCriticalOverproduction = false;\n      for (var _i9 = 0, _Object$entries7 = Object.entries(_pieceCounts); _i9 < _Object$entries7.length; _i9++) {\n        var _Object$entries7$_i = _slicedToArray(_Object$entries7[_i9], 2),\n          _pieceLength5 = _Object$entries7$_i[0],\n          _count3 = _Object$entries7$_i[1];\n        var _lengthInt2 = parseInt(_pieceLength5, 10);\n        var _demandLeft = remainingDemand.get(_lengthInt2) || 0;\n        if (_count3 > _demandLeft) {\n          // Comptabiliser la surproduction\n          var excessCount = _count3 - _demandLeft;\n          overproduction += 1; // Pénalité par type de pièce en surproduction\n          totalOverproduction += excessCount; // Nombre total de pièces en surproduction\n\n          // Si la demande est à zéro mais qu'on produirait quand même, pénalité encore plus forte\n          if (_demandLeft === 0) {\n            hasCriticalOverproduction = true;\n            // Marquer ce pattern comme non viable s'il produirait des pièces \n            // dont on n'a plus besoin du tout\n            isPatternViable = false;\n          }\n        }\n      }\n\n      // Ne considérer les patterns non viables que s'ils sont vraiment nécessaires\n      if (!isPatternViable) {\n        // Pénaliser très fortement, sauf s'il n'y a pas d'autre choix\n        score = -1000;\n      } else {\n        // Pénalités progressives pour dissuader la surproduction\n        var wastePenalty = _pattern.waste * 2;\n        var overproductionPenalty = overproduction * 15;\n        var totalOverproductionPenalty = totalOverproduction * 10;\n        var criticalPenalty = hasCriticalOverproduction ? 200 : 0;\n        score -= wastePenalty + overproductionPenalty + totalOverproductionPenalty + criticalPenalty;\n      }\n\n      // Actualiser si c'est le meilleur pattern jusqu'à présent\n      if (useful && score > bestScore) {\n        bestScore = score;\n        bestPattern = _pattern;\n        bestPatternIndex = _i7;\n      }\n    }\n\n    // Si aucun pattern utile n'a été trouvé, générer un nouveau pattern spécifique\n    if (bestPattern === null) {\n      // Essayer de générer un pattern sur mesure pour la demande restante\n      bestPattern = generateCustomPattern(remainingDemand, stockBars);\n      bestPatternIndex = patterns.length; // Un nouvel index virtuel\n\n      if (bestPattern) {\n        patterns.push(bestPattern);\n        console.log(\"Nouveau pattern g\\xE9n\\xE9r\\xE9 \\xE0 l'it\\xE9ration \".concat(iteration));\n      } else {\n        console.warn(\"\\u26A0\\uFE0F Impossible de satisfaire toute la demande \\xE0 l'it\\xE9ration \".concat(iteration));\n        break;\n      }\n    }\n\n    // 2. PHASE DE MASTER PROBLEM: Appliquer ce pattern\n    if (bestPattern) {\n      // Vérifier si nous avons suffisamment de barres mères de cette longueur\n      var stockLength = bestPattern.stockLength;\n      var availableCount = availableStock.get(stockLength) || 0;\n      if (availableCount <= 0) {\n        // Plus de barres mères de cette longueur disponibles, essayer un autre pattern\n        console.log(\"\\u26A0\\uFE0F Plus de barres m\\xE8res de longueur \".concat(stockLength, \" disponibles\"));\n        patterns.splice(bestPatternIndex, 1); // Retirer ce pattern de la liste\n        continue;\n      }\n\n      // Adapter le pattern pour éviter la surproduction\n      var modifiedPattern = adaptPatternToPreventOverproduction(bestPattern, remainingDemand, iteration);\n\n      // Ne pas utiliser le pattern s'il n'a plus de pièces utiles après adaptation\n      if (!modifiedPattern.hasUsablePieces) {\n        console.log(\"  \\u2022 Pattern ignor\\xE9 car aucune pi\\xE8ce n'est n\\xE9cessaire apr\\xE8s adaptation\");\n        continue;\n      }\n\n      // Décrémenter le stock disponible\n      availableStock.set(stockLength, availableCount - 1);\n\n      // Créer un nouvel index pour ce pattern modifié\n      var modifiedPatternIndex = \"modified_\".concat(bestPatternIndex, \"_\").concat(iteration);\n\n      // Incrémenter le compteur de ce pattern modifié\n      var varName = \"pattern_\".concat(modifiedPatternIndex);\n      solution[varName] = (solution[varName] || 0) + 1;\n\n      // Mettre à jour l'utilisation de ce pattern\n      patternCurrentUsage.set(bestPatternIndex, (patternCurrentUsage.get(bestPatternIndex) || 0) + 1);\n\n      // Utiliser le pattern modifié au lieu du pattern d'origine\n      bestPattern = modifiedPattern;\n\n      // Garder trace des patterns modifiés\n      // Important: Stocker le modifiedPattern avec le nouvel index pour le retrouver lors du traitement final\n      patterns[modifiedPatternIndex] = modifiedPattern;\n\n      // Garder trace des patterns sélectionnés\n      if (selectedPatterns.has(modifiedPatternIndex)) {\n        selectedPatterns.set(modifiedPatternIndex, selectedPatterns.get(modifiedPatternIndex) + 1);\n      } else {\n        selectedPatterns.set(modifiedPatternIndex, 1);\n      }\n\n      // Incrémenter le nombre total de barres utilisées\n      solution.result++;\n    }\n  }\n\n  // Vérifier s'il reste des pièces non satisfaites\n  var remainingPieces = Array.from(remainingDemand.entries()).filter(function (_ref7) {\n    var _ref8 = _slicedToArray(_ref7, 2),\n      _ = _ref8[0],\n      qty = _ref8[1];\n    return qty > 0;\n  }).map(function (_ref9) {\n    var _ref0 = _slicedToArray(_ref9, 2),\n      len = _ref0[0],\n      qty = _ref0[1];\n    return {\n      length: len,\n      quantity: qty\n    };\n  });\n  if (remainingPieces.length > 0) {\n    console.warn(\"\\u26A0\\uFE0F \".concat(remainingPieces.length, \" types de pi\\xE8ces non satisfaites apr\\xE8s column generation\"));\n\n    // Dernière chance: utiliser un algorithme glouton direct pour les pièces restantes\n    var additionalSolution = solveRemainingPiecesGreedy(remainingPieces, stockBars);\n\n    // Fusionner les solutions\n    for (var _i0 = 0, _Object$entries8 = Object.entries(additionalSolution); _i0 < _Object$entries8.length; _i0++) {\n      var _Object$entries8$_i = _slicedToArray(_Object$entries8[_i0], 2),\n        key = _Object$entries8$_i[0],\n        value = _Object$entries8$_i[1];\n      if (key === 'result') {\n        solution.result += value;\n      } else if (key.startsWith('pattern_')) {\n        solution[key] = (solution[key] || 0) + value;\n      }\n    }\n  }\n  console.log(\"Column Generation termin\\xE9e: \".concat(solution.result, \" barres utilis\\xE9es\"));\n  return {\n    method: \"ColumnGeneration\",\n    solution: solution,\n    patterns: patterns\n  };\n}\n\n/**\n * Génère un pattern sur mesure pour satisfaire une demande spécifique\n * Utile quand les patterns existants ne sont pas adaptés\n * @param {Map} demandMap - Mapping des demandes restantes\n * @param {Array} stockBars - Barres mères disponibles\n * @returns {Object} Pattern généré, ou null si impossible\n */\nfunction generateCustomPattern(demandMap, stockBars) {\n  // Trouver la barre mère la plus appropriée\n  var bestBar = stockBars[0]; // Par défaut, prendre la première\n\n  // Déterminer les pièces encore nécessaires, triées par taille décroissante\n  var remainingPieces = [];\n  var _iterator16 = _createForOfIteratorHelper(demandMap.entries()),\n    _step16;\n  try {\n    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n      var _step16$value = _slicedToArray(_step16.value, 2),\n        length = _step16$value[0],\n        quantity = _step16$value[1];\n      if (quantity > 0) {\n        remainingPieces.push({\n          length: parseInt(length, 10),\n          quantity: quantity\n        });\n      }\n    }\n\n    // Si aucune pièce restante, retourner null\n  } catch (err) {\n    _iterator16.e(err);\n  } finally {\n    _iterator16.f();\n  }\n  if (remainingPieces.length === 0) return null;\n\n  // Trier par ordre décroissant de longueur\n  remainingPieces.sort(function (a, b) {\n    return b.length - a.length;\n  });\n\n  // Essayer de générer un pattern pour chaque barre disponible\n  var bestPattern = null;\n  var bestScore = -Infinity;\n  var _iterator17 = _createForOfIteratorHelper(stockBars),\n    _step17;\n  try {\n    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n      var bar = _step17.value;\n      var stockLength = bar.length;\n\n      // Algorithme du sac à dos pour maximiser l'utilisation de la barre\n      var pattern = knapsackForPattern(remainingPieces, stockLength);\n\n      // Évaluer ce pattern\n      if (pattern && pattern.pieces.length > 0) {\n        // Score = rapport entre la somme des longueurs et la longueur de la barre\n        var utilizationRatio = (stockLength - pattern.waste) / stockLength;\n\n        // Préférer les patterns qui utilisent bien la barre\n        if (utilizationRatio > 0.5 && utilizationRatio > bestScore) {\n          bestScore = utilizationRatio;\n          bestPattern = pattern;\n          bestPattern.stockLength = stockLength;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator17.e(err);\n  } finally {\n    _iterator17.f();\n  }\n  return bestPattern;\n}\n\n/**\n * Résout un problème de sac à dos pour générer un pattern optimisé\n * @param {Array} pieces - Pièces disponibles\n * @param {Number} capacity - Capacité (longueur de la barre)\n * @returns {Object} Pattern généré\n */\nfunction knapsackForPattern(pieces, capacity) {\n  // Algorithme du sac à dos modifié pour le problème de cutting stock\n  var n = pieces.length;\n  var dp = Array(capacity + 1).fill(0);\n  var selected = Array(capacity + 1).fill().map(function () {\n    return [];\n  });\n\n  // Phase 1: Résoudre le problème du sac à dos\n  for (var i = 0; i < n; i++) {\n    var piece = pieces[i];\n    for (var j = capacity; j >= piece.length; j--) {\n      // Limiter le nombre de copies de chaque pièce à sa quantité\n      for (var k = 1; k <= piece.quantity; k++) {\n        if (j >= k * piece.length) {\n          var newValue = dp[j - k * piece.length] + k * piece.length;\n          if (newValue > dp[j]) {\n            dp[j] = newValue;\n            selected[j] = _toConsumableArray(selected[j - k * piece.length]);\n\n            // Ajouter k copies de cette pièce\n            for (var l = 0; l < k; l++) {\n              selected[j].push(piece.length);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Phase 2: Reconstruire la solution\n  var patternPieces = selected[capacity];\n  var waste = capacity - dp[capacity];\n\n  // Compter les occurrences de chaque pièce\n  var composition = {};\n  var _iterator18 = _createForOfIteratorHelper(patternPieces),\n    _step18;\n  try {\n    for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n      var pieceLength = _step18.value;\n      composition[pieceLength] = (composition[pieceLength] || 0) + 1;\n    }\n  } catch (err) {\n    _iterator18.e(err);\n  } finally {\n    _iterator18.f();\n  }\n  return {\n    pieces: patternPieces,\n    waste: waste,\n    composition: composition\n  };\n}\n\n/**\n * Résout le problème pour les pièces restantes avec un algorithme glouton\n * @param {Array} remainingPieces - Pièces restantes\n * @param {Array} stockBars - Barres mères disponibles\n * @returns {Object} Solution pour les pièces restantes\n */\nfunction solveRemainingPiecesGreedy(remainingPieces, stockBars) {\n  console.log(\"Résolution des pièces restantes avec algorithme glouton\");\n\n  // Créer une copie du stock disponible\n  var availableBarsByLength = new Map();\n  var _iterator19 = _createForOfIteratorHelper(stockBars),\n    _step19;\n  try {\n    for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n      var bar = _step19.value;\n      if (availableBarsByLength.has(bar.length)) {\n        availableBarsByLength.set(bar.length, availableBarsByLength.get(bar.length) + bar.quantity);\n      } else {\n        availableBarsByLength.set(bar.length, bar.quantity);\n      }\n    }\n\n    // Vérifier si nous avons encore des barres disponibles\n  } catch (err) {\n    _iterator19.e(err);\n  } finally {\n    _iterator19.f();\n  }\n  var totalAvailableBars = Array.from(availableBarsByLength.values()).reduce(function (acc, val) {\n    return acc + val;\n  }, 0);\n  if (totalAvailableBars === 0) {\n    console.warn(\"⚠️ Plus aucune barre mère disponible pour les pièces restantes\");\n    return {\n      feasible: false,\n      result: 0\n    };\n  }\n\n  // Trier les barres mères par longueur décroissante\n  var sortedBars = Array.from(availableBarsByLength.entries()).sort(function (a, b) {\n    return b[0] - a[0];\n  });\n\n  // Obtenir la barre mère la plus adaptée pour chaque pièce\n  var stockLength = sortedBars[0][0]; // Par défaut, prendre la plus grande\n\n  // Préparer toutes les pièces restantes dans un tableau plat\n  var allPieces = [];\n  var _iterator20 = _createForOfIteratorHelper(remainingPieces),\n    _step20;\n  try {\n    for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n      var piece = _step20.value;\n      for (var _i11 = 0; _i11 < piece.quantity; _i11++) {\n        allPieces.push(piece.length);\n      }\n    }\n\n    // Trier les pièces par ordre décroissant\n  } catch (err) {\n    _iterator20.e(err);\n  } finally {\n    _iterator20.f();\n  }\n  allPieces.sort(function (a, b) {\n    return b - a;\n  });\n\n  // First-Fit Decreasing\n  var bars = [];\n  var solution = {\n    feasible: true,\n    result: 0\n  };\n  for (var _i1 = 0, _allPieces = allPieces; _i1 < _allPieces.length; _i1++) {\n    var pieceLength = _allPieces[_i1];\n    var placed = false;\n\n    // Essayer de placer dans une barre existante\n    for (var i = 0; i < bars.length; i++) {\n      if (bars[i].remainingSpace >= pieceLength) {\n        bars[i].pieces.push(pieceLength);\n        bars[i].remainingSpace -= pieceLength;\n        placed = true;\n        break;\n      }\n    }\n\n    // Si non placée, créer une nouvelle barre\n    if (!placed) {\n      // Trouver la barre la plus petite qui peut contenir cette pièce\n      var bestFitBarLength = null;\n      var _iterator21 = _createForOfIteratorHelper(availableBarsByLength.entries()),\n        _step21;\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var _step21$value = _slicedToArray(_step21.value, 2),\n            barLength = _step21$value[0],\n            quantity = _step21$value[1];\n          if (quantity > 0 && barLength >= pieceLength && (bestFitBarLength === null || barLength < bestFitBarLength)) {\n            bestFitBarLength = barLength;\n          }\n        }\n\n        // Vérifier si nous avons trouvé une barre disponible\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n      if (bestFitBarLength === null) {\n        console.warn(\"\\u26A0\\uFE0F Plus de barres disponibles pour la pi\\xE8ce de longueur \".concat(pieceLength));\n        continue; // Passer à la pièce suivante\n      }\n\n      // Réduire la quantité disponible\n      availableBarsByLength.set(bestFitBarLength, availableBarsByLength.get(bestFitBarLength) - 1);\n\n      // Créer une nouvelle barre\n      bars.push({\n        pieces: [pieceLength],\n        remainingSpace: bestFitBarLength - pieceLength,\n        stockLength: bestFitBarLength\n      });\n      solution.result++;\n    }\n  }\n\n  // Convertir en format pattern_X\n  for (var _i10 = 0; _i10 < bars.length; _i10++) {\n    var patternKey = \"pattern_extra_\".concat(_i10);\n    solution[patternKey] = 1;\n  }\n  return solution;\n}\n\n/**\n * Algorithme glouton simple (fallback de secours)\n * @param {Array} stockBars - Barres mères disponibles\n * @param {Array} demandPieces - Pièces à découper\n * @returns {Object} Résultats de l'algorithme glouton\n */\nfunction solveWithSimpleGreedy(stockBars, demandPieces) {\n  console.log(\"Utilisation de l'algorithme glouton simple\");\n\n  // Créer une carte des barres disponibles par longueur\n  var availableBarsByLength = new Map();\n  var _iterator22 = _createForOfIteratorHelper(stockBars),\n    _step22;\n  try {\n    for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n      var _bar2 = _step22.value;\n      if (availableBarsByLength.has(_bar2.length)) {\n        availableBarsByLength.set(_bar2.length, availableBarsByLength.get(_bar2.length) + _bar2.quantity);\n      } else {\n        availableBarsByLength.set(_bar2.length, _bar2.quantity);\n      }\n    }\n\n    // Vérifier si nous avons des barres disponibles\n  } catch (err) {\n    _iterator22.e(err);\n  } finally {\n    _iterator22.f();\n  }\n  var totalAvailableBars = Array.from(availableBarsByLength.values()).reduce(function (acc, val) {\n    return acc + val;\n  }, 0);\n  if (totalAvailableBars === 0) {\n    console.warn(\"⚠️ Aucune barre mère disponible\");\n    return {\n      rawData: {\n        usedBars: [],\n        wasteLength: 0,\n        totalMotherBarsUsed: 0,\n        remainingPieces: demandPieces,\n        motherBarLength: 0\n      },\n      layouts: []\n    };\n  }\n\n  // Extraire les longueurs des barres mères disponibles\n  var availableLengths = Array.from(availableBarsByLength.keys()).sort(function (a, b) {\n    return b - a;\n  });\n  var motherBarLength = availableLengths[0]; // La plus grande\n\n  // Créer un tableau plat de toutes les pièces\n  var allPieces = [];\n  var _iterator23 = _createForOfIteratorHelper(demandPieces),\n    _step23;\n  try {\n    for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n      var piece = _step23.value;\n      for (var _i15 = 0; _i15 < piece.quantity; _i15++) {\n        allPieces.push(piece.length);\n      }\n    }\n\n    // Trier les pièces par ordre décroissant\n  } catch (err) {\n    _iterator23.e(err);\n  } finally {\n    _iterator23.f();\n  }\n  allPieces.sort(function (a, b) {\n    return b - a;\n  });\n\n  // First-Fit Decreasing\n  var usedBars = [];\n  var currentBarIndex = -1;\n  for (var _i12 = 0, _allPieces2 = allPieces; _i12 < _allPieces2.length; _i12++) {\n    var pieceLength = _allPieces2[_i12];\n    var placed = false;\n\n    // Essayer de placer dans une barre existante\n    for (var i = 0; i <= currentBarIndex; i++) {\n      if (usedBars[i].remainingSpace >= pieceLength) {\n        usedBars[i].pieces.push(pieceLength);\n        usedBars[i].cuts.push(pieceLength); // Mise à jour pour compatibilité\n        usedBars[i].remainingSpace -= pieceLength;\n        usedBars[i].remainingLength -= pieceLength; // Mise à jour pour compatibilité\n        placed = true;\n        break;\n      }\n    }\n\n    // Si non placée, créer une nouvelle barre\n    if (!placed) {\n      // Trouver la barre la plus petite qui peut contenir cette pièce\n      var bestFitBarLength = null;\n      var _iterator24 = _createForOfIteratorHelper(availableLengths),\n        _step24;\n      try {\n        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n          var barLength = _step24.value;\n          if (availableBarsByLength.get(barLength) > 0 && barLength >= pieceLength && (bestFitBarLength === null || barLength < bestFitBarLength)) {\n            bestFitBarLength = barLength;\n          }\n        }\n\n        // Si aucune barre disponible, considérer cette pièce comme non satisfaite\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n      if (bestFitBarLength === null) {\n        console.warn(\"\\u26A0\\uFE0F Plus de barres disponibles pour la pi\\xE8ce de longueur \".concat(pieceLength));\n        continue; // Passer à la pièce suivante sans la placer\n      }\n\n      // Réduire le stock de barres disponibles\n      availableBarsByLength.set(bestFitBarLength, availableBarsByLength.get(bestFitBarLength) - 1);\n\n      // Créer la nouvelle barre\n      currentBarIndex++;\n      usedBars[currentBarIndex] = {\n        id: currentBarIndex + 1,\n        pieces: [pieceLength],\n        remainingSpace: bestFitBarLength - pieceLength,\n        originalLength: bestFitBarLength,\n        // Ajout pour compatibilité\n        cuts: [pieceLength],\n        remainingLength: bestFitBarLength - pieceLength\n      };\n    }\n  }\n\n  // Calculer le total des déchets\n  var wasteLength = 0;\n  for (var _i13 = 0, _usedBars = usedBars; _i13 < _usedBars.length; _i13++) {\n    var bar = _usedBars[_i13];\n    wasteLength += bar.remainingSpace;\n  }\n\n  // Regrouper les barres par layout identique\n  var layoutPatterns = {};\n  for (var _i14 = 0, _usedBars2 = usedBars; _i14 < _usedBars2.length; _i14++) {\n    var _bar = _usedBars2[_i14];\n    // Créer une clé unique pour ce layout (arrangement de pièces)\n    var layoutKey = _bar.pieces.slice().sort(function (a, b) {\n      return b - a;\n    }).join(',');\n    if (!layoutPatterns[layoutKey]) {\n      layoutPatterns[layoutKey] = {\n        count: 1,\n        pieces: _bar.pieces.slice().sort(function (a, b) {\n          return b - a;\n        }),\n        waste: _bar.remainingSpace,\n        totalLength: _bar.originalLength - _bar.remainingSpace,\n        // Ajout des propriétés pour la compatibilité\n        cuts: _bar.pieces.slice().sort(function (a, b) {\n          return b - a;\n        }),\n        remainingLength: _bar.remainingSpace,\n        originalLength: _bar.originalLength\n      };\n    } else {\n      layoutPatterns[layoutKey].count++;\n    }\n  }\n\n  // Convertir en tableau et trier\n  var layoutsArray = Object.values(layoutPatterns);\n  layoutsArray.sort(function (a, b) {\n    return b.count - a.count;\n  });\n  return {\n    rawData: {\n      usedBars: usedBars,\n      wasteLength: wasteLength,\n      totalMotherBarsUsed: usedBars.length,\n      remainingPieces: [],\n      // Toutes les pièces sont découpées\n      motherBarLength: motherBarLength\n    },\n    layouts: layoutsArray\n  };\n}\n\n/**\n * Traite les résultats bruts de l'optimisation pour générer un résultat structuré\n * @param {Object} optimizationResult - Résultats bruts\n * @param {Array} stockBars - Barres mères disponibles\n * @param {Array} demandPieces - Pièces à découper\n * @returns {Object} Résultats structurés\n */\nfunction processOptimizationResult(optimizationResult, stockBars, demandPieces) {\n  var method = optimizationResult.method,\n    solution = optimizationResult.solution,\n    patterns = optimizationResult.patterns;\n\n  // Si pas de patterns, retourner une solution vide\n  if (!patterns || patterns.length === 0) {\n    return {\n      rawData: {\n        usedBars: [],\n        wasteLength: 0,\n        totalMotherBarsUsed: 0,\n        remainingPieces: demandPieces,\n        motherBarLength: stockBars.length > 0 ? stockBars[0].length : 0\n      },\n      layouts: []\n    };\n  }\n  console.log(\"Traitement des r\\xE9sultats (m\\xE9thode: \".concat(method, \")\"));\n\n  // Structures pour la solution\n  var usedBars = [];\n  var placedPieces = new Map();\n  var wasteLength = 0;\n  var barId = 1;\n\n  // Initialiser le compteur de pièces placées\n  var _iterator25 = _createForOfIteratorHelper(demandPieces),\n    _step25;\n  try {\n    for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n      var piece = _step25.value;\n      placedPieces.set(piece.length, 0);\n    }\n\n    // Traiter les patterns utilisés dans la solution\n  } catch (err) {\n    _iterator25.e(err);\n  } finally {\n    _iterator25.f();\n  }\n  for (var _i16 = 0, _Object$entries9 = Object.entries(solution); _i16 < _Object$entries9.length; _i16++) {\n    var _Object$entries9$_i = _slicedToArray(_Object$entries9[_i16], 2),\n      varName = _Object$entries9$_i[0],\n      countValue = _Object$entries9$_i[1];\n    // N'utiliser que les variables de type pattern_X avec une valeur positive\n    if (varName.startsWith('pattern_') && !isNaN(countValue) && countValue > 0) {\n      var patternIndex = void 0;\n\n      // Extraire l'index du pattern\n      if (varName.startsWith('pattern_extra_')) {\n        // Patterns ajoutés par l'algorithme glouton\n        continue; // On ne peut pas les tracer, ils seront gérés séparément\n      } else if (varName.startsWith('pattern_modified_')) {\n        // Pattern modifié - extraire l'ID complet\n        patternIndex = varName.replace('pattern_', '');\n      } else {\n        patternIndex = parseInt(varName.replace('pattern_', ''), 10);\n      }\n\n      // Récupérer le pattern\n      var pattern = patterns[patternIndex];\n      if (!pattern) {\n        console.warn(\"\\u26A0\\uFE0F Pattern \".concat(patternIndex, \" non trouv\\xE9 dans la collection de patterns\"));\n        continue;\n      }\n\n      // Debug pour les patterns modifiés\n      if (pattern.isModifiedPattern && pattern.originInfo) {\n        console.log(\"Application du pattern modifi\\xE9 \".concat(patternIndex, \":\"));\n        console.log(\"  \\u2022 Pi\\xE8ces d'origine: \".concat(pattern.originInfo.originalPieces.join(', ')));\n        console.log(\"  \\u2022 Pi\\xE8ces conserv\\xE9es: \".concat(pattern.pieces.join(', ')));\n        if (pattern.originInfo.removedPieces && pattern.originInfo.removedPieces.length > 0) {\n          console.log(\"  \\u2022 Pi\\xE8ces supprim\\xE9es: \".concat(pattern.originInfo.removedPieces.join(', ')));\n        }\n      }\n\n      // Utiliser ce pattern le nombre de fois indiqué\n      for (var i = 0; i < countValue; i++) {\n        // Créer une nouvelle barre utilisée\n        var bar = {\n          id: barId++,\n          pieces: _toConsumableArray(pattern.pieces),\n          waste: pattern.waste || 0,\n          originalLength: pattern.stockLength || stockBars[0].length,\n          // Ajouter des propriétés pour la compatibilité avec l'affichage\n          cuts: _toConsumableArray(pattern.pieces),\n          remainingLength: pattern.waste || 0\n        };\n        usedBars.push(bar);\n        wasteLength += pattern.waste || 0;\n\n        // Mettre à jour le compteur de pièces placées\n        var _iterator26 = _createForOfIteratorHelper(pattern.pieces),\n          _step26;\n        try {\n          for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n            var pieceLength = _step26.value;\n            placedPieces.set(pieceLength, (placedPieces.get(pieceLength) || 0) + 1);\n          }\n        } catch (err) {\n          _iterator26.e(err);\n        } finally {\n          _iterator26.f();\n        }\n      }\n    }\n  }\n\n  // Calculer les pièces restantes\n  var remainingPieces = [];\n  var _iterator27 = _createForOfIteratorHelper(demandPieces),\n    _step27;\n  try {\n    for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n      var _piece = _step27.value;\n      var placed = placedPieces.get(_piece.length) || 0;\n      var remaining = _piece.quantity - placed;\n      if (remaining > 0) {\n        remainingPieces.push({\n          length: _piece.length,\n          quantity: remaining\n        });\n      }\n    }\n\n    // S'il reste des pièces et que nous sommes dans un cas avec algorithme glouton\n  } catch (err) {\n    _iterator27.e(err);\n  } finally {\n    _iterator27.f();\n  }\n  if (remainingPieces.length > 0 && (method === \"ColumnGeneration\" || solution.greedy)) {\n    console.warn(\"\\u26A0\\uFE0F Il reste \".concat(remainingPieces.length, \" types de pi\\xE8ces non d\\xE9coup\\xE9es\"));\n\n    // Essayer de découper les pièces restantes avec l'algorithme glouton\n    var remainingResult = solveWithSimpleGreedy(stockBars, remainingPieces);\n\n    // Fusionner les résultats\n    usedBars.push.apply(usedBars, _toConsumableArray(remainingResult.rawData.usedBars));\n    wasteLength += remainingResult.rawData.wasteLength;\n\n    // Les pièces restantes sont maintenant toutes découpées\n    remainingPieces.length = 0;\n  }\n\n  // Regrouper les barres par layout identique\n  var layoutPatterns = {};\n  for (var _i17 = 0, _usedBars3 = usedBars; _i17 < _usedBars3.length; _i17++) {\n    var _bar3 = _usedBars3[_i17];\n    // Créer une clé unique pour ce layout\n    var layoutKey = _bar3.pieces.slice().sort(function (a, b) {\n      return b - a;\n    }).join(',');\n    if (!layoutPatterns[layoutKey]) {\n      // Créer une structure compatible avec les autres algorithmes\n      layoutPatterns[layoutKey] = {\n        count: 1,\n        pieces: _bar3.pieces.slice().sort(function (a, b) {\n          return b - a;\n        }),\n        waste: _bar3.waste || _bar3.remainingLength || 0,\n        totalLength: _bar3.originalLength - (_bar3.waste || _bar3.remainingLength || 0),\n        // Pour compatibilité avec la fonction d'affichage\n        cuts: _bar3.pieces.slice().sort(function (a, b) {\n          return b - a;\n        }),\n        remainingLength: _bar3.waste || _bar3.remainingLength || 0,\n        originalLength: _bar3.originalLength\n      };\n    } else {\n      layoutPatterns[layoutKey].count++;\n    }\n  }\n\n  // Convertir en tableau et trier\n  var layoutsArray = Object.values(layoutPatterns);\n  layoutsArray.sort(function (a, b) {\n    return b.count - a.count;\n  });\n  return {\n    rawData: {\n      usedBars: usedBars,\n      wasteLength: wasteLength,\n      totalMotherBarsUsed: usedBars.length,\n      remainingPieces: remainingPieces,\n      motherBarLength: stockBars.length > 0 ? stockBars[0].length : 0\n    },\n    layouts: layoutsArray\n  };\n}\n\n/**\n * Calcule les statistiques clés pour un modèle\n * @param {Object} modelResult - Résultats pour un modèle spécifique\n * @param {Array} stockBars - Barres mères disponibles\n * @param {Array} demandPieces - Pièces à découper\n * @returns {Object} Statistiques calculées\n */\nfunction calculateModelStats(modelResult, stockBars, demandPieces) {\n  // Initialiser les compteurs\n  var totalDemandLength = 0;\n  var totalStockLength = 0;\n  var totalUsedLength = 0;\n  var totalWasteLength = 0;\n\n  // Initialiser les variables de statut de production\n  var hasOverproduction = false;\n  var hasUnderproduction = false;\n  var overproductionDetails = [];\n  var underproductionDetails = [];\n  var totalOverproduced = 0;\n  var totalUnderproduced = 0;\n\n  // 1. Calculer la somme des longueurs de toutes les pièces à découper\n  var demandByPieceLength = new Map();\n  var _iterator28 = _createForOfIteratorHelper(demandPieces),\n    _step28;\n  try {\n    for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n      var piece = _step28.value;\n      totalDemandLength += piece.length * piece.quantity;\n      demandByPieceLength.set(piece.length, piece.quantity);\n    }\n\n    // 2. Calculer la somme des longueurs de toutes les barres mères disponibles\n  } catch (err) {\n    _iterator28.e(err);\n  } finally {\n    _iterator28.f();\n  }\n  var _iterator29 = _createForOfIteratorHelper(stockBars),\n    _step29;\n  try {\n    for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n      var bar = _step29.value;\n      totalStockLength += bar.length * bar.quantity;\n    }\n\n    // 3. Calculer la somme des longueurs utilisées et des chutes dans les layouts\n  } catch (err) {\n    _iterator29.e(err);\n  } finally {\n    _iterator29.f();\n  }\n  if (modelResult.layouts && modelResult.layouts.length > 0) {\n    // Garder trace des pièces découpées par longueur\n    var cutPiecesByLength = new Map();\n\n    // Réinitialiser totalWasteLength pour un calcul précis\n    totalWasteLength = 0;\n    var _iterator30 = _createForOfIteratorHelper(modelResult.layouts),\n      _step30;\n    try {\n      for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n        var layout = _step30.value;\n        // Nombre de barres de ce layout\n        var count = layout.count || 1;\n\n        // Pour chaque barre de ce layout\n        var pieces = layout.cuts || layout.pieces || [];\n\n        // Compter les pièces par longueur\n        var _iterator32 = _createForOfIteratorHelper(pieces),\n          _step32;\n        try {\n          for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n            var pieceLength = _step32.value;\n            var currentCount = cutPiecesByLength.get(pieceLength) || 0;\n            cutPiecesByLength.set(pieceLength, currentCount + count);\n          }\n        } catch (err) {\n          _iterator32.e(err);\n        } finally {\n          _iterator32.f();\n        }\n        var pieceSum = pieces.reduce(function (sum, piece) {\n          return sum + piece;\n        }, 0);\n        var wasteLength = layout.remainingLength || layout.waste || 0;\n\n        // Multiplier par le nombre de fois que ce layout est utilisé\n        totalUsedLength += pieceSum * count;\n        totalWasteLength += wasteLength * count;\n      }\n\n      // Calculer la longueur totale des barres utilisées\n    } catch (err) {\n      _iterator30.e(err);\n    } finally {\n      _iterator30.f();\n    }\n    var totalBarsLength = 0;\n    if (modelResult.rawData && modelResult.rawData.usedBars) {\n      totalBarsLength = modelResult.rawData.usedBars.reduce(function (sum, bar) {\n        return sum + bar.originalLength;\n      }, 0);\n    }\n\n    // Le taux d'utilisation correct est:\n    var correctUtilizationRate = totalBarsLength > 0 ? (totalUsedLength / totalBarsLength * 100).toFixed(3) : 0;\n\n    // Vérifier s'il y a une surproduction\n    var _iterator31 = _createForOfIteratorHelper(cutPiecesByLength.entries()),\n      _step31;\n    try {\n      for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n        var _step31$value = _slicedToArray(_step31.value, 2),\n          _pieceLength7 = _step31$value[0],\n          cutCount = _step31$value[1];\n        var demandCount = demandByPieceLength.get(_pieceLength7) || 0;\n        var diff = cutCount - demandCount;\n        if (diff > 0) {\n          hasOverproduction = true;\n          totalOverproduced += diff;\n          overproductionDetails.push(\"\".concat(diff, \" pi\\xE8ces de longueur \").concat(_pieceLength7));\n        } else if (diff < 0) {\n          hasUnderproduction = true;\n          totalUnderproduced += Math.abs(diff);\n          underproductionDetails.push(\"\".concat(Math.abs(diff), \" pi\\xE8ces de longueur \").concat(_pieceLength7));\n        }\n      }\n\n      // Afficher des avertissements clairs pour les problèmes détectés\n    } catch (err) {\n      _iterator31.e(err);\n    } finally {\n      _iterator31.f();\n    }\n    if (hasOverproduction) {\n      console.warn(\"\\u26A0\\uFE0F SURPRODUCTION: \".concat(totalOverproduced, \" pi\\xE8ces au total\"));\n    }\n    if (hasUnderproduction) {\n      console.warn(\"\\u26A0\\uFE0F PRODUCTION INCOMPL\\xC8TE: \".concat(totalUnderproduced, \" pi\\xE8ces manquantes\"));\n    }\n  }\n  return {\n    totalDemandLength: totalDemandLength,\n    totalStockLength: totalStockLength,\n    totalUsedLength: totalUsedLength,\n    totalWasteLength: totalWasteLength,\n    // Correction du calcul du taux d'utilisation\n    utilizationRate: totalUsedLength > 0 && modelResult.rawData && modelResult.rawData.usedBars && modelResult.rawData.usedBars.length > 0 ? (totalUsedLength / modelResult.rawData.usedBars.reduce(function (sum, bar) {\n      return sum + bar.originalLength;\n    }, 0) * 100).toFixed(3) : 0,\n    overproductionDetails: hasOverproduction ? overproductionDetails.join(', ') : null,\n    underproductionDetails: hasUnderproduction ? underproductionDetails.join(', ') : null,\n    hasOverproduction: hasOverproduction,\n    hasUnderproduction: hasUnderproduction,\n    totalOverproduced: totalOverproduced,\n    totalUnderproduced: totalUnderproduced\n  };\n}\n\n//# sourceURL=webpack://parser-optimizer/./src/js/algorithms/Integer-Linear-Programming.js?");

/***/ }),

/***/ "./src/js/data-manager.js":
/*!********************************!*\
  !*** ./src/js/data-manager.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataManager: () => (/* binding */ DataManager)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * DataManager - Service pur de gestion des données (CRUD)\n */\nvar DataManager = {\n  // Structure de données simplifiée\n  data: {\n    pieces: {},\n    // Barres filles groupées par modèle\n    motherBars: {},\n    // Barres mères groupées par modèle\n    barsList: [] // Liste plate de toutes les barres\n  },\n  /**\n   * Initialise les données\n   */\n  initData: function initData() {\n    this.data = {\n      pieces: {},\n      motherBars: {},\n      barsList: []\n    };\n    return this.data;\n  },\n  /**\n   * Récupère l'état des données\n   */\n  getData: function getData() {\n    return this.data;\n  },\n  /**\n   * Ajoute une liste de barres aux données\n   */\n  addBars: function addBars(bars) {\n    var _this = this;\n    if (!Array.isArray(bars) || bars.length === 0) return [];\n    var addedIds = [];\n    bars.forEach(function (bar) {\n      if (!bar) return; // Ignorer les barres nulles\n\n      // Générer un ID unique si manquant\n      if (!bar.id) {\n        bar.id = \"bar_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 5));\n      }\n\n      // Ajouter à la liste principale\n      _this.data.barsList.push(bar);\n\n      // Ajouter à la structure appropriée selon le type\n      if (bar.type === 'fille') {\n        _this._addToPieces(bar);\n      } else if (bar.type === 'mere' || bar.type === 'mother') {\n        _this._addToMotherBars(bar);\n      }\n      addedIds.push(bar.id);\n    });\n    return addedIds;\n  },\n  /**\n   * Ajoute une barre fille à la structure pieces\n   */\n  _addToPieces: function _addToPieces(bar) {\n    var model = bar.model;\n\n    // Créer l'entrée pour ce modèle si nécessaire\n    if (!this.data.pieces[model]) {\n      this.data.pieces[model] = [];\n    }\n\n    // Vérifier si une barre identique existe déjà\n    var existingIndex = this.data.pieces[model].findIndex(function (b) {\n      var _b$angles, _bar$angles, _b$angles2, _bar$angles2;\n      return b.length === bar.length && b.orientation === bar.orientation && ((_b$angles = b.angles) === null || _b$angles === void 0 ? void 0 : _b$angles.start) === ((_bar$angles = bar.angles) === null || _bar$angles === void 0 ? void 0 : _bar$angles.start) && ((_b$angles2 = b.angles) === null || _b$angles2 === void 0 ? void 0 : _b$angles2.end) === ((_bar$angles2 = bar.angles) === null || _bar$angles2 === void 0 ? void 0 : _bar$angles2.end);\n    });\n    if (existingIndex !== -1) {\n      // Mettre à jour la quantité de la barre existante\n      this.data.pieces[model][existingIndex].quantity += bar.quantity || 1;\n    } else {\n      // Ajouter la nouvelle barre\n      this.data.pieces[model].push(_objectSpread({}, bar));\n    }\n  },\n  /**\n   * Ajoute une barre mère à la structure motherBars\n   */\n  _addToMotherBars: function _addToMotherBars(bar) {\n    var model = bar.model;\n\n    // Créer l'entrée pour ce modèle si nécessaire\n    if (!this.data.motherBars[model]) {\n      this.data.motherBars[model] = [];\n    }\n\n    // Vérifier si une barre identique existe déjà\n    var existingIndex = this.data.motherBars[model].findIndex(function (b) {\n      return b.length === bar.length;\n    });\n    if (existingIndex !== -1) {\n      // Mettre à jour la quantité de la barre existante\n      this.data.motherBars[model][existingIndex].quantity += bar.quantity || 1;\n    } else {\n      // Ajouter la nouvelle barre\n      this.data.motherBars[model].push(_objectSpread({}, bar));\n    }\n  },\n  /**\n   * Supprime une pièce par son ID\n   */\n  deletePiece: function deletePiece(id) {\n    // Trouver la barre dans la liste principale\n    var barIndex = this.data.barsList.findIndex(function (b) {\n      return b.id === id && b.type === 'fille';\n    });\n    if (barIndex !== -1) {\n      var bar = this.data.barsList[barIndex];\n      var model = bar.model;\n\n      // Supprimer de la liste principale\n      this.data.barsList.splice(barIndex, 1);\n\n      // Supprimer de la structure pieces\n      if (this.data.pieces[model]) {\n        var pieceIndex = this.data.pieces[model].findIndex(function (p) {\n          return p.id === id;\n        });\n        if (pieceIndex !== -1) {\n          this.data.pieces[model].splice(pieceIndex, 1);\n\n          // Nettoyer la structure si vide\n          if (this.data.pieces[model].length === 0) {\n            delete this.data.pieces[model];\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  /**\n   * Supprime une barre mère par son ID\n   */\n  deleteMotherBar: function deleteMotherBar(id) {\n    // Trouver la barre dans la liste principale\n    var barIndex = this.data.barsList.findIndex(function (b) {\n      return b.id === id && (b.type === 'mere' || b.type === 'mother');\n    });\n    if (barIndex !== -1) {\n      var bar = this.data.barsList[barIndex];\n      var model = bar.model;\n\n      // Supprimer de la liste principale\n      this.data.barsList.splice(barIndex, 1);\n\n      // Supprimer de la structure motherBars\n      if (this.data.motherBars[model]) {\n        var barModelIndex = this.data.motherBars[model].findIndex(function (b) {\n          return b.id === id;\n        });\n        if (barModelIndex !== -1) {\n          this.data.motherBars[model].splice(barModelIndex, 1);\n\n          // Nettoyer la structure si vide\n          if (this.data.motherBars[model].length === 0) {\n            delete this.data.motherBars[model];\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  /**\n   * Met à jour la quantité d'une pièce\n   */\n  updatePieceQuantityById: function updatePieceQuantityById(id, quantity) {\n    // Parcourir la liste principale\n    for (var i = 0; i < this.data.barsList.length; i++) {\n      if (this.data.barsList[i].id === id && this.data.barsList[i].type === 'fille') {\n        // Mettre à jour dans la liste principale\n        this.data.barsList[i].quantity = quantity;\n\n        // Mettre à jour dans la structure pieces\n        var model = this.data.barsList[i].model;\n        if (this.data.pieces[model]) {\n          for (var j = 0; j < this.data.pieces[model].length; j++) {\n            if (this.data.pieces[model][j].id === id) {\n              this.data.pieces[model][j].quantity = quantity;\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  },\n  /**\n   * Met à jour la longueur d'une pièce\n   */\n  updatePieceLengthById: function updatePieceLengthById(id, length) {\n    for (var i = 0; i < this.data.barsList.length; i++) {\n      if (this.data.barsList[i].id === id && this.data.barsList[i].type === 'fille') {\n        // Mettre à jour dans la liste principale\n        this.data.barsList[i].length = length;\n\n        // Mettre à jour dans la structure pieces\n        var model = this.data.barsList[i].model;\n        if (this.data.pieces[model]) {\n          for (var j = 0; j < this.data.pieces[model].length; j++) {\n            if (this.data.pieces[model][j].id === id) {\n              this.data.pieces[model][j].length = length;\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  },\n  /**\n   * Met à jour la quantité d'une barre mère\n   */\n  updateMotherBarQuantityById: function updateMotherBarQuantityById(id, quantity) {\n    for (var i = 0; i < this.data.barsList.length; i++) {\n      if (this.data.barsList[i].id === id && (this.data.barsList[i].type === 'mere' || this.data.barsList[i].type === 'mother')) {\n        // Mettre à jour dans la liste principale\n        this.data.barsList[i].quantity = quantity;\n\n        // Mettre à jour dans la structure motherBars\n        var model = this.data.barsList[i].model;\n        if (this.data.motherBars[model]) {\n          for (var j = 0; j < this.data.motherBars[model].length; j++) {\n            if (this.data.motherBars[model][j].id === id) {\n              this.data.motherBars[model][j].quantity = quantity;\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  },\n  /**\n   * Met à jour la longueur d'une barre mère\n   */\n  updateMotherBarLengthById: function updateMotherBarLengthById(id, length) {\n    for (var i = 0; i < this.data.barsList.length; i++) {\n      if (this.data.barsList[i].id === id && (this.data.barsList[i].type === 'mere' || this.data.barsList[i].type === 'mother')) {\n        // Mettre à jour dans la liste principale\n        this.data.barsList[i].length = length;\n\n        // Mettre à jour dans la structure motherBars\n        var model = this.data.barsList[i].model;\n        if (this.data.motherBars[model]) {\n          for (var j = 0; j < this.data.motherBars[model].length; j++) {\n            if (this.data.motherBars[model][j].id === id) {\n              this.data.motherBars[model][j].length = length;\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  },\n  /**\n   * Récupère une pièce par son ID\n   * @param {string} id - ID de la pièce\n   * @returns {Object|null} La pièce ou null si non trouvée\n   */\n  getPieceById: function getPieceById(id) {\n    var piece = this.data.barsList.find(function (b) {\n      return b.id === id && b.type === 'fille';\n    });\n    return piece ? _objectSpread({}, piece) : null;\n  },\n  /**\n   * Récupère une barre mère par son ID\n   * @param {string} id - ID de la barre mère\n   * @returns {Object|null} La barre mère ou null si non trouvée\n   */\n  getMotherBarById: function getMotherBarById(id) {\n    var bar = this.data.barsList.find(function (b) {\n      return b.id === id && (b.type === 'mother' || b.type === 'mere');\n    });\n    return bar ? _objectSpread({}, bar) : null;\n  },\n  /**\n   * Met à jour une pièce avec de nouvelles valeurs\n   * @param {string} id - ID de la pièce à mettre à jour\n   * @param {Object} updatedValues - Nouvelles valeurs\n   * @returns {boolean} Succès de l'opération\n   */\n  updatePiece: function updatePiece(id, updatedValues) {\n    // Trouver la pièce dans la liste principale\n    var pieceIndex = this.data.barsList.findIndex(function (b) {\n      return b.id === id && b.type === 'fille';\n    });\n    if (pieceIndex === -1) return false;\n    var oldPiece = this.data.barsList[pieceIndex];\n    var oldModel = oldPiece.model;\n    var newModel = updatedValues.model || oldModel;\n\n    // Suppression de l'ancienne pièce de la structure pieces\n    if (this.data.pieces[oldModel]) {\n      var index = this.data.pieces[oldModel].findIndex(function (p) {\n        return p.id === id;\n      });\n      if (index !== -1) {\n        this.data.pieces[oldModel].splice(index, 1);\n        if (this.data.pieces[oldModel].length === 0) {\n          delete this.data.pieces[oldModel];\n        }\n      }\n    }\n\n    // Mise à jour de la pièce dans la liste principale\n    this.data.barsList[pieceIndex] = _objectSpread(_objectSpread({}, oldPiece), updatedValues);\n\n    // Ajout de la pièce mise à jour dans la structure pieces\n    if (!this.data.pieces[newModel]) {\n      this.data.pieces[newModel] = [];\n    }\n    this.data.pieces[newModel].push(this.data.barsList[pieceIndex]);\n    return true;\n  },\n  /**\n   * Met à jour une barre mère avec de nouvelles valeurs\n   * @param {string} id - ID de la barre mère à mettre à jour\n   * @param {Object} updatedValues - Nouvelles valeurs\n   * @returns {boolean} Succès de l'opération\n   */\n  updateMotherBar: function updateMotherBar(id, updatedValues) {\n    // Trouver la barre dans la liste principale\n    var barIndex = this.data.barsList.findIndex(function (b) {\n      return b.id === id && (b.type === 'mother' || b.type === 'mere');\n    });\n    if (barIndex === -1) return false;\n    var oldBar = this.data.barsList[barIndex];\n    var oldModel = oldBar.model;\n    var newModel = updatedValues.model || oldModel;\n\n    // Suppression de l'ancienne barre de la structure motherBars\n    if (this.data.motherBars[oldModel]) {\n      var index = this.data.motherBars[oldModel].findIndex(function (b) {\n        return b.id === id;\n      });\n      if (index !== -1) {\n        this.data.motherBars[oldModel].splice(index, 1);\n        if (this.data.motherBars[oldModel].length === 0) {\n          delete this.data.motherBars[oldModel];\n        }\n      }\n    }\n\n    // Mise à jour de la barre dans la liste principale\n    this.data.barsList[barIndex] = _objectSpread(_objectSpread({}, oldBar), updatedValues);\n\n    // Ajout de la barre mise à jour dans la structure motherBars\n    if (!this.data.motherBars[newModel]) {\n      this.data.motherBars[newModel] = [];\n    }\n    this.data.motherBars[newModel].push(this.data.barsList[barIndex]);\n    return true;\n  }\n};\n\n//# sourceURL=webpack://parser-optimizer/./src/js/data-manager.js?");

/***/ }),

/***/ "./src/js/import-manager.js":
/*!**********************************!*\
  !*** ./src/js/import-manager.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImportManager: () => (/* binding */ ImportManager)\n/* harmony export */ });\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jszip */ \"./node_modules/jszip/dist/jszip.min.js\");\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jszip__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"./src/js/index.js\");\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2); } }, _regeneratorDefine2(e, r, n, t); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n/**\n * Gestionnaire d'import pour fichiers NC2 et ZIP\n * Se concentre uniquement sur le parsing des fichiers, sans manipulation des données\n */\n\n\nvar ImportManager = {\n  /**\n   * Traite plusieurs fichiers NC2 ou un ZIP\n   * @param {FileList} files - Liste des fichiers à traiter\n   * @returns {Promise<Array>} - Tableau d'objets barre\n   */\n  processMultipleFiles: function () {\n    var _processMultipleFiles = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(files) {\n      var barres, _iterator, _step, file, fileName, content, parsedData, zipBarres, _t, _t2;\n      return _regenerator().w(function (_context) {\n        while (1) switch (_context.n) {\n          case 0:\n            barres = [];\n            _context.p = 1;\n            _iterator = _createForOfIteratorHelper(files);\n            _context.p = 2;\n            _iterator.s();\n          case 3:\n            if ((_step = _iterator.n()).done) {\n              _context.n = 8;\n              break;\n            }\n            file = _step.value;\n            fileName = file.name.toLowerCase();\n            if (!(fileName.endsWith('.nc2') || fileName.endsWith('.nc1'))) {\n              _context.n = 5;\n              break;\n            }\n            _context.n = 4;\n            return this.readFileAsText(file);\n          case 4:\n            content = _context.v;\n            parsedData = _index_js__WEBPACK_IMPORTED_MODULE_1__.Parser.parseNC2(content);\n            barres.push(this.convertToBarre(parsedData, file.name));\n            _context.n = 7;\n            break;\n          case 5:\n            if (!fileName.endsWith('.zip')) {\n              _context.n = 7;\n              break;\n            }\n            _context.n = 6;\n            return this.processZipFile(file);\n          case 6:\n            zipBarres = _context.v;\n            barres.push.apply(barres, _toConsumableArray(zipBarres));\n          case 7:\n            _context.n = 3;\n            break;\n          case 8:\n            _context.n = 10;\n            break;\n          case 9:\n            _context.p = 9;\n            _t = _context.v;\n            _iterator.e(_t);\n          case 10:\n            _context.p = 10;\n            _iterator.f();\n            return _context.f(10);\n          case 11:\n            return _context.a(2, barres);\n          case 12:\n            _context.p = 12;\n            _t2 = _context.v;\n            console.error('Erreur traitement fichiers:', _t2);\n            throw _t2;\n          case 13:\n            return _context.a(2);\n        }\n      }, _callee, this, [[2, 9, 10, 11], [1, 12]]);\n    }));\n    function processMultipleFiles(_x) {\n      return _processMultipleFiles.apply(this, arguments);\n    }\n    return processMultipleFiles;\n  }(),\n  /**\n   * Lit un fichier comme texte\n   * @param {File} file - Fichier à lire\n   * @returns {Promise<string>} - Contenu du fichier\n   */\n  readFileAsText: function readFileAsText(file) {\n    return new Promise(function (resolve, reject) {\n      var reader = new FileReader();\n      reader.onload = function () {\n        return resolve(reader.result);\n      };\n      reader.onerror = function (e) {\n        return reject(new Error(\"Erreur lecture \".concat(file.name)));\n      };\n      reader.readAsText(file);\n    });\n  },\n  /**\n   * Traite un fichier ZIP contenant des fichiers NC2\n   * @param {File} zipFile - Fichier ZIP à traiter\n   * @returns {Promise<Array>} - Tableau d'objets barre\n   */\n  processZipFile: function () {\n    var _processZipFile = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(zipFile) {\n      var barres, arrayBuffer, zip, _i, _Object$entries, _Object$entries$_i, path, zipEntry, lowerPath, content, parsedData, _t3;\n      return _regenerator().w(function (_context2) {\n        while (1) switch (_context2.n) {\n          case 0:\n            barres = [];\n            _context2.p = 1;\n            _context2.n = 2;\n            return new Promise(function (resolve, reject) {\n              var reader = new FileReader();\n              reader.onload = function () {\n                return resolve(reader.result);\n              };\n              reader.onerror = function () {\n                return reject(new Error(\"Erreur lecture ZIP\"));\n              };\n              reader.readAsArrayBuffer(zipFile);\n            });\n          case 2:\n            arrayBuffer = _context2.v;\n            _context2.n = 3;\n            return jszip__WEBPACK_IMPORTED_MODULE_0___default().loadAsync(arrayBuffer);\n          case 3:\n            zip = _context2.v;\n            _i = 0, _Object$entries = Object.entries(zip.files);\n          case 4:\n            if (!(_i < _Object$entries.length)) {\n              _context2.n = 8;\n              break;\n            }\n            _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), path = _Object$entries$_i[0], zipEntry = _Object$entries$_i[1];\n            if (!zipEntry.dir) {\n              _context2.n = 5;\n              break;\n            }\n            return _context2.a(3, 7);\n          case 5:\n            lowerPath = path.toLowerCase();\n            if (!(lowerPath.endsWith('.nc2') || lowerPath.endsWith('.nc1'))) {\n              _context2.n = 7;\n              break;\n            }\n            _context2.n = 6;\n            return zipEntry.async('string');\n          case 6:\n            content = _context2.v;\n            try {\n              parsedData = _index_js__WEBPACK_IMPORTED_MODULE_1__.Parser.parseNC2(content);\n              barres.push(this.convertToBarre(parsedData, path));\n            } catch (error) {\n              console.error(\"Erreur parsing \".concat(path, \":\"), error);\n            }\n          case 7:\n            _i++;\n            _context2.n = 4;\n            break;\n          case 8:\n            return _context2.a(2, barres);\n          case 9:\n            _context2.p = 9;\n            _t3 = _context2.v;\n            console.error(\"Erreur traitement ZIP:\", _t3);\n            throw _t3;\n          case 10:\n            return _context2.a(2);\n        }\n      }, _callee2, this, [[1, 9]]);\n    }));\n    function processZipFile(_x2) {\n      return _processZipFile.apply(this, arguments);\n    }\n    return processZipFile;\n  }(),\n  /**\n   * Convertit les données parsées en objet barre\n   * @param {Object} parsedData - Données parsées du fichier NC2\n   * @param {string} filename - Nom du fichier source\n   * @returns {Object} - Objet barre\n   */\n  convertToBarre: function convertToBarre(parsedData, filename) {\n    var _parsedData$angles, _parsedData$angles2;\n    if (!parsedData || !parsedData.profile) {\n      console.error(\"Donn\\xE9es invalides: \".concat(filename));\n      return null;\n    }\n    var shortName = filename.split('/').pop();\n\n    // Format simple de barre\n    return {\n      model: parsedData.profile || 'INCONNU',\n      profileFull: parsedData.profileFull || parsedData.profile || 'INCONNU',\n      length: parsedData.length || 0,\n      quantity: parsedData.quantity || 1,\n      flatValue: parsedData.flatValue || 0,\n      orientation: parsedData.orientation || \"a-plat\",\n      type: 'fille',\n      angles: {\n        start: ((_parsedData$angles = parsedData.angles) === null || _parsedData$angles === void 0 ? void 0 : _parsedData$angles.start) || 90,\n        end: ((_parsedData$angles2 = parsedData.angles) === null || _parsedData$angles2 === void 0 ? void 0 : _parsedData$angles2.end) || 90\n      },\n      cas: parsedData.cas || 0,\n      id: \"\".concat(shortName.replace(/\\W/g, '_'), \"_\").concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 5)),\n      originalFile: shortName\n    };\n  }\n};\n\n//# sourceURL=webpack://parser-optimizer/./src/js/import-manager.js?");

/***/ }),

/***/ "./src/js/index.js":
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Parser: () => (/* reexport safe */ _parser_js__WEBPACK_IMPORTED_MODULE_8__.Parser),\n/* harmony export */   algorithms: () => (/* binding */ algorithms)\n/* harmony export */ });\n/* harmony import */ var _css_base_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/base.css */ \"./src/css/base.css\");\n/* harmony import */ var _css_layout_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css/layout.css */ \"./src/css/layout.css\");\n/* harmony import */ var _css_components_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css/components.css */ \"./src/css/components.css\");\n/* harmony import */ var _css_sections_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../css/sections.css */ \"./src/css/sections.css\");\n/* harmony import */ var _data_manager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data-manager.js */ \"./src/js/data-manager.js\");\n/* harmony import */ var _ui_controller_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ui-controller.js */ \"./src/js/ui-controller.js\");\n/* harmony import */ var _algorithm_service_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./algorithm-service.js */ \"./src/js/algorithm-service.js\");\n/* harmony import */ var _results_renderer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./results-renderer.js */ \"./src/js/results-renderer.js\");\n/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parser.js */ \"./src/js/parser.js\");\n/* harmony import */ var _import_manager_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./import-manager.js */ \"./src/js/import-manager.js\");\n/* harmony import */ var _pgm_generator_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./pgm-generator.js */ \"./src/js/pgm-generator.js\");\n/* harmony import */ var _algorithms_First_Fit_Decreasing_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./algorithms/First-Fit-Decreasing.js */ \"./src/js/algorithms/First-Fit-Decreasing.js\");\n/* harmony import */ var _algorithms_Integer_Linear_Programming_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./algorithms/Integer-Linear-Programming.js */ \"./src/js/algorithms/Integer-Linear-Programming.js\");\n// Importer les fichiers CSS\n\n\n\n\n\n// Importer tous les modules nécessaires\n\n\n\n\n\n\n\n\n// Importer les algorithmes\n\n\n\n// Export algorithms for the algorithm service\nvar algorithms = {\n  solveGreedyFFD: _algorithms_First_Fit_Decreasing_js__WEBPACK_IMPORTED_MODULE_11__.solveGreedyFFD,\n  solveWithILP: _algorithms_Integer_Linear_Programming_js__WEBPACK_IMPORTED_MODULE_12__.solveWithILP\n};\n\n// Export parser for the import manager\n\n\n// Initialize when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', function () {\n  console.log('Parser Optimizer');\n\n  // Initialize services\n  var dataManager = _data_manager_js__WEBPACK_IMPORTED_MODULE_4__.DataManager;\n  var algorithmService = _algorithm_service_js__WEBPACK_IMPORTED_MODULE_6__.AlgorithmService;\n  var resultsRenderer = _results_renderer_js__WEBPACK_IMPORTED_MODULE_7__.ResultsRenderer;\n\n  // Initialize data\n  var data = dataManager.initData();\n\n  // Initialize UI with dependencies\n  _ui_controller_js__WEBPACK_IMPORTED_MODULE_5__.UIController.init({\n    dataManager: dataManager,\n    algorithmService: algorithmService,\n    resultsRenderer: resultsRenderer,\n    importManager: _import_manager_js__WEBPACK_IMPORTED_MODULE_9__.ImportManager,\n    pgmGenerator: _pgm_generator_js__WEBPACK_IMPORTED_MODULE_10__.PgmGenerator,\n    data: data\n  });\n\n  // Expose data for debugging\n  if (true) {\n    window.appData = data;\n    window.debug = {\n      dataManager: dataManager,\n      algorithmService: algorithmService,\n      resultsRenderer: resultsRenderer,\n      uiController: _ui_controller_js__WEBPACK_IMPORTED_MODULE_5__.UIController,\n      importManager: _import_manager_js__WEBPACK_IMPORTED_MODULE_9__.ImportManager\n    };\n  }\n});\n\n//# sourceURL=webpack://parser-optimizer/./src/js/index.js?");

/***/ }),

/***/ "./src/js/parser.js":
/*!**************************!*\
  !*** ./src/js/parser.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Parser: () => (/* binding */ Parser)\n/* harmony export */ });\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n/**\n * Parser pour fichiers NC2\n */\nvar Parser = {\n  // Configuration des valeurs à extraire\n  carteValeurs: {\n    general: {\n      'nom': {\n        ligne: 2,\n        formule: function formule(x) {\n          return String(x).replace('**', '').trim();\n        }\n      },\n      'quantite': {\n        ligne: 8,\n        formule: function formule(x) {\n          return parseInt(String(x).trim(), 10) || 1;\n        }\n      },\n      'profil': {\n        ligne: 9,\n        formule: function formule(x) {\n          return String(x).trim().substring(0, 3);\n        }\n      }\n    },\n    cas: {\n      1: {\n        'description': \"A plat - Angles de même sens\",\n        'valeur_a_plat': {\n          ligne: 13,\n          formule: function formule(x) {\n            return Math.round(parseFloat(x)) * Math.pow(10, 4);\n          }\n        },\n        'longueur': {\n          position: [2, 1, 2],\n          formule: function formule(x) {\n            return Math.round(x * 10000) / 10000;\n          }\n        },\n        'angle_54': {\n          position: [1, 4, 4],\n          formule: function formule(x) {\n            return Math.round(x * 10) / 10 + 90;\n          }\n        },\n        'angle_55': {\n          position: [1, 4, 2],\n          formule: function formule(x) {\n            return Math.round(x * 10) / 10 + 90;\n          }\n        }\n      },\n      2: {\n        'description': \"A plat - Angles de sens opposé\",\n        'valeur_a_plat': {\n          ligne: 13,\n          formule: function formule(x) {\n            return Math.round(parseFloat(x)) * Math.pow(10, 4);\n          }\n        },\n        'longueur': {\n          position: [2, 1, 2],\n          formule: function formule(x) {\n            return Math.round(x * 10000) / 10000;\n          }\n        },\n        'angle_54': {\n          position: [1, 4, 4],\n          formule: function formule(x) {\n            return Math.round(x * 10) / 10 + 90;\n          }\n        },\n        'angle_55': {\n          position: [1, 4, 2],\n          formule: function formule(x) {\n            return Math.round(x * 10) / 10 + 90;\n          }\n        }\n      },\n      3: {\n        'description': \"Debout - Angles de même sens\",\n        'valeur_a_plat': {\n          ligne: 12,\n          formule: function formule(x) {\n            return Math.round(parseFloat(x)) * Math.pow(10, 4);\n          }\n        },\n        'longueur': {\n          position: [1, 1, 2],\n          formule: function formule(x) {\n            return Math.round(x * 10000) / 10000;\n          }\n        },\n        'angle_54': {\n          position: [3, 4, 4],\n          formule: function formule(x) {\n            return Math.round(x * 10) / 10 + 90;\n          }\n        },\n        'angle_55': {\n          position: [3, 4, 2],\n          formule: function formule(x) {\n            return Math.round(x * 10) / 10 + 90;\n          }\n        }\n      },\n      4: {\n        'description': \"Debout - Angles de sens opposé\",\n        'valeur_a_plat': {\n          ligne: 12,\n          formule: function formule(x) {\n            return Math.round(parseFloat(x)) * Math.pow(10, 4);\n          }\n        },\n        'longueur': {\n          position: [1, 1, 2],\n          formule: function formule(x) {\n            return Math.round(x * 10000) / 10000;\n          }\n        },\n        'angle_54': {\n          position: [3, 4, 4],\n          formule: function formule(x) {\n            return Math.round(x * 10) / 10 + 90;\n          }\n        },\n        'angle_55': {\n          position: [3, 4, 2],\n          formule: function formule(x) {\n            return Math.round(x * 10) / 10 + 90;\n          }\n        }\n      },\n      5: {\n        'description': \"90 degres\",\n        'valeur_a_plat': {\n          ligne: 12,\n          formule: function formule(x) {\n            return Math.round(parseFloat(x)) * Math.pow(10, 4);\n          }\n        },\n        'longueur': {\n          position: [2, 1, 3],\n          formule: function formule(x) {\n            return Math.round(x * 10000) / 10000;\n          }\n        },\n        'angle_54': {\n          position: [1, 4, 4],\n          formule: function formule(x) {\n            return Math.round(x * 10) / 10 + 90;\n          }\n        },\n        'angle_55': {\n          position: [1, 4, 2],\n          formule: function formule(x) {\n            return Math.round(x * 10) / 10 + 90;\n          }\n        }\n      }\n    }\n  },\n  // Configuration pour le tableau AK\n  AK_index: {\n    'paragraphes': 3,\n    'colonnes': 6,\n    'lignes': 5,\n    'default': -0.00\n  },\n  /**\n   * Parse un fichier NC2\n   * @param {string} content - Contenu du fichier NC2\n   * @returns {Object} - Données extraites\n   */\n  parseNC2: function parseNC2(content) {\n    try {\n      console.log(\"Analyse du fichier NC2...\");\n\n      // Stockage des lignes du fichier\n      var lignes = content.split('\\n').map(function (ligne) {\n        return ligne.trim();\n      });\n      if (lignes.length < 10) {\n        throw new Error(\"Le fichier contient trop peu de lignes\");\n      }\n\n      // Créer l'objet de données extraites\n      var donneesExtraites = {\n        general: {},\n        cas: 0,\n        valeurs_specifiques: {}\n      };\n\n      // Extraire les données générales\n      for (var _i = 0, _Object$entries = Object.entries(this.carteValeurs.general); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          cle = _Object$entries$_i[0],\n          info = _Object$entries$_i[1];\n        var ligneContenu = lignes[info.ligne - 1] || '';\n        donneesExtraites.general[cle] = info.formule(ligneContenu);\n        console.log(\"\".concat(cle, \": \").concat(donneesExtraites.general[cle]));\n      }\n\n      // Extraire le nom complet du profil à partir de la ligne 9\n      var ligneProfilComplet = lignes[8] || '';\n      var profilComplet = ligneProfilComplet.trim();\n\n      // Construire le tableau AK 3D\n      var AK_valeurs = this.construireTableauAK3D(lignes);\n\n      // Déterminer le cas\n      donneesExtraites.cas = this.detecterCas(AK_valeurs);\n      console.log(\"Cas d\\xE9tect\\xE9: \".concat(donneesExtraites.cas));\n      if (donneesExtraites.cas === 0) {\n        throw new Error(\"Impossible de détecter le cas du fichier NC2\");\n      }\n      var casInfo = this.carteValeurs.cas[donneesExtraites.cas];\n\n      // Extraire les valeurs spécifiques\n      for (var _i2 = 0, _Object$entries2 = Object.entries(casInfo); _i2 < _Object$entries2.length; _i2++) {\n        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n          _cle = _Object$entries2$_i[0],\n          _info = _Object$entries2$_i[1];\n        if (_cle !== 'description') {\n          var valeurBrute = void 0;\n          if (_cle === 'valeur_a_plat') {\n            var _ligneContenu = lignes[_info.ligne - 1] || '0';\n            valeurBrute = parseFloat(_ligneContenu);\n          } else {\n            var _info$position = _slicedToArray(_info.position, 3),\n              paraIdx = _info$position[0],\n              colIdx = _info$position[1],\n              ligneIdx = _info$position[2];\n            valeurBrute = AK_valeurs[paraIdx - 1][colIdx - 1][ligneIdx - 1];\n          }\n\n          // Si la valeur n'est pas par défaut, on la traite\n          if (valeurBrute !== this.AK_index[\"default\"]) {\n            // Conserver la valeur originale et la valeur transformée pour les angles\n            if (_cle === 'angle_54' || _cle === 'angle_55') {\n              var transformedAngle = _info.formule(valeurBrute); // Valeur transformée\n\n              donneesExtraites.valeurs_specifiques[_cle] = transformedAngle;\n              console.log(\"\".concat(_cle, \": \").concat(transformedAngle));\n            } else {\n              donneesExtraites.valeurs_specifiques[_cle] = _info.formule(valeurBrute);\n              console.log(\"\".concat(_cle, \": \").concat(donneesExtraites.valeurs_specifiques[_cle]));\n            }\n          }\n        }\n      }\n\n      // Déterminer l'orientation à partir du cas\n      var orientation;\n      if (donneesExtraites.cas === 1 || donneesExtraites.cas === 2) {\n        orientation = \"a-plat\";\n      } else {\n        orientation = \"debout\"; // Cas 3, 4 et 5 sont tous \"debout\"\n      }\n\n      // Formatter les données pour le DataManager - structure unifiée des barres\n      return {\n        profile: donneesExtraites.general.profil,\n        // Nom court pour F4C (ex: \"HEA\")\n        profileFull: profilComplet,\n        // Nom complet pour l'UI (ex: \"HEA100\")\n        length: donneesExtraites.valeurs_specifiques.longueur || 0,\n        quantity: donneesExtraites.general.quantite,\n        flatValue: donneesExtraites.valeurs_specifiques.valeur_a_plat || 0,\n        angles: {\n          start: donneesExtraites.valeurs_specifiques.angle_54 || 90,\n          end: donneesExtraites.valeurs_specifiques.angle_55 || 90\n        },\n        orientation: orientation,\n        // Orientation déterminée à partir du cas\n        type: 'fille',\n        cas: donneesExtraites.cas,\n        // Numéro du cas pour la génération F4C\n        originalData: donneesExtraites // Conservation des données brutes complètes\n      };\n    } catch (error) {\n      console.error('Erreur de parsing NC2:', error);\n      throw new Error(\"Erreur de parsing NC2: \".concat(error.message));\n    }\n  },\n  /**\n   * Construire un tableau 3D pour les valeurs AK\n   * @param {Array<string>} lignes - Lignes du fichier NC2\n   * @returns {Array} - Tableau 3D des valeurs AK\n   */\n  construireTableauAK3D: function construireTableauAK3D(lignes) {\n    // Initialiser le tableau AK_valeurs\n    var AK_valeurs = new Array(this.AK_index.paragraphes);\n    for (var i = 0; i < this.AK_index.paragraphes; i++) {\n      AK_valeurs[i] = new Array(this.AK_index.colonnes);\n      for (var j = 0; j < this.AK_index.colonnes; j++) {\n        AK_valeurs[i][j] = new Array(this.AK_index.lignes);\n        for (var k = 0; k < this.AK_index.lignes; k++) {\n          AK_valeurs[i][j][k] = this.AK_index[\"default\"];\n        }\n      }\n    }\n\n    // Remplir le tableau AK_valeurs avec les données du fichier NC\n    var paragraphe_courant = -1;\n    var ligne_dans_paragraphe = -1;\n    var dans_paragraphe_AK = false;\n    for (var _i3 = 0; _i3 < lignes.length; _i3++) {\n      var ligne = lignes[_i3];\n\n      // Détecter le début d'un paragraphe AK\n      if (ligne.startsWith('AK')) {\n        dans_paragraphe_AK = true;\n        paragraphe_courant++;\n\n        // Vérifier qu'on ne dépasse pas le nombre de paragraphes définis\n        if (paragraphe_courant >= this.AK_index.paragraphes) break;\n        ligne_dans_paragraphe = 0;\n        continue;\n      }\n\n      // Détecter la fin d'un paragraphe AK\n      if (ligne.startsWith('EN')) {\n        dans_paragraphe_AK = false;\n        continue;\n      }\n\n      // Traiter les lignes à l'intérieur d'un paragraphe AK\n      if (dans_paragraphe_AK && ligne.trim() !== '') {\n        // Limiter au nombre de lignes défini\n        if (ligne_dans_paragraphe >= this.AK_index.lignes) continue;\n\n        // Séparer les valeurs et supprimer l'identifiant (v, o, u)\n        var valeurs = ligne.trim().split(/\\s+/);\n        if (valeurs.length > 0 && /^[a-zA-Z]/.test(valeurs[0])) {\n          valeurs.shift();\n        }\n\n        // Stocker chaque valeur\n        for (var col = 0; col < valeurs.length && col < this.AK_index.colonnes; col++) {\n          var valeur = valeurs[col];\n\n          // Supprimer une lettre à la fin si présente\n          valeur = valeur.replace(/[a-zA-Z]$/, '');\n\n          // Convertir en nombre et stocker\n          AK_valeurs[paragraphe_courant][col][ligne_dans_paragraphe] = parseFloat(valeur) || 0;\n        }\n        ligne_dans_paragraphe++;\n      }\n    }\n    return AK_valeurs;\n  },\n  /**\n   * Détecte le cas de figure du fichier NC2\n   * @param {Array} AK_valeurs - Tableau 3D des valeurs AK\n   * @returns {number} - Numéro du cas (1-5)\n   */\n  detecterCas: function detecterCas(AK_valeurs) {\n    var cas_possibles = [];\n\n    // Vérifier si le cas est 1 ou 2 (valeurs dans la colonne 4 du 1er paragraphe AK)\n    for (var i = 0; i < this.AK_index.lignes; i++) {\n      if (AK_valeurs[0][3][i] !== this.AK_index[\"default\"]) {\n        console.log(\"Cas 1 ou 2\");\n        cas_possibles = [1, 2];\n        break;\n      }\n    }\n\n    // Vérifier si le cas est 3 ou 4 (valeurs dans la colonne 4 du 3ème paragraphe AK)\n    if (cas_possibles.length === 0) {\n      for (var _i4 = 0; _i4 < this.AK_index.lignes; _i4++) {\n        if (AK_valeurs[2][3][_i4] !== this.AK_index[\"default\"]) {\n          console.log(\"Cas 3 ou 4\");\n          cas_possibles = [3, 4];\n          break;\n        }\n      }\n    }\n\n    // Si aucune valeur n'est trouvée, c'est le cas 5\n    if (cas_possibles.length === 0) {\n      console.log(\"Cas 5\");\n      return 5;\n    }\n\n    // Déterminer si angles de même sens ou sens opposé\n    var paraIdx = cas_possibles[0] - 1;\n    if (AK_valeurs[paraIdx][3][1] * AK_valeurs[paraIdx][3][3] > 0) {\n      // Même sens\n      return cas_possibles[0];\n    } else {\n      // Sens opposé\n      return cas_possibles[1];\n    }\n  }\n};\n\n// Exporter le module\n\n\n//# sourceURL=webpack://parser-optimizer/./src/js/parser.js?");

/***/ }),

/***/ "./src/js/pgm-generator.js":
/*!*********************************!*\
  !*** ./src/js/pgm-generator.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PgmGenerator: () => (/* binding */ PgmGenerator)\n/* harmony export */ });\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jszip */ \"./node_modules/jszip/dist/jszip.min.js\");\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jszip__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorValues(e) { if (null != e) { var t = e[\"function\" == typeof Symbol && Symbol.iterator || \"@@iterator\"], r = 0; if (t) return t.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + \" is not iterable\"); }\nfunction _regeneratorKeys(e) { var n = Object(e), r = []; for (var t in n) r.unshift(t); return function e() { for (; r.length;) if ((t = r.pop()) in n) return e.value = t, e.done = !1, e; return e.done = !0, e; }; }\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2); } }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n/**\n * Générateur de fichiers PGM\n */\n\nvar PgmGenerator = {\n  /**\n   * Génère un fichier PGM à partir d'un schéma de coupe\n   * @param {Object} layout - Schéma de coupe\n   * @param {string} modelName - Nom du modèle/profil\n   * @param {Object} pieceDataMap - Map des données complètes des pièces\n   * @returns {string} - Contenu du fichier PGM\n   */\n  generatePgm: function generatePgm(layout, modelName) {\n    var _layout$cuts;\n    var pieceDataMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // Valeur à plat par défaut - utiliser la première pièce si disponible\n    var firstPieceId = (_layout$cuts = layout.cuts) === null || _layout$cuts === void 0 || (_layout$cuts = _layout$cuts[0]) === null || _layout$cuts === void 0 ? void 0 : _layout$cuts.pieceId;\n    var firstPiece = pieceDataMap[firstPieceId];\n    var flatValue = (firstPiece === null || firstPiece === void 0 ? void 0 : firstPiece.flatValue) || 0;\n\n    // Utiliser le modèle court pour le B021 (nom du profil dans F4C)\n    var profileShortName = (firstPiece === null || firstPiece === void 0 ? void 0 : firstPiece.model) || modelName;\n\n    // Header F4C commun à toutes les barres\n    var bodyAttrs = {\n      B001: \"        \",\n      B002: \"700\",\n      B003: \"3\",\n      B004: \"0\",\n      B005: \"0\",\n      B006: \"0\",\n      B007: \"0\",\n      B008: \"0\",\n      B009: \"0\",\n      B010: \"0\",\n      B011: \"0\",\n      B012: \"0\",\n      B013: \"0\",\n      B021: profileShortName.padEnd(8, ' '),\n      // Nom court du profil pour F4C\n      B022: \"0\",\n      B023: \"0\",\n      B024: \"0\",\n      B025: \"0\",\n      B041: \"0\",\n      B026: \"0\",\n      B027: \"0\",\n      B030: \"        \",\n      B031: \"                \",\n      B032: \"                \",\n      B033: \"        \",\n      B034: \"0\",\n      B035: flatValue.toString(),\n      // Valeur à plat du profil\n      B037: \"                \",\n      B036: \"0\",\n      B090: \"                \",\n      B100: \"1\"\n    };\n\n    // Début du fichier PGM\n    var pgmContent = \"<!--CEB-->\\n<BODY \".concat(Object.entries(bodyAttrs).map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n      return \"\".concat(key, \"=\\\"\").concat(value, \"\\\"\");\n    }).join(' '), \" ></BODY>\\n\");\n\n    // Récupérer la liste des pièces coupées\n    var cuts = layout.cuts || [];\n\n    // Ajouter une balise STEP pour chaque pièce à couper\n    var _iterator = _createForOfIteratorHelper(cuts),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _pieceData$angles, _pieceData$angles2;\n        var piece = _step.value;\n        // Récupérer les données complètes de la pièce si disponibles\n        var pieceData = pieceDataMap[piece.pieceId] || {};\n\n        // Utiliser les angles originaux ou des valeurs par défaut\n        var startAngle = ((_pieceData$angles = pieceData.angles) === null || _pieceData$angles === void 0 ? void 0 : _pieceData$angles.start) || 90;\n        var endAngle = ((_pieceData$angles2 = pieceData.angles) === null || _pieceData$angles2 === void 0 ? void 0 : _pieceData$angles2.end) || 90;\n        var stepAttrs = {\n          S051: Math.round(piece.length * 10000).toString(),\n          // Longueur multipliée par 10000\n          S052: piece.count.toString(),\n          // Quantité de cette pièce\n          S053: \"1\",\n          // Une pièce à la fois\n          S054: Math.round(startAngle * 100).toString(),\n          // Angle de début converti\n          S055: Math.round(endAngle * 100).toString(),\n          // Angle de fin converti\n          S056: \"1\",\n          S057: \"1\",\n          S058: \"1\",\n          S060: \"0\",\n          S061: \"0\",\n          S070: \"0\",\n          S071: \"0\",\n          S072: \"0\",\n          S073: \"0\",\n          S074: \"0\",\n          S075: \"0\",\n          S094: \"0\"\n        };\n        pgmContent += \"<STEP \".concat(Object.entries(stepAttrs).map(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n            key = _ref4[0],\n            value = _ref4[1];\n          return \"\".concat(key, \"=\\\"\").concat(value, \"\\\"\");\n        }).join(' '), \" ></STEP>\\n\");\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return pgmContent;\n  },\n  /**\n   * Génère un fichier ZIP contenant tous les fichiers PGM\n   * @param {Object} cutResults - Résultats de l'optimisation\n   * @param {Object} dataManager - Instance du DataManager pour accéder aux données complètes\n   * @returns {Promise<Blob>} - Blob du fichier ZIP\n   */\n  generateAllPgmFiles: function () {\n    var _generateAllPgmFiles = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(cutResults, dataManager) {\n      var _this = this;\n      var zip, pieceDataMap, _loop, model, blob, _t, _t2;\n      return _regenerator().w(function (_context2) {\n        while (1) switch (_context2.n) {\n          case 0:\n            zip = new (jszip__WEBPACK_IMPORTED_MODULE_0___default())(); // Créer un map des pièces par ID pour un accès rapide\n            pieceDataMap = {};\n            dataManager.data.barsList.forEach(function (bar) {\n              if (bar.type === 'fille' && bar.id) {\n                pieceDataMap[bar.id] = bar;\n              }\n            });\n\n            // Pour chaque modèle\n            _loop = /*#__PURE__*/_regenerator().m(function _loop(model) {\n              var firstPieceWithModel, profileFull;\n              return _regenerator().w(function (_context) {\n                while (1) switch (_context.n) {\n                  case 0:\n                    // Trouver le profileFull correspondant au modèle\n                    firstPieceWithModel = dataManager.data.barsList.find(function (bar) {\n                      return bar.model === model;\n                    });\n                    profileFull = (firstPieceWithModel === null || firstPieceWithModel === void 0 ? void 0 : firstPieceWithModel.profileFull) || model; // Pour chaque schéma de coupe\n                    cutResults.modelResults[model].layouts.forEach(function (layout, index) {\n                      // Générer le contenu PGM avec les données complètes des pièces\n                      var pgmContent = _this.generatePgm(layout, model, pieceDataMap);\n\n                      // Utiliser le nom complet du profil pour le nom du fichier\n                      var filename = \"\".concat(profileFull, \"_\").concat(Math.round(layout.barLength || layout.originalLength), \"_\").concat(index + 1, \".pgm\");\n                      zip.file(filename, pgmContent);\n                    });\n                  case 1:\n                    return _context.a(2);\n                }\n              }, _loop);\n            });\n            _t = _regeneratorKeys(cutResults.modelResults);\n          case 1:\n            if ((_t2 = _t()).done) {\n              _context2.n = 3;\n              break;\n            }\n            model = _t2.value;\n            return _context2.d(_regeneratorValues(_loop(model)), 2);\n          case 2:\n            _context2.n = 1;\n            break;\n          case 3:\n            _context2.n = 4;\n            return zip.generateAsync({\n              type: \"blob\"\n            });\n          case 4:\n            blob = _context2.v;\n            return _context2.a(2, blob);\n        }\n      }, _callee);\n    }));\n    function generateAllPgmFiles(_x, _x2) {\n      return _generateAllPgmFiles.apply(this, arguments);\n    }\n    return generateAllPgmFiles;\n  }()\n};\n\n// Exporter le module\n\n\n//# sourceURL=webpack://parser-optimizer/./src/js/pgm-generator.js?");

/***/ }),

/***/ "./src/js/results-renderer.js":
/*!************************************!*\
  !*** ./src/js/results-renderer.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResultsRenderer: () => (/* binding */ ResultsRenderer)\n/* harmony export */ });\n/**\n * ResultsRenderer - Handles rendering of algorithm results in the UI\n * This separates UI rendering from algorithm logic\n */\nvar ResultsRenderer = {\n  /**\n   * Render algorithm results to the container\n   * @param {Object} results - Algorithm results to render\n   * @param {Object} algorithmService - Algorithm service for stats calculation\n   * @param {HTMLElement} [container] - Optional container element (defaults to results-container)\n   */\n  renderResults: function renderResults(results, algorithmService, container) {\n    if (!container) {\n      container = document.getElementById('results-container');\n    }\n    if (!results) {\n      this.renderErrorMessage(container, \"Impossible de calculer les résultats\", \"L'algorithme n'a pas pu trouver de solution avec les données fournies.\");\n      return;\n    }\n\n    // Calculate global statistics\n    var globalStats = algorithmService.calculateGlobalStats(results);\n\n    // Build HTML for results\n    var html = this.renderGlobalSummary(results, globalStats);\n    html += this.renderModelDetails(results, algorithmService);\n\n    // Update container\n    container.innerHTML = html;\n  },\n  /**\n   * Render error message\n   * @param {HTMLElement} container - Container element\n   * @param {string} title - Error title\n   * @param {string} message - Error message\n   */\n  renderErrorMessage: function renderErrorMessage(container, title, message) {\n    container.innerHTML = \"\\n      <div class=\\\"error-message\\\">\\n        <h3>\".concat(title, \"</h3>\\n        <p>\").concat(message, \"</p>\\n      </div>\\n    \");\n  },\n  /**\n   * Render global statistics summary\n   * @param {Object} results - Algorithm results\n   * @param {Object} stats - Calculated global statistics\n   * @returns {string} HTML for global summary\n   */\n  renderGlobalSummary: function renderGlobalSummary(results, stats) {\n    var html = \"\\n      <div class=\\\"results-summary\\\">\\n        <h3>R\\xE9sum\\xE9 global</h3>\\n    \";\n\n    // Add comparison information if available\n    if (results.comparison) {\n      html += this.renderComparisonSection(results.comparison, results.bestAlgorithm);\n    }\n    html += \"\\n        <div class=\\\"stats-grid\\\">\\n          <div class=\\\"stat-card\\\">\\n            <div class=\\\"stat-label\\\">Barres utilis\\xE9es</div>\\n            <div class=\\\"stat-value\\\">\".concat(stats.totalUsedBars, \"</div>\\n          </div>\\n          <div class=\\\"stat-card\\\">\\n            <div class=\\\"stat-label\\\">Longueur totale barres m\\xE8res</div>\\n            <div class=\\\"stat-value\\\">\").concat(stats.totalBarLength, \" unit\\xE9s</div>\\n          </div>\\n          <div class=\\\"stat-card\\\">\\n            <div class=\\\"stat-label\\\">Chutes (total)</div>\\n            <div class=\\\"stat-value\\\">\").concat(stats.totalWaste, \" unit\\xE9s</div>\\n          </div>\\n          <div class=\\\"stat-card efficiency-card\\\">\\n            <div class=\\\"stat-label\\\">Efficacit\\xE9</div>\\n            <div class=\\\"stat-value\\\">\").concat(stats.totalEfficiency, \"%</div>\\n          </div>\\n        </div>\\n      </div>\\n    \");\n    return html;\n  },\n  /**\n   * Render algorithm comparison section\n   * @param {Object} comparison - Comparison data\n   * @param {string} bestAlgorithm - Best algorithm identifier\n   * @returns {string} HTML for comparison section\n   */\n  renderComparisonSection: function renderComparisonSection(comparison, bestAlgorithm) {\n    return \"\\n      <div class=\\\"algorithm-comparison\\\">\\n        <p class=\\\"comparison-result\\\">\\n          <strong>Algorithme choisi:</strong> \".concat(bestAlgorithm === 'ffd' ? 'First-Fit Decreasing' : 'Programmation Linéaire', \"\\n          <span class=\\\"tag\\\">\").concat(bestAlgorithm === 'ffd' ? 'FFD' : 'ILP', \"</span>\\n        </p>\\n        <div class=\\\"algorithm-efficiencies\\\">\\n          <div class=\\\"efficiency-comparison \").concat(bestAlgorithm === 'ffd' ? 'best' : '', \"\\\">\\n            <div class=\\\"algorithm-name\\\">First-Fit Decreasing</div>\\n            <div class=\\\"efficiency-value\\\">\").concat(comparison.ffdEfficiency, \"%</div>\\n          </div>\\n          <div class=\\\"efficiency-comparison \").concat(bestAlgorithm === 'ilp' ? 'best' : '', \"\\\">\\n            <div class=\\\"algorithm-name\\\">Programmation Lin\\xE9aire</div>\\n            <div class=\\\"efficiency-value\\\">\").concat(comparison.ilpEfficiency, \"%</div>\\n          </div>\\n        </div>\\n        <p class=\\\"difference-info\\\">\\n          Diff\\xE9rence d'efficacit\\xE9: <strong>\").concat(comparison.differencePercentage, \"%</strong>\\n        </p>\\n      </div>\\n    \");\n  },\n  /**\n   * Render model details sections\n   * @param {Object} results - Algorithm results\n   * @param {Object} algorithmService - Algorithm service for stats calculation\n   * @returns {string} HTML for model details\n   */\n  renderModelDetails: function renderModelDetails(results, algorithmService) {\n    var modelResults = results.modelResults || {};\n    var html = \"\\n      <h3 class=\\\"mb-3\\\">D\\xE9tails par mod\\xE8le</h3>\\n      <div class=\\\"model-results\\\">\\n    \";\n\n    // Add each model's results\n    for (var model in modelResults) {\n      var modelResult = modelResults[model];\n      var modelStats = algorithmService.calculateModelStats(modelResult);\n      html += this.renderModelCard(model, modelResult, modelStats, algorithmService);\n    }\n    html += \"</div>\";\n    return html;\n  },\n  /**\n   * Render a single model card\n   * @param {string} modelName - Name of the model\n   * @param {Object} modelResult - Model result data\n   * @param {Object} stats - Calculated model statistics\n   * @param {Object} algorithmService - Algorithm service for pattern processing\n   * @returns {string} HTML for model card\n   */\n  renderModelCard: function renderModelCard(modelName, modelResult, stats, algorithmService) {\n    var _this = this;\n    var html = \"\\n      <div class=\\\"model-card\\\">\\n        <div class=\\\"model-header\\\">\\n          <h3>Mod\\xE8le: \".concat(modelName, \"</h3>\\n        </div>\\n        <div class=\\\"model-content\\\">\\n          <div class=\\\"model-stats\\\">\\n            <div class=\\\"model-stat\\\">\\n              <div class=\\\"stat-label\\\">Barres</div>\\n              <div class=\\\"stat-value\\\">\").concat(stats.barCount, \"</div>\\n            </div>\\n            <div class=\\\"model-stat\\\">\\n              <div class=\\\"stat-label\\\">Longueur totale</div>\\n              <div class=\\\"stat-value\\\">\").concat(stats.totalLength, \" unit\\xE9s</div>\\n            </div>\\n            <div class=\\\"model-stat\\\">\\n              <div class=\\\"stat-label\\\">Chutes</div>\\n              <div class=\\\"stat-value\\\">\").concat(stats.wasteLength, \" unit\\xE9s</div>\\n            </div>\\n            <div class=\\\"model-stat\\\">\\n              <div class=\\\"stat-label\\\">Efficacit\\xE9</div>\\n              <div class=\\\"efficiency-tag\\\">\").concat(stats.efficiency, \"%</div>\\n            </div>\\n          </div>\\n          \\n          <div class=\\\"cut-schemes\\\">\\n            <h4 class=\\\"mb-2\\\">Sch\\xE9mas de coupe</h4>\\n    \");\n\n    // Add each cutting pattern\n    modelResult.layouts.forEach(function (layout, index) {\n      var processedPattern = algorithmService.processPattern(layout);\n      html += _this.renderCutScheme(processedPattern, index);\n    });\n    html += \"\\n          </div>\\n        </div>\\n      </div>\\n    \";\n    return html;\n  },\n  /**\n   * Render a single cut scheme\n   * @param {Object} pattern - Processed pattern data\n   * @param {number} index - Pattern index\n   * @returns {string} HTML for cut scheme\n   */\n  renderCutScheme: function renderCutScheme(pattern, index) {\n    // Generate the text representation of cuts\n    var cutsHtml = '';\n    pattern.cuts.forEach(function (cut) {\n      cutsHtml += \"<span class=\\\"cut-count\\\">\".concat(cut.count, \"\\xD7</span>\").concat(cut.length, \" \");\n    });\n\n    // Generate visual representation of the cuts\n    var visualBarHtml = '';\n    pattern.visualPieces.forEach(function (piece) {\n      var lastPieceClass = piece.isLast ? 'last-piece' : '';\n      visualBarHtml += \"\\n        <div class=\\\"cut-piece \".concat(lastPieceClass, \"\\\" \\n             style=\\\"width: \").concat(piece.percentage, \"%\\\" \\n             title=\\\"\").concat(piece.length, \"\\\">\\n          \").concat(piece.length, \"\\n        </div>\\n      \");\n    });\n\n    // Add waste piece if any\n    if (pattern.waste > 0) {\n      visualBarHtml += \"\\n        <div class=\\\"waste-piece\\\" \\n             style=\\\"width: \".concat(pattern.wastePercentage, \"%\\\" \\n             title=\\\"Chute: \").concat(pattern.waste, \"\\\">\\n          \").concat(pattern.waste, \"\\n        </div>\\n      \");\n    }\n    return \"\\n      <div class=\\\"cut-scheme\\\">\\n        <div class=\\\"cut-scheme-header\\\">\\n          <strong>\".concat(pattern.count, \"\\xD7 Sch\\xE9ma #\").concat(index + 1, \"</strong>\\n          <span>Barre de \").concat(pattern.barLength, \"</span>\\n        </div>\\n        <div class=\\\"cut-pieces\\\">\\n          Pi\\xE8ces: \").concat(cutsHtml, \"\\n        </div>\\n        <div class=\\\"waste\\\">\\n          Chute: <span class=\\\"waste-value\\\">\").concat(pattern.waste, \"</span>\\n        </div>\\n        <div class=\\\"cut-bar\\\">\\n          \").concat(visualBarHtml, \"\\n        </div>\\n      </div>\\n    \");\n  }\n};\n\n//# sourceURL=webpack://parser-optimizer/./src/js/results-renderer.js?");

/***/ }),

/***/ "./src/js/ui-controller.js":
/*!*********************************!*\
  !*** ./src/js/ui-controller.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UIController: () => (/* binding */ UIController)\n/* harmony export */ });\n/* harmony import */ var _ui_import_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui/import-handler.js */ \"./src/js/ui/import-handler.js\");\n/* harmony import */ var _ui_edit_handler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui/edit-handler.js */ \"./src/js/ui/edit-handler.js\");\n/* harmony import */ var _ui_results_handler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui/results-handler.js */ \"./src/js/ui/results-handler.js\");\n/* harmony import */ var _ui_notification_service_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ui/notification-service.js */ \"./src/js/ui/notification-service.js\");\n/* harmony import */ var _ui_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ui/utils.js */ \"./src/js/ui/utils.js\");\n/**\n * Contrôleur d'interface utilisateur principal\n * Coordonne les différentes sections et services\n */\n\n\n\n\n\nvar UIController = {\n  // Références aux services\n  dataManager: null,\n  algorithmService: null,\n  resultsRenderer: null,\n  importManager: null,\n  pgmGenerator: null,\n  // Handlers de sections\n  importHandler: null,\n  editHandler: null,\n  resultsHandler: null,\n  // Services UI\n  notificationService: null,\n  /**\n   * Initialise le contrôleur UI avec les dépendances\n   * @param {Object} options - Options d'initialisation\n   */\n  init: function init(options) {\n    // Stocke les références aux services\n    this.dataManager = options.dataManager;\n    this.algorithmService = options.algorithmService;\n    this.resultsRenderer = options.resultsRenderer;\n    this.importManager = options.importManager;\n    this.pgmGenerator = options.pgmGenerator;\n\n    // Initialiser les services UI\n    this.notificationService = _ui_notification_service_js__WEBPACK_IMPORTED_MODULE_3__.NotificationService;\n    this.notificationService.init();\n\n    // Initialiser les handlers de sections\n    this.importHandler = _ui_import_handler_js__WEBPACK_IMPORTED_MODULE_0__.ImportHandler;\n    this.editHandler = _ui_edit_handler_js__WEBPACK_IMPORTED_MODULE_1__.EditHandler;\n    this.editHandler.init({\n      dataManager: this.dataManager,\n      showNotification: this.notificationService.show.bind(this.notificationService)\n    });\n    this.importHandler.init({\n      dataManager: this.dataManager,\n      importManager: this.importManager,\n      showNotification: this.notificationService.show.bind(this.notificationService),\n      navigateToSection: this.navigateToSection.bind(this),\n      editHandler: this.editHandler // Ajouter une référence directe à editHandler\n    });\n    this.resultsHandler = _ui_results_handler_js__WEBPACK_IMPORTED_MODULE_2__.ResultsHandler;\n    this.resultsHandler.init({\n      pgmGenerator: this.pgmGenerator,\n      dataManager: this.dataManager,\n      showNotification: this.notificationService.show.bind(this.notificationService)\n    });\n\n    // Initialiser les gestionnaires d'événements\n    this.initEventHandlers();\n\n    // Rendre la section d'édition immédiatement\n    this.editHandler.renderSection();\n  },\n  /**\n   * Initialise tous les gestionnaires d'événements de navigation\n   */\n  initEventHandlers: function initEventHandlers() {\n    var _this = this;\n    // Navigation entre sections\n    document.querySelectorAll('.nav-btn').forEach(function (button) {\n      button.addEventListener('click', function () {\n        var sectionId = button.getAttribute('data-section');\n        _this.navigateToSection(sectionId);\n      });\n    });\n\n    // Bouton de génération des fichiers de découpe\n    document.getElementById('generate-cuts-btn').addEventListener('click', function () {\n      return _this.generateOptimalCuts();\n    });\n\n    // Bouton de retour aux données\n    document.getElementById('back-to-data-btn').addEventListener('click', function () {\n      return _this.navigateToSection('data-section');\n    });\n\n    // Bouton de téléchargement de tous les PGM\n    document.getElementById('download-all-pgm').addEventListener('click', function () {\n      return _this.resultsHandler.downloadAllPgm();\n    });\n  },\n  /**\n   * Affiche la section spécifiée\n   * @param {string} sectionId - ID de la section à afficher\n   */\n  navigateToSection: function navigateToSection(sectionId) {\n    // Masquer les erreurs d'import\n    if (this.importHandler) this.importHandler.hideError();\n\n    // Mettre à jour les boutons de navigation\n    document.querySelectorAll('.nav-btn').forEach(function (button) {\n      if (button.getAttribute('data-section') === sectionId) {\n        button.classList.add('active');\n      } else {\n        button.classList.remove('active');\n      }\n    });\n\n    // Afficher la section correspondante\n    document.querySelectorAll('.content-section').forEach(function (section) {\n      if (section.id === sectionId) {\n        section.classList.add('active');\n      } else {\n        section.classList.remove('active');\n      }\n    });\n  },\n  /**\n   * Génère les découpes optimales et affiche les résultats\n   */\n  generateOptimalCuts: function generateOptimalCuts() {\n    var _this2 = this;\n    // Valider les données avant optimisation\n    var validation = this.dataManager.validateData();\n    if (!validation.valid) {\n      this.notificationService.show(validation.message, 'warning');\n      return;\n    }\n    var data = this.dataManager.getData();\n    _ui_utils_js__WEBPACK_IMPORTED_MODULE_4__.UIUtils.showLoadingOverlay();\n    setTimeout(function () {\n      try {\n        // Comparaison automatique des algorithmes pour choisir le meilleur\n        var result = _this2.algorithmService.compareAlgorithms(data);\n        console.log('Optimization result:', result);\n\n        // Naviguer vers la section des résultats\n        _this2.navigateToSection('result-section');\n\n        // Afficher les résultats\n        _this2.resultsRenderer.renderResults(result, _this2.algorithmService);\n\n        // Générer les aperçus PGM\n        _this2.resultsHandler.generatePgmPreviews(result);\n      } catch (error) {\n        console.error('Optimization error:', error);\n        _this2.notificationService.show(\"Erreur d'optimisation: \".concat(error.message), 'error');\n      } finally {\n        _ui_utils_js__WEBPACK_IMPORTED_MODULE_4__.UIUtils.hideLoadingOverlay();\n      }\n    }, 100);\n  }\n};\n\n//# sourceURL=webpack://parser-optimizer/./src/js/ui-controller.js?");

/***/ }),

/***/ "./src/js/ui/edit-handler.js":
/*!***********************************!*\
  !*** ./src/js/ui/edit-handler.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditHandler: () => (/* binding */ EditHandler)\n/* harmony export */ });\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n/**\n * Gestionnaire de la section d'édition\n */\nvar EditHandler = {\n  // Dépendances\n  dataManager: null,\n  showNotification: null,\n  // État interne\n  editingId: null,\n  editingType: null,\n  editingMode: null,\n  // 'edit' ou 'create'\n\n  /**\n   * Initialise le handler d'édition\n   */\n  init: function init(options) {\n    this.dataManager = options.dataManager;\n    this.showNotification = options.showNotification;\n\n    // Créer les panneaux latéraux s'ils n'existent pas\n    this.createPiecePanel();\n    this.createStockPanel();\n  },\n  /**\n   * Rend la section d'édition\n   */\n  renderSection: function renderSection() {\n    this.renderPiecesTable();\n    this.renderStockBarsTable();\n  },\n  /**\n   * Convertit le code d'orientation en affichage lisible\n   */\n  formatOrientation: function formatOrientation(orientation) {\n    switch (orientation) {\n      case 'debout':\n        return 'Debout';\n      case 'a-plat':\n        return 'À plat';\n      default:\n        return orientation;\n    }\n  },\n  /**\n   * Rend le tableau des barres filles\n   */\n  renderPiecesTable: function renderPiecesTable() {\n    var _this = this;\n    var tableContainer = document.querySelector('#pieces-table');\n    var data = this.dataManager.getData();\n\n    // Récupérer toutes les barres filles\n    var allPieces = [];\n    for (var model in data.pieces) {\n      allPieces.push.apply(allPieces, _toConsumableArray(data.pieces[model]));\n    }\n\n    // Trier les barres\n    allPieces.sort(function (a, b) {\n      return a.model.localeCompare(b.model) || a.length - b.length;\n    });\n\n    // Générer l'en-tête du tableau\n    var html = \"\\n      <table class=\\\"data-table\\\">\\n        <thead>\\n          <tr>\\n            <th>Profil</th>\\n            <th>Orientation</th>\\n            <th>Longueur</th>\\n            <th>Angle d\\xE9but</th>\\n            <th>Angle fin</th>\\n            <th>Quantit\\xE9</th>\\n            <th>Actions</th>\\n          </tr>\\n        </thead>\\n        <tbody>\\n    \";\n\n    // Générer les lignes du tableau\n    for (var _i = 0, _allPieces = allPieces; _i < _allPieces.length; _i++) {\n      var _piece$angles, _piece$angles2;\n      var piece = _allPieces[_i];\n      html += \"\\n        <tr data-id=\\\"\".concat(piece.id, \"\\\">\\n          <td>\").concat(piece.profileFull || piece.model, \"</td>\\n          <td>\").concat(this.formatOrientation(piece.orientation || \"non-définie\"), \"</td>\\n          <td>\").concat(Math.round(piece.length), \"</td>\\n          <td>\").concat(parseFloat(((_piece$angles = piece.angles) === null || _piece$angles === void 0 ? void 0 : _piece$angles.start) || 90).toFixed(2), \"\\xB0</td>\\n          <td>\").concat(parseFloat(((_piece$angles2 = piece.angles) === null || _piece$angles2 === void 0 ? void 0 : _piece$angles2.end) || 90).toFixed(2), \"\\xB0</td>\\n          <td>\").concat(piece.quantity, \"</td>\\n          <td>\\n            <button class=\\\"btn btn-sm btn-primary edit-piece-btn\\\" \\n                    data-id=\\\"\").concat(piece.id, \"\\\">\\u270E</button>\\n            <button class=\\\"btn btn-sm btn-danger delete-piece-btn\\\" \\n                    data-id=\\\"\").concat(piece.id, \"\\\">\\xD7</button>\\n          </td>\\n        </tr>\\n      \");\n    }\n\n    // Ajouter une ligne pour le bouton d'ajout\n    html += \"\\n        <tr class=\\\"add-row\\\">\\n          <td colspan=\\\"7\\\">\\n            <button id=\\\"add-piece-btn\\\" class=\\\"btn btn-sm btn-primary\\\">+ Ajouter une barre \\xE0 d\\xE9couper</button>\\n          </td>\\n        </tr>\\n      </tbody>\\n    </table>\\n    \";\n    tableContainer.innerHTML = html;\n\n    // Ajouter les gestionnaires d'événements\n    tableContainer.querySelectorAll('.delete-piece-btn').forEach(function (button) {\n      button.addEventListener('click', function () {\n        var id = button.getAttribute('data-id');\n        if (_this.dataManager.deletePiece(id)) {\n          _this.renderPiecesTable();\n        }\n      });\n    });\n\n    // Ajouter les gestionnaires pour l'édition\n    tableContainer.querySelectorAll('.edit-piece-btn').forEach(function (button) {\n      button.addEventListener('click', function () {\n        var id = button.getAttribute('data-id');\n        _this.openPiecePanel('edit', id);\n      });\n    });\n\n    // Ajouter le gestionnaire pour le bouton d'ajout de pièce\n    document.getElementById('add-piece-btn').addEventListener('click', function () {\n      _this.openPiecePanel('create');\n    });\n  },\n  /**\n   * Rend le tableau des barres mères\n   */\n  renderStockBarsTable: function renderStockBarsTable() {\n    var _this2 = this;\n    var tableContainer = document.querySelector('#stock-bars-table');\n    var data = this.dataManager.getData();\n\n    // Récupérer toutes les barres mères\n    var allMotherBars = [];\n    for (var model in data.motherBars) {\n      allMotherBars.push.apply(allMotherBars, _toConsumableArray(data.motherBars[model]));\n    }\n\n    // Trier les barres\n    allMotherBars.sort(function (a, b) {\n      return a.model.localeCompare(b.model) || a.length - b.length;\n    });\n\n    // Générer l'en-tête du tableau\n    var html = \"\\n      <table class=\\\"data-table\\\">\\n        <thead>\\n          <tr>\\n            <th>Profil</th>\\n            <th>Longueur</th>\\n            <th>Quantit\\xE9</th>\\n            <th>Actions</th>\\n          </tr>\\n        </thead>\\n        <tbody>\\n    \";\n\n    // Générer les lignes du tableau\n    for (var _i2 = 0, _allMotherBars = allMotherBars; _i2 < _allMotherBars.length; _i2++) {\n      var bar = _allMotherBars[_i2];\n      html += \"\\n        <tr data-id=\\\"\".concat(bar.id, \"\\\">\\n          <td>\").concat(bar.profileFull || bar.model, \"</td>\\n          <td>\").concat(Math.round(bar.length), \"</td>\\n          <td>\").concat(bar.quantity, \"</td>\\n          <td>\\n            <button class=\\\"btn btn-sm btn-primary edit-stock-btn\\\" \\n                    data-id=\\\"\").concat(bar.id, \"\\\">\\u270E</button>\\n            <button class=\\\"btn btn-sm btn-danger delete-stock-btn\\\" \\n                    data-id=\\\"\").concat(bar.id, \"\\\">\\xD7</button>\\n          </td>\\n        </tr>\\n      \");\n    }\n\n    // Ajouter une ligne pour le bouton d'ajout\n    html += \"\\n        <tr class=\\\"add-row\\\">\\n          <td colspan=\\\"4\\\">\\n            <button id=\\\"add-mother-bar-btn\\\" class=\\\"btn btn-sm btn-primary\\\">+ Ajouter une barre m\\xE8re</button>\\n          </td>\\n        </tr>\\n      </tbody>\\n    </table>\\n    \";\n    tableContainer.innerHTML = html;\n\n    // Ajouter les gestionnaires d'événements\n    tableContainer.querySelectorAll('.delete-stock-btn').forEach(function (button) {\n      button.addEventListener('click', function () {\n        var id = button.getAttribute('data-id');\n        if (_this2.dataManager.deleteMotherBar(id)) {\n          _this2.renderStockBarsTable();\n        }\n      });\n    });\n\n    // Ajouter les gestionnaires pour l'édition\n    tableContainer.querySelectorAll('.edit-stock-btn').forEach(function (button) {\n      button.addEventListener('click', function () {\n        var id = button.getAttribute('data-id');\n        _this2.openStockPanel('edit', id);\n      });\n    });\n\n    // Ajouter le gestionnaire pour le bouton d'ajout\n    document.getElementById('add-mother-bar-btn').addEventListener('click', function () {\n      _this2.openStockPanel('create');\n    });\n  },\n  /**\n   * Ouvre le panneau des barres filles (édition ou création)\n   * @param {string} mode - Mode du panneau ('edit' ou 'create')\n   * @param {string} id - ID de la pièce à éditer (seulement en mode 'edit')\n   */\n  openPiecePanel: function openPiecePanel(mode) {\n    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    this.editingMode = mode;\n    this.editingId = id;\n    this.editingType = 'piece';\n    var panel = document.getElementById('piece-panel');\n    var overlay = document.getElementById('panel-overlay');\n    var form = panel.querySelector('.panel-form');\n    var title = panel.querySelector('.panel-title');\n\n    // Vider le formulaire\n    form.innerHTML = '';\n    if (mode === 'edit') {\n      var _item$angles, _item$angles2;\n      var item = this.dataManager.getPieceById(id);\n      if (!item) return;\n      title.textContent = \"\\xC9diter la barre \".concat(item.profileFull || item.model);\n\n      // Générer le formulaire d'édition\n      form.innerHTML = \"\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"piece-profile\\\">Profil :</label>\\n          <div class=\\\"profile-input-group\\\">\\n            <select id=\\\"piece-profile-select\\\">\\n              <option value=\\\"custom\\\">Saisie personnalis\\xE9e</option>\\n              \".concat(this.getProfileOptions(item.profileFull), \"\\n            </select>\\n            <input type=\\\"text\\\" id=\\\"piece-profile\\\" value=\\\"\").concat(item.profileFull || item.model, \"\\\">\\n          </div>\\n        </div>\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"piece-length\\\">Longueur :</label>\\n          <input type=\\\"number\\\" id=\\\"piece-length\\\" min=\\\"1\\\" step=\\\"1\\\" value=\\\"\").concat(Math.round(item.length), \"\\\">\\n        </div>\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"piece-quantity\\\">Quantit\\xE9 :</label>\\n          <input type=\\\"number\\\" id=\\\"piece-quantity\\\" min=\\\"1\\\" value=\\\"\").concat(item.quantity, \"\\\">\\n        </div>\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"piece-angle-start\\\">Angle d\\xE9but (\\xB0) :</label>\\n          <input type=\\\"number\\\" id=\\\"piece-angle-start\\\" min=\\\"0\\\" max=\\\"360\\\" step=\\\"0.01\\\" value=\\\"\").concat(parseFloat(((_item$angles = item.angles) === null || _item$angles === void 0 ? void 0 : _item$angles.start) || 90).toFixed(2), \"\\\">\\n        </div>\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"piece-angle-end\\\">Angle fin (\\xB0) :</label>\\n          <input type=\\\"number\\\" id=\\\"piece-angle-end\\\" min=\\\"0\\\" max=\\\"360\\\" step=\\\"0.01\\\" value=\\\"\").concat(parseFloat(((_item$angles2 = item.angles) === null || _item$angles2 === void 0 ? void 0 : _item$angles2.end) || 90).toFixed(2), \"\\\">\\n        </div>\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"piece-orientation\\\">Orientation :</label>\\n          <select id=\\\"piece-orientation\\\">\\n            <option value=\\\"a-plat\\\" \").concat(item.orientation === 'a-plat' ? 'selected' : '', \">\\xC0 plat</option>\\n            <option value=\\\"debout\\\" \").concat(item.orientation === 'debout' ? 'selected' : '', \">Debout</option>\\n          </select>\\n        </div>\\n      \");\n\n      // Initialiser les contrôles spécifiques\n      var profileSelect = document.getElementById('piece-profile-select');\n      var profileInput = document.getElementById('piece-profile');\n      profileSelect.addEventListener('change', function () {\n        if (profileSelect.value === 'custom') {\n          profileInput.removeAttribute('readonly');\n          profileInput.focus();\n        } else {\n          profileInput.value = profileSelect.value;\n          profileInput.setAttribute('readonly', 'readonly');\n        }\n      });\n\n      // Si le profil actuel n'est pas dans la liste, sélectionner \"custom\"\n      var matchingOption = Array.from(profileSelect.options).find(function (option) {\n        return option.value === item.profileFull;\n      });\n      if (!matchingOption) {\n        profileSelect.value = 'custom';\n        profileInput.removeAttribute('readonly');\n      } else {\n        profileSelect.value = item.profileFull;\n        profileInput.setAttribute('readonly', 'readonly');\n      }\n    } else {\n      // Mode création\n      title.textContent = 'Nouvelle barre à découper';\n      form.innerHTML = \"\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"piece-profile\\\">Profil :</label>\\n          <div class=\\\"profile-input-group\\\">\\n            <select id=\\\"piece-profile-select\\\">\\n              <option value=\\\"custom\\\">Saisie personnalis\\xE9e</option>\\n              \".concat(this.getProfileOptions(), \"\\n            </select>\\n            <input type=\\\"text\\\" id=\\\"piece-profile\\\" placeholder=\\\"Saisir le profil\\\">\\n          </div>\\n        </div>\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"piece-length\\\">Longueur :</label>\\n          <input type=\\\"number\\\" id=\\\"piece-length\\\" min=\\\"1\\\" step=\\\"1\\\">\\n        </div>\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"piece-quantity\\\">Quantit\\xE9 :</label>\\n          <input type=\\\"number\\\" id=\\\"piece-quantity\\\" min=\\\"1\\\" value=\\\"1\\\">\\n        </div>\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"piece-angle-start\\\">Angle d\\xE9but (\\xB0) :</label>\\n          <input type=\\\"number\\\" id=\\\"piece-angle-start\\\" min=\\\"0\\\" max=\\\"360\\\" step=\\\"0.01\\\" value=\\\"90.00\\\">\\n        </div>\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"piece-angle-end\\\">Angle fin (\\xB0) :</label>\\n          <input type=\\\"number\\\" id=\\\"piece-angle-end\\\" min=\\\"0\\\" max=\\\"360\\\" step=\\\"0.01\\\" value=\\\"90.00\\\">\\n        </div>\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"piece-orientation\\\">Orientation :</label>\\n          <select id=\\\"piece-orientation\\\">\\n            <option value=\\\"a-plat\\\">\\xC0 plat</option>\\n            <option value=\\\"debout\\\">Debout</option>\\n          </select>\\n        </div>\\n      \");\n\n      // Initialiser les contrôles\n      var _profileSelect = document.getElementById('piece-profile-select');\n      var _profileInput = document.getElementById('piece-profile');\n      _profileSelect.addEventListener('change', function () {\n        if (_profileSelect.value === 'custom') {\n          _profileInput.removeAttribute('readonly');\n          _profileInput.focus();\n        } else {\n          _profileInput.value = _profileSelect.value;\n          _profileInput.setAttribute('readonly', 'readonly');\n        }\n      });\n    }\n\n    // Afficher le panneau et l'overlay\n    panel.classList.add('visible');\n    overlay.classList.add('visible');\n  },\n  /**\n   * Ouvre le panneau des barres mères (édition ou création)\n   * @param {string} mode - Mode du panneau ('edit' ou 'create')\n   * @param {string} id - ID de la barre à éditer (seulement en mode 'edit')\n   */\n  openStockPanel: function openStockPanel(mode) {\n    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    this.editingMode = mode;\n    this.editingId = id;\n    this.editingType = 'stock';\n    var panel = document.getElementById('stock-panel');\n    var overlay = document.getElementById('panel-overlay');\n    var form = panel.querySelector('.panel-form');\n    var title = panel.querySelector('.panel-title');\n\n    // Vider le formulaire\n    form.innerHTML = '';\n    if (mode === 'edit') {\n      var item = this.dataManager.getMotherBarById(id);\n      if (!item) return;\n      title.textContent = \"\\xC9diter la barre m\\xE8re \".concat(item.profileFull || item.model);\n\n      // Générer le formulaire d'édition\n      form.innerHTML = \"\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"stock-profile\\\">Profil :</label>\\n          <select id=\\\"stock-profile\\\">\\n            \".concat(this.getProfileOptions(item.profileFull), \"\\n          </select>\\n        </div>\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"stock-length\\\">Longueur :</label>\\n          <input type=\\\"number\\\" id=\\\"stock-length\\\" min=\\\"1\\\" step=\\\"1\\\" value=\\\"\").concat(Math.round(item.length), \"\\\">\\n        </div>\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"stock-quantity\\\">Quantit\\xE9 :</label>\\n          <input type=\\\"number\\\" id=\\\"stock-quantity\\\" min=\\\"1\\\" value=\\\"\").concat(item.quantity, \"\\\">\\n        </div>\\n      \");\n    } else {\n      // Mode création\n      title.textContent = 'Nouvelle barre mère';\n      form.innerHTML = \"\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"stock-profile\\\">Profil :</label>\\n          <select id=\\\"stock-profile\\\">\\n            \".concat(this.getProfileOptions(), \"\\n          </select>\\n        </div>\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"stock-length\\\">Longueur :</label>\\n          <input type=\\\"number\\\" id=\\\"stock-length\\\" min=\\\"1\\\" step=\\\"1\\\">\\n        </div>\\n        <div class=\\\"form-group\\\">\\n          <label for=\\\"stock-quantity\\\">Quantit\\xE9 :</label>\\n          <input type=\\\"number\\\" id=\\\"stock-quantity\\\" min=\\\"1\\\" value=\\\"1000000\\\">\\n        </div>\\n      \");\n    }\n\n    // Afficher le panneau et l'overlay\n    panel.classList.add('visible');\n    overlay.classList.add('visible');\n  },\n  /**\n   * Ferme le panneau d'édition actif\n   */\n  closePanel: function closePanel() {\n    var piecePanel = document.getElementById('piece-panel');\n    var stockPanel = document.getElementById('stock-panel');\n    var overlay = document.getElementById('panel-overlay');\n    piecePanel.classList.remove('visible');\n    stockPanel.classList.remove('visible');\n    overlay.classList.remove('visible');\n    this.editingId = null;\n    this.editingType = null;\n    this.editingMode = null;\n  },\n  /**\n   * Enregistre les modifications ou crée un nouvel élément\n   */\n  saveItem: function saveItem() {\n    var type = this.editingType;\n    var id = this.editingId;\n    var mode = this.editingMode;\n    if (!type) return;\n    var success = false;\n    var updatedProfile = false;\n    if (type === 'piece') {\n      var profileValue = document.getElementById('piece-profile').value;\n      // Arrondir la longueur à l'entier\n      var length = Math.round(parseFloat(document.getElementById('piece-length').value));\n      var quantity = parseInt(document.getElementById('piece-quantity').value, 10);\n      // Limiter les angles à 2 décimales\n      var angleStart = parseFloat(parseFloat(document.getElementById('piece-angle-start').value).toFixed(2));\n      var angleEnd = parseFloat(parseFloat(document.getElementById('piece-angle-end').value).toFixed(2));\n      var orientation = document.getElementById('piece-orientation').value;\n      if (profileValue && length && quantity) {\n        if (mode === 'edit') {\n          var piece = this.dataManager.getPieceById(id);\n\n          // Vérifier si c'est un nouveau profil\n          if (piece && piece.profileFull !== profileValue) {\n            updatedProfile = true;\n          }\n          var updatedPiece = {\n            profileFull: profileValue,\n            model: profileValue.split(' ')[0] || profileValue,\n            length: length,\n            quantity: quantity,\n            orientation: orientation,\n            angles: {\n              start: angleStart,\n              end: angleEnd\n            }\n          };\n          success = this.dataManager.updatePiece(id, updatedPiece);\n        } else {\n          var pieceData = {\n            profileFull: profileValue,\n            model: profileValue.split(' ')[0] || profileValue,\n            length: length,\n            quantity: quantity,\n            type: 'fille',\n            orientation: orientation,\n            angles: {\n              start: angleStart,\n              end: angleEnd\n            }\n          };\n          if (this.dataManager.addBars([pieceData]).length > 0) {\n            success = true;\n            updatedProfile = true;\n          }\n        }\n        if (success) {\n          this.renderPiecesTable();\n\n          // Mettre à jour les listes déroulantes de profils si un nouveau profil a été ajouté\n          if (updatedProfile) {\n            this.updateAllProfileSelects();\n          }\n        }\n      }\n    } else if (type === 'stock') {\n      var _profileValue = document.getElementById('stock-profile').value;\n      // Arrondir la longueur à l'entier\n      var _length = Math.round(parseFloat(document.getElementById('stock-length').value));\n      var _quantity = parseInt(document.getElementById('stock-quantity').value, 10);\n      if (_profileValue && _length && _quantity) {\n        if (mode === 'edit') {\n          var bar = this.dataManager.getMotherBarById(id);\n\n          // Vérifier si c'est un nouveau profil\n          if (bar && bar.profileFull !== _profileValue) {\n            updatedProfile = true;\n          }\n          var updatedMotherBar = {\n            profileFull: _profileValue,\n            model: _profileValue.split(' ')[0] || _profileValue,\n            length: _length,\n            quantity: _quantity\n          };\n          success = this.dataManager.updateMotherBar(id, updatedMotherBar);\n        } else {\n          var barData = {\n            profileFull: _profileValue,\n            model: _profileValue.split(' ')[0] || _profileValue,\n            length: _length,\n            quantity: _quantity,\n            type: 'mother'\n          };\n          if (this.dataManager.addBars([barData]).length > 0) {\n            success = true;\n            updatedProfile = true;\n          }\n        }\n        if (success) {\n          this.renderStockBarsTable();\n\n          // Mettre à jour les listes déroulantes de profils si un nouveau profil a été ajouté\n          if (updatedProfile) {\n            this.updateAllProfileSelects();\n          }\n        }\n      }\n    }\n    if (success) {\n      this.closePanel();\n    } else {\n      this.showNotification('Veuillez remplir correctement tous les champs', 'warning');\n    }\n  },\n  /**\n   * Met à jour toutes les listes déroulantes de profils dans l'interface\n   */\n  updateAllProfileSelects: function updateAllProfileSelects() {\n    // Mettre à jour la liste des profils dans le panneau d'ajout/édition de barre mère\n    var stockProfileSelect = document.getElementById('stock-profile');\n    if (stockProfileSelect) {\n      var currentValue = stockProfileSelect.value;\n      stockProfileSelect.innerHTML = this.getProfileOptions(currentValue);\n    }\n\n    // Mettre à jour la liste des profils dans le panneau d'ajout/édition de barre fille\n    var pieceProfileSelect = document.getElementById('piece-profile-select');\n    if (pieceProfileSelect) {\n      var customOption = pieceProfileSelect.querySelector('option[value=\"custom\"]');\n      var _currentValue = pieceProfileSelect.value !== 'custom' ? pieceProfileSelect.value : '';\n\n      // Sauvegarder l'option \"Saisie personnalisée\"\n      var customHtml = customOption ? customOption.outerHTML : '<option value=\"custom\">Saisie personnalisée</option>';\n      pieceProfileSelect.innerHTML = customHtml + this.getProfileOptions(_currentValue);\n    }\n  },\n  /**\n   * Obtient la liste des options de profil pour les selects\n   * @param {string} currentValue - Valeur actuelle pour pré-sélection\n   * @returns {string} HTML des options\n   */\n  getProfileOptions: function getProfileOptions(currentValue) {\n    var data = this.dataManager.getData();\n    var profiles = new Set();\n\n    // Collecter tous les profils uniques\n    var _loop = function _loop(model) {\n      data.pieces[model].forEach(function (piece) {\n        if (piece.profileFull) profiles.add(piece.profileFull);else profiles.add(model);\n      });\n    };\n    for (var model in data.pieces) {\n      _loop(model);\n    }\n    var _loop2 = function _loop2(_model) {\n      data.motherBars[_model].forEach(function (bar) {\n        if (bar.profileFull) profiles.add(bar.profileFull);else profiles.add(_model);\n      });\n    };\n    for (var _model in data.motherBars) {\n      _loop2(_model);\n    }\n\n    // Générer les options HTML\n    var optionsHtml = '';\n    var _iterator = _createForOfIteratorHelper(profiles),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var profile = _step.value;\n        optionsHtml += \"<option value=\\\"\".concat(profile, \"\\\" \").concat(profile === currentValue ? 'selected' : '', \">\").concat(profile, \"</option>\");\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return optionsHtml;\n  },\n  /**\n   * Crée le panneau des barres filles\n   */\n  createPiecePanel: function createPiecePanel() {\n    var _this3 = this;\n    // Vérifier si le panneau existe déjà\n    if (document.getElementById('piece-panel')) return;\n\n    // S'assurer que l'overlay existe\n    if (!document.getElementById('panel-overlay')) {\n      var overlay = document.createElement('div');\n      overlay.id = 'panel-overlay';\n      overlay.className = 'panel-overlay';\n      document.body.appendChild(overlay);\n\n      // Fermer le panneau quand on clique sur l'overlay\n      overlay.addEventListener('click', function () {\n        return _this3.closePanel();\n      });\n    }\n\n    // Créer le panneau\n    var panel = document.createElement('div');\n    panel.id = 'piece-panel';\n    panel.className = 'side-panel piece-panel';\n    panel.innerHTML = \"\\n      <div class=\\\"panel-header\\\">\\n        <h3 class=\\\"panel-title\\\">Barre \\xE0 d\\xE9couper</h3>\\n        <button class=\\\"panel-close\\\">&times;</button>\\n      </div>\\n      <div class=\\\"panel-form\\\">\\n        <!-- Le contenu du formulaire sera g\\xE9n\\xE9r\\xE9 dynamiquement -->\\n      </div>\\n      <div class=\\\"panel-actions\\\">\\n        <button class=\\\"btn btn-secondary cancel-btn\\\">Annuler</button>\\n        <button class=\\\"btn btn-primary save-btn\\\">Enregistrer</button>\\n      </div>\\n    \";\n\n    // Ajouter au DOM\n    document.body.appendChild(panel);\n\n    // Ajouter les gestionnaires d'événements\n    panel.querySelector('.panel-close').addEventListener('click', function () {\n      return _this3.closePanel();\n    });\n    panel.querySelector('.cancel-btn').addEventListener('click', function () {\n      return _this3.closePanel();\n    });\n    panel.querySelector('.save-btn').addEventListener('click', function () {\n      return _this3.saveItem();\n    });\n  },\n  /**\n   * Crée le panneau des barres mères\n   */\n  createStockPanel: function createStockPanel() {\n    var _this4 = this;\n    // Vérifier si le panneau existe déjà\n    if (document.getElementById('stock-panel')) return;\n\n    // S'assurer que l'overlay existe\n    if (!document.getElementById('panel-overlay')) {\n      var overlay = document.createElement('div');\n      overlay.id = 'panel-overlay';\n      overlay.className = 'panel-overlay';\n      document.body.appendChild(overlay);\n\n      // Fermer le panneau quand on clique sur l'overlay\n      overlay.addEventListener('click', function () {\n        return _this4.closePanel();\n      });\n    }\n\n    // Créer le panneau\n    var panel = document.createElement('div');\n    panel.id = 'stock-panel';\n    panel.className = 'side-panel stock-panel';\n    panel.innerHTML = \"\\n      <div class=\\\"panel-header\\\">\\n        <h3 class=\\\"panel-title\\\">Barre m\\xE8re</h3>\\n        <button class=\\\"panel-close\\\">&times;</button>\\n      </div>\\n      <div class=\\\"panel-form\\\">\\n        <!-- Le contenu du formulaire sera g\\xE9n\\xE9r\\xE9 dynamiquement -->\\n      </div>\\n      <div class=\\\"panel-actions\\\">\\n        <button class=\\\"btn btn-secondary cancel-btn\\\">Annuler</button>\\n        <button class=\\\"btn btn-primary save-btn\\\">Enregistrer</button>\\n      </div>\\n    \";\n\n    // Ajouter au DOM\n    document.body.appendChild(panel);\n\n    // Ajouter les gestionnaires d'événements\n    panel.querySelector('.panel-close').addEventListener('click', function () {\n      return _this4.closePanel();\n    });\n    panel.querySelector('.cancel-btn').addEventListener('click', function () {\n      return _this4.closePanel();\n    });\n    panel.querySelector('.save-btn').addEventListener('click', function () {\n      return _this4.saveItem();\n    });\n  }\n};\n\n//# sourceURL=webpack://parser-optimizer/./src/js/ui/edit-handler.js?");

/***/ }),

/***/ "./src/js/ui/import-handler.js":
/*!*************************************!*\
  !*** ./src/js/ui/import-handler.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImportHandler: () => (/* binding */ ImportHandler)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/js/ui/utils.js\");\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2); } }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n/**\n * Gestionnaire de la section d'import\n * Gère le drag & drop et l'import de fichiers\n */\n\nvar ImportHandler = {\n  // Dépendances\n  dataManager: null,\n  importManager: null,\n  editHandler: null,\n  // Callbacks\n  showNotification: null,\n  navigateToSection: null,\n  /**\n   * Initialise le handler d'import\n   */\n  init: function init(options) {\n    this.dataManager = options.dataManager;\n    this.importManager = options.importManager;\n    this.showNotification = options.showNotification;\n    this.navigateToSection = options.navigateToSection;\n    this.editHandler = options.editHandler;\n    this.initDropZone();\n  },\n  /**\n   * Initialise la zone de drop\n   */\n  initDropZone: function initDropZone() {\n    var _this = this;\n    var dropZone = document.querySelector('.file-drop-zone');\n    var fileInput = document.getElementById('nc2-files-input');\n\n    // Ajouter un conteneur pour les erreurs s'il n'existe pas\n    if (!document.getElementById('import-error')) {\n      var errorDiv = document.createElement('div');\n      errorDiv.id = 'import-error';\n      errorDiv.className = 'error-message hidden';\n      dropZone.parentNode.insertBefore(errorDiv, dropZone.nextSibling);\n    }\n\n    // Prévenir les comportements par défaut du navigateur\n    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(function (eventName) {\n      dropZone.addEventListener(eventName, function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n      });\n    });\n\n    // Ajouter/retirer la classe active pendant le drag\n    ['dragenter', 'dragover'].forEach(function (eventName) {\n      dropZone.addEventListener(eventName, function () {\n        return dropZone.classList.add('active');\n      });\n    });\n    ['dragleave', 'drop'].forEach(function (eventName) {\n      dropZone.addEventListener(eventName, function () {\n        return dropZone.classList.remove('active');\n      });\n    });\n\n    // Gérer le drop\n    dropZone.addEventListener('drop', function (e) {\n      return _this.processImportedFiles(e.dataTransfer.files);\n    });\n\n    // Gérer le clic sur l'input file\n    fileInput.addEventListener('change', function () {\n      return _this.processImportedFiles(fileInput.files);\n    });\n  },\n  /**\n   * Traite les fichiers importés\n   */\n  processImportedFiles: function () {\n    var _processImportedFiles = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(files) {\n      var importedBars, addedIds, fileInput, _t;\n      return _regenerator().w(function (_context) {\n        while (1) switch (_context.n) {\n          case 0:\n            if (!(files.length === 0)) {\n              _context.n = 1;\n              break;\n            }\n            return _context.a(2);\n          case 1:\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.UIUtils.showLoadingOverlay();\n            this.hideError();\n            _context.p = 2;\n            _context.n = 3;\n            return this.importManager.processMultipleFiles(files);\n          case 3:\n            importedBars = _context.v;\n            if (importedBars && importedBars.length > 0) {\n              // Ajouter les barres au DataManager\n              addedIds = this.dataManager.addBars(importedBars);\n              if (addedIds.length > 0) {\n                // Rester sur la même section et montrer un message de succès\n                this.showNotification(\"\".concat(addedIds.length, \" barres import\\xE9es avec succ\\xE8s.\"), 'success');\n\n                // Mettre à jour les tableaux d'édition\n                if (this.editHandler) {\n                  this.editHandler.renderSection();\n\n                  // Faire défiler jusqu'à la zone d'édition après un court délai\n                  setTimeout(function () {\n                    var editPanel = document.querySelector('.panels-container');\n                    if (editPanel) {\n                      editPanel.scrollIntoView({\n                        behavior: 'smooth',\n                        block: 'start'\n                      });\n                    }\n                  }, 300); // Délai court pour laisser le temps au DOM de se mettre à jour\n                }\n              } else {\n                this.showError('Aucune nouvelle pièce ajoutée.');\n              }\n            } else {\n              this.showError('Aucune pièce valide trouvée dans les fichiers.');\n            }\n            _context.n = 5;\n            break;\n          case 4:\n            _context.p = 4;\n            _t = _context.v;\n            console.error('Import error:', _t);\n            this.showError(\"Erreur d'import: \".concat(_t.message));\n          case 5:\n            _context.p = 5;\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.UIUtils.hideLoadingOverlay();\n\n            // Réinitialiser l'élément input file pour permettre la réimportation du même fichier\n            fileInput = document.getElementById('nc2-files-input');\n            if (fileInput) {\n              fileInput.value = '';\n            }\n            return _context.f(5);\n          case 6:\n            return _context.a(2);\n        }\n      }, _callee, this, [[2, 4, 5, 6]]);\n    }));\n    function processImportedFiles(_x) {\n      return _processImportedFiles.apply(this, arguments);\n    }\n    return processImportedFiles;\n  }(),\n  /**\n   * Affiche une erreur d'import\n   */\n  showError: function showError(message) {\n    var errorDiv = document.getElementById('import-error');\n    if (errorDiv) {\n      errorDiv.textContent = message;\n      errorDiv.classList.remove('hidden');\n    }\n  },\n  /**\n   * Masque l'erreur d'import\n   */\n  hideError: function hideError() {\n    var errorDiv = document.getElementById('import-error');\n    if (errorDiv) {\n      errorDiv.classList.add('hidden');\n    }\n  }\n};\n\n//# sourceURL=webpack://parser-optimizer/./src/js/ui/import-handler.js?");

/***/ }),

/***/ "./src/js/ui/notification-service.js":
/*!*******************************************!*\
  !*** ./src/js/ui/notification-service.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NotificationService: () => (/* binding */ NotificationService)\n/* harmony export */ });\n/**\n * Service de notification\n * Gère l'affichage des notifications à l'utilisateur\n */\nvar NotificationService = {\n  /**\n   * Initialise le service de notification\n   */\n  init: function init() {\n    // Vérifier si un conteneur de notification existe\n    if (!document.getElementById('notification-container')) {\n      var container = document.createElement('div');\n      container.id = 'notification-container';\n      document.body.appendChild(container);\n    }\n  },\n  /**\n   * Affiche une notification à l'utilisateur\n   * @param {string} message - Message à afficher\n   * @param {string} type - Type de notification ('success', 'warning', 'error', 'info')\n   */\n  show: function show(message) {\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'info';\n    // Obtenir le conteneur de notification\n    var notifContainer = document.getElementById('notification-container');\n\n    // Créer la notification\n    var notification = document.createElement('div');\n    notification.className = \"notification \".concat(type);\n    notification.innerHTML = \"\\n      <span class=\\\"notification-message\\\">\".concat(message, \"</span>\\n      <button class=\\\"notification-close\\\">&times;</button>\\n    \");\n\n    // Ajouter la notification au conteneur\n    notifContainer.appendChild(notification);\n\n    // Configurer le bouton de fermeture\n    notification.querySelector('.notification-close').addEventListener('click', function () {\n      notification.classList.add('hiding');\n      setTimeout(function () {\n        if (notification.parentNode) {\n          notifContainer.removeChild(notification);\n        }\n      }, 300);\n    });\n\n    // Auto-fermeture après 5 secondes pour les notifications non-erreur\n    if (type !== 'error') {\n      setTimeout(function () {\n        if (notification.parentNode) {\n          notification.classList.add('hiding');\n          setTimeout(function () {\n            if (notification.parentNode) {\n              notifContainer.removeChild(notification);\n            }\n          }, 300);\n        }\n      }, 5000);\n    }\n  }\n};\n\n//# sourceURL=webpack://parser-optimizer/./src/js/ui/notification-service.js?");

/***/ }),

/***/ "./src/js/ui/results-handler.js":
/*!**************************************!*\
  !*** ./src/js/ui/results-handler.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResultsHandler: () => (/* binding */ ResultsHandler)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/js/ui/utils.js\");\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2); } }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n/**\n * Gestionnaire de la section résultats\n * Gère le rendu des résultats et la génération des fichiers PGM\n */\n\nvar ResultsHandler = {\n  // Dépendances\n  pgmGenerator: null,\n  dataManager: null,\n  // Callbacks\n  showNotification: null,\n  /**\n   * Initialise le gestionnaire de résultats\n   * @param {Object} options - Options d'initialisation\n   */\n  init: function init(options) {\n    this.pgmGenerator = options.pgmGenerator;\n    this.dataManager = options.dataManager;\n    this.showNotification = options.showNotification;\n  },\n  /**\n   * Génère les aperçus des fichiers PGM\n   * @param {Object} results - Résultats de l'optimisation\n   */\n  generatePgmPreviews: function generatePgmPreviews(results) {\n    var _this = this;\n    try {\n      var container = document.getElementById('pgm-files-list');\n      var html = '';\n\n      // Pour chaque modèle\n      var _loop = function _loop(model) {\n        var modelResults = results.modelResults[model];\n\n        // Pour chaque schéma de coupe\n        modelResults.layouts.forEach(function (layout, index) {\n          var fileName = \"\".concat(model, \"_\").concat(Math.round(layout.barLength), \".pgm\");\n          html += \"\\n            <div class=\\\"pgm-file-item\\\">\\n              <div class=\\\"pgm-file-info\\\">\\n                <span class=\\\"pgm-file-name\\\">\".concat(fileName, \"</span>\\n                <span class=\\\"pgm-file-model\\\">\").concat(model, \"</span>\\n                <span class=\\\"pgm-file-length\\\">Longueur: \").concat(layout.barLength, \"</span>\\n                <span class=\\\"pgm-file-pieces\\\">Pi\\xE8ces: \").concat(layout.cuts ? layout.cuts.length : 0, \"</span>\\n              </div>\\n              <button class=\\\"btn btn-sm btn-primary download-pgm-btn\\\" \\n                      data-model=\\\"\").concat(model, \"\\\" \\n                      data-index=\\\"\").concat(index, \"\\\">\\n                T\\xE9l\\xE9charger\\n              </button>\\n            </div>\\n          \");\n        });\n      };\n      for (var model in results.modelResults) {\n        _loop(model);\n      }\n      container.innerHTML = html;\n\n      // Configurer les boutons de téléchargement\n      container.querySelectorAll('.download-pgm-btn').forEach(function (button) {\n        button.addEventListener('click', function () {\n          var model = button.getAttribute('data-model');\n          var index = parseInt(button.getAttribute('data-index'), 10);\n          var layout = results.modelResults[model].layouts[index];\n          var pgmContent = _this.pgmGenerator.generatePgm(layout, model);\n\n          // Télécharger le fichier\n          _utils_js__WEBPACK_IMPORTED_MODULE_0__.UIUtils.downloadFile(pgmContent, \"\".concat(model, \"_\").concat(Math.round(layout.barLength), \".pgm\"), 'text/plain');\n        });\n      });\n    } catch (error) {\n      console.error('Erreur lors de la génération des aperçus PGM:', error);\n      document.getElementById('pgm-files-list').innerHTML = '<p class=\"error-text\">Une erreur est survenue lors de la génération des aperçus PGM.</p>';\n    }\n  },\n  /**\n   * Télécharge tous les fichiers PGM\n   */\n  downloadAllPgm: function () {\n    var _downloadAllPgm = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {\n      var resultsContainer, results, blob, _t;\n      return _regenerator().w(function (_context) {\n        while (1) switch (_context.n) {\n          case 0:\n            _context.p = 0;\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.UIUtils.showLoadingOverlay();\n\n            // Obtenir les résultats actuels\n            resultsContainer = document.getElementById('results-display');\n            if (resultsContainer.dataset.results) {\n              _context.n = 1;\n              break;\n            }\n            this.showNotification('Aucun résultat disponible', 'warning');\n            return _context.a(2);\n          case 1:\n            results = JSON.parse(resultsContainer.dataset.results); // Générer le ZIP avec tous les fichiers PGM\n            _context.n = 2;\n            return this.pgmGenerator.generateAllPgmFiles(results, this.dataManager);\n          case 2:\n            blob = _context.v;\n            // Télécharger le ZIP\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.UIUtils.downloadFile(blob, 'pgm_files.zip', 'application/zip');\n\n            // Suppression de la notification de succès\n            _context.n = 4;\n            break;\n          case 3:\n            _context.p = 3;\n            _t = _context.v;\n            console.error('Error generating PGM files:', _t);\n            this.showNotification(\"Erreur lors de la g\\xE9n\\xE9ration des fichiers PGM: \".concat(_t.message), 'error');\n          case 4:\n            _context.p = 4;\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.UIUtils.hideLoadingOverlay();\n            return _context.f(4);\n          case 5:\n            return _context.a(2);\n        }\n      }, _callee, this, [[0, 3, 4, 5]]);\n    }));\n    function downloadAllPgm() {\n      return _downloadAllPgm.apply(this, arguments);\n    }\n    return downloadAllPgm;\n  }()\n};\n\n//# sourceURL=webpack://parser-optimizer/./src/js/ui/results-handler.js?");

/***/ }),

/***/ "./src/js/ui/utils.js":
/*!****************************!*\
  !*** ./src/js/ui/utils.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UIUtils: () => (/* binding */ UIUtils)\n/* harmony export */ });\n/**\n * Utilitaires pour l'interface utilisateur\n */\nvar UIUtils = {\n  /**\n   * Affiche l'overlay de chargement\n   */\n  showLoadingOverlay: function showLoadingOverlay() {\n    var overlay = document.getElementById('loading-overlay');\n    if (overlay) {\n      overlay.classList.remove('hidden');\n    }\n  },\n  /**\n   * Masque l'overlay de chargement\n   */\n  hideLoadingOverlay: function hideLoadingOverlay() {\n    var overlay = document.getElementById('loading-overlay');\n    if (overlay) {\n      overlay.classList.add('hidden');\n    }\n  },\n  /**\n   * Télécharge un fichier\n   * @param {Blob|string} content - Contenu du fichier\n   * @param {string} filename - Nom du fichier\n   * @param {string} type - Type MIME\n   */\n  downloadFile: function downloadFile(content, filename, type) {\n    var blob = content instanceof Blob ? content : new Blob([content], {\n      type: type\n    });\n    var url = URL.createObjectURL(blob);\n    var a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }\n};\n\n//# sourceURL=webpack://parser-optimizer/./src/js/ui/utils.js?");

/***/ }),

/***/ "?2632":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://parser-optimizer/fs_(ignored)?");

/***/ }),

/***/ "?2c27":
/*!*******************************!*\
  !*** child_process (ignored) ***!
  \*******************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://parser-optimizer/child_process_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/index.js");
/******/ 	
/******/ })()
;